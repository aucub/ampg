import { makeApi, Zodios, type ZodiosOptions } from "../deps.ts";
import { z } from "../deps.ts";



type request_tracer_trace = Array<Partial<{
	action: string;
	action_parameters: {};
	description: string;
	expression: string;
	kind: string;
	matched: boolean;
	name: string;
	step_name: string;
	trace: request_tracer_trace;
	type: string;
}>>;;

const iam_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const iam_api_response_common = z.object({ errors: iam_messages, messages: iam_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const iam_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const iam_api_response_collection = iam_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: iam_result_info }).partial().passthrough());
const iam_response_collection = iam_api_response_collection.and(z.object({ result: z.array(z.object({}).partial().passthrough()) }).partial().passthrough());
const iam_api_response_common_failure = z.object({ errors: iam_messages, messages: iam_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const urlscanner_create_scan_Body = z.object({ customHeaders: z.record(z.string()).optional(), screenshotsResolutions: z.array(z.enum(["desktop", "mobile", "tablet"])).optional().default(["desktop"]), url: z.string(), visibility: z.enum(["Public", "Unlisted"]).optional().default("Public") }).passthrough();
const nc_challenges_admin_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const nc_challenges_admin_api_response_common = z.object({ errors: nc_challenges_admin_messages, messages: nc_challenges_admin_messages, success: z.boolean() }).passthrough();
const nc_challenges_admin_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).passthrough();
const nc_challenges_admin_bot_fight_mode = z.boolean();
const nc_challenges_admin_clearance_level = z.enum(["no_clearance", "jschallenge", "managed", "interactive"]);
const nc_challenges_admin_created_on = z.string();
const nc_challenges_admin_domains = z.array(z.string());
const nc_challenges_admin_mode = z.enum(["non-interactive", "invisible", "managed"]);
const nc_challenges_admin_modified_on = z.string();
const nc_challenges_admin_name = z.string();
const nc_challenges_admin_offlabel = z.boolean();
const nc_challenges_admin_region = z.literal("world");
const nc_challenges_admin_sitekey = z.string();
const nc_challenges_admin_widget_list = z.object({ bot_fight_mode: nc_challenges_admin_bot_fight_mode, clearance_level: nc_challenges_admin_clearance_level, created_on: nc_challenges_admin_created_on.datetime({ offset: true }), domains: nc_challenges_admin_domains, mode: nc_challenges_admin_mode, modified_on: nc_challenges_admin_modified_on.datetime({ offset: true }), name: nc_challenges_admin_name.min(1).max(254), offlabel: nc_challenges_admin_offlabel, region: nc_challenges_admin_region.default("world"), sitekey: nc_challenges_admin_sitekey.max(32) }).passthrough();
const nc_challenges_admin_api_response_common_failure = z.object({ errors: nc_challenges_admin_messages, messages: nc_challenges_admin_messages, result: z.object({}).partial().passthrough().nullable(), success: z.boolean() }).passthrough();
const nc_challenges_admin_secret = z.string();
const nc_challenges_admin_widget_detail = z.object({ bot_fight_mode: nc_challenges_admin_bot_fight_mode, clearance_level: nc_challenges_admin_clearance_level, created_on: nc_challenges_admin_created_on.datetime({ offset: true }), domains: nc_challenges_admin_domains, mode: nc_challenges_admin_mode, modified_on: nc_challenges_admin_modified_on.datetime({ offset: true }), name: nc_challenges_admin_name.min(1).max(254), offlabel: nc_challenges_admin_offlabel, region: nc_challenges_admin_region.default("world"), secret: nc_challenges_admin_secret, sitekey: nc_challenges_admin_sitekey.max(32) }).passthrough();
const nc_challenges_admin_invalidate_immediately = z.boolean();
const cloudforce_one_time = z.string();
const cloudforce_one_request_type = z.string();
const cloudforce_one_request_status = z.enum(["open", "accepted", "reported", "approved", "completed", "declined"]);
const cloudforce_one_request_list = z.object({ completed_after: cloudforce_one_time.and(z.unknown()).and(z.unknown()).optional(), completed_before: cloudforce_one_time.and(z.unknown()).and(z.unknown()).optional(), created_after: cloudforce_one_time.and(z.unknown()).and(z.unknown()).optional(), created_before: cloudforce_one_time.and(z.unknown()).and(z.unknown()).optional(), page: z.number().int(), per_page: z.number().int(), request_type: cloudforce_one_request_type.optional(), sort_by: z.string().optional(), sort_order: z.enum(["asc", "desc"]).optional(), status: cloudforce_one_request_status.optional() }).passthrough();
const cloudforce_one_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const cloudforce_one_api_response_common = z.object({ errors: cloudforce_one_messages, messages: cloudforce_one_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const cloudforce_one_uuid = z.string();
const cloudforce_one_priority = z.enum(["routine", "high", "urgent"]);
const cloudforce_one_request_readable_id = z.string();
const cloudforce_one_request_summary = z.string();
const cloudforce_one_tlp = z.enum(["clear", "amber", "amber-strict", "green", "red"]);
const cloudforce_one_request_list_item = z.object({ completed: cloudforce_one_time.and(z.unknown()).and(z.unknown()).optional(), created: cloudforce_one_time.and(z.unknown()).and(z.unknown()), id: cloudforce_one_uuid.max(36), message_tokens: z.number().int().optional(), priority: cloudforce_one_priority, readable_id: cloudforce_one_request_readable_id.optional(), request: cloudforce_one_request_type, status: cloudforce_one_request_status.optional(), summary: cloudforce_one_request_summary, tlp: cloudforce_one_tlp, tokens: z.number().int().optional(), updated: cloudforce_one_time.and(z.unknown()).and(z.unknown()) }).passthrough();
const cloudforce_one_api_response_common_failure = cloudforce_one_api_response_common.and(z.object({ errors: z.unknown(), success: z.unknown() }).partial().passthrough());
const cloudforce_one_request_constants = z.object({ priority: z.array(cloudforce_one_priority), status: z.array(cloudforce_one_request_status), tlp: z.array(cloudforce_one_tlp) }).partial().passthrough();
const cloudforce_one_request_content = z.string();
const cloudforce_one_request_edit = z.object({ content: cloudforce_one_request_content, priority: z.string(), request_type: cloudforce_one_request_type, summary: cloudforce_one_request_summary, tlp: cloudforce_one_tlp }).partial().passthrough();
const cloudforce_one_request_item = z.object({ completed: cloudforce_one_time.datetime({ offset: true }).optional(), content: cloudforce_one_request_content, created: cloudforce_one_time.datetime({ offset: true }), id: cloudforce_one_uuid.max(36), message_tokens: z.number().int().optional(), priority: cloudforce_one_time.datetime({ offset: true }), readable_id: cloudforce_one_request_readable_id.optional(), request: cloudforce_one_request_type, status: cloudforce_one_request_status.optional(), summary: cloudforce_one_request_summary, tlp: cloudforce_one_tlp, tokens: z.number().int().optional(), updated: cloudforce_one_time.datetime({ offset: true }) }).passthrough();
const cloudforce_one_priority_list = z.object({ page: z.number().int(), per_page: z.number().int() }).passthrough();
const cloudforce_one_labels = z.array(z.string());
const cloudforce_one_priority_item = z.object({ created: cloudforce_one_time.and(z.unknown()), id: cloudforce_one_uuid.max(36), labels: cloudforce_one_labels, priority: z.number().int(), requirement: z.string(), tlp: cloudforce_one_tlp, updated: cloudforce_one_time.and(z.unknown()) }).passthrough();
const cloudforce_one_priority_edit = z.object({ labels: cloudforce_one_labels, priority: z.number().int(), requirement: z.string(), tlp: cloudforce_one_tlp }).passthrough();
const cloudforce_one_quota = z.object({ anniversary_date: cloudforce_one_time.and(z.unknown()).and(z.unknown()), quarter_anniversary_date: cloudforce_one_time.and(z.unknown()).and(z.unknown()), quota: z.number().int(), remaining: z.number().int() }).partial().passthrough();
const cloudforce_one_request_types = z.array(z.string());
const cloudforce_one_request_message_list = z.object({ after: cloudforce_one_time.and(z.unknown()).and(z.unknown()).optional(), before: cloudforce_one_time.and(z.unknown()).and(z.unknown()).optional(), page: z.number().int(), per_page: z.number().int(), sort_by: z.string().optional(), sort_order: z.enum(["asc", "desc"]).optional() }).passthrough();
const cloudforce_one_message_content = z.string();
const cloudforce_one_request_message_item = z.object({ author: z.string(), content: cloudforce_one_message_content, created: cloudforce_one_time.and(z.unknown()).and(z.unknown()).optional(), id: z.number().int(), is_follow_on_request: z.boolean(), updated: cloudforce_one_time.and(z.unknown()).and(z.unknown()) }).passthrough();
const cloudforce_one_request_message_edit = z.object({ content: cloudforce_one_message_content }).partial().passthrough();
const custom_pages_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const custom_pages_api_response_common = z.object({ errors: custom_pages_messages, messages: custom_pages_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const custom_pages_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const custom_pages_api_response_collection = custom_pages_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: custom_pages_result_info }).partial().passthrough());
const custom_pages_custom_pages_response_collection = custom_pages_api_response_collection.and(z.object({ result: z.array(z.object({}).partial().passthrough()) }).partial().passthrough());
const custom_pages_api_response_common_failure = z.object({ errors: custom_pages_messages, messages: custom_pages_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const custom_pages_api_response_single = custom_pages_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]).nullable() }).partial().passthrough());
const custom_pages_custom_pages_response_single = custom_pages_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const custom_pages_state = z.enum(["default", "customized"]);
const custom_pages_url = z.string();
const d1_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const d1_api_response_common = z.object({ errors: d1_messages, messages: d1_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const d1_api_response_single = d1_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const d1_api_response_common_failure = z.object({ errors: d1_messages, messages: d1_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const d1_file_size = z.number();
const d1_database_name = z.string();
const d1_table_count = z.number();
const d1_database_identifier = z.string();
const d1_database_version = z.string();
const d1_database_details_response = z.object({ created_at: z.unknown(), file_size: d1_file_size, name: d1_database_name.regex(/^[a-z0-9][a-z0-9-_]*$/), num_tables: d1_table_count, uuid: d1_database_identifier, version: d1_database_version.regex(/^(alpha|beta)$/) }).partial().passthrough();
const d1_params = z.array(z.string());
const d1_sql = z.string();
const cloudflare_d1_query_database_Body = z.object({ params: d1_params.optional(), sql: d1_sql }).passthrough();
const d1_query_meta = z.object({ changed_db: z.boolean(), changes: z.number(), duration: z.number(), last_row_id: z.number(), rows_read: z.number(), rows_written: z.number(), size_after: z.number() }).partial().passthrough();
const d1_query_result_response = z.object({ meta: d1_query_meta, results: z.array(z.object({}).partial().passthrough()), success: z.boolean() }).partial().passthrough();
const dns_dns_analytics_api_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const dns_dns_analytics_api_api_response_common = z.object({ errors: dns_dns_analytics_api_messages, messages: dns_dns_analytics_api_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const dns_dns_analytics_api_api_response_single = dns_dns_analytics_api_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const dns_dns_analytics_api_data = z.array(z.object({ dimensions: z.array(z.string()) }).passthrough());
const dns_dns_analytics_api_filters = z.string();
const dns_dns_analytics_api_limit = z.number();
const dns_dns_analytics_api_since = z.string();
const dns_dns_analytics_api_until = z.string();
const dns_dns_analytics_api_query = z.object({ dimensions: z.array(z.string()), filters: dns_dns_analytics_api_filters.optional(), limit: dns_dns_analytics_api_limit.int().default(100000), metrics: z.array(z.string()), since: dns_dns_analytics_api_since.datetime({ offset: true }), sort: z.array(z.string()).optional(), until: dns_dns_analytics_api_until.datetime({ offset: true }) }).passthrough();
const dns_dns_analytics_api_result = z.object({ data: dns_dns_analytics_api_data, data_lag: z.number().gte(0), max: z.object({}).partial().passthrough(), min: z.object({}).partial().passthrough(), query: dns_dns_analytics_api_query, rows: z.number().gte(0), totals: z.object({}).partial().passthrough() }).passthrough();
const dns_dns_analytics_api_report = dns_dns_analytics_api_result.and(z.object({ data: z.unknown() }).passthrough());
const dns_dns_analytics_api_api_response_common_failure = z.object({ errors: dns_dns_analytics_api_messages, messages: dns_dns_analytics_api_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const dns_dns_analytics_api_time_delta = z.enum(["all", "auto", "year", "quarter", "month", "week", "day", "hour", "dekaminute", "minute"]);
const dns_dns_analytics_api_report_bytime = dns_dns_analytics_api_result.and(z.object({ data: z.unknown(), query: z.object({ time_delta: dns_dns_analytics_api_time_delta }).passthrough(), time_intervals: z.array(z.array(z.string())) }).passthrough());
const email_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const email_api_response_common = z.object({ errors: email_messages, messages: email_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const email_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const email_api_response_collection = email_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: email_result_info }).partial().passthrough());
const email_created = z.string();
const email_email = z.string();
const email_destination_address_identifier = z.string();
const email_modified = z.string();
const email_destination_address_tag = z.string();
const email_verified = z.string();
const email_destination_address_properties = z.object({ created: email_created.datetime({ offset: true }), email: email_email.max(90), id: email_destination_address_identifier.max(32), modified: email_modified.datetime({ offset: true }), tag: email_destination_address_tag.max(32), verified: email_verified.datetime({ offset: true }) }).partial().passthrough();
const email_addresses = email_destination_address_properties;
const email_destination_addresses_response_collection = email_api_response_collection.and(z.object({ result: z.array(email_addresses), result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown() }).partial().passthrough() }).partial().passthrough());
const email_create_destination_address_properties = z.object({ email: email_email.max(90) }).passthrough();
const email_api_response_single = email_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const email_destination_address_response_single = email_api_response_single.and(z.object({ result: email_addresses }).partial().passthrough());
const legacy_jhs_schemas_mode = z.enum(["block", "challenge", "whitelist", "js_challenge", "managed_challenge"]);
const filters = z.object({ "configuration.target": z.enum(["ip", "ip_range", "asn", "country"]), "configuration.value": z.string(), match: z.enum(["any", "all"]).default("all"), mode: legacy_jhs_schemas_mode, notes: z.string() }).partial().passthrough().optional();
const egs_pagination_json = z.object({ page: z.number().gte(1).default(1), per_page: z.number().gte(1).lte(1000).default(20) }).partial().passthrough().optional();
const legacy_jhs_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const legacy_jhs_api_response_common = z.object({ errors: legacy_jhs_messages, messages: legacy_jhs_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const legacy_jhs_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const legacy_jhs_api_response_collection = legacy_jhs_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: legacy_jhs_result_info }).partial().passthrough());
const legacy_jhs_response_collection = legacy_jhs_api_response_collection.and(z.object({ result: z.array(z.object({}).partial().passthrough()) }).partial().passthrough());
const legacy_jhs_api_response_common_failure = z.object({ errors: legacy_jhs_messages, messages: legacy_jhs_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const legacy_jhs_ip_configuration = z.object({ target: z.unknown(), value: z.string() }).partial().passthrough();
const legacy_jhs_ipv6_configuration = z.object({ target: z.unknown(), value: z.string() }).partial().passthrough();
const legacy_jhs_cidr_configuration = z.object({ target: z.unknown(), value: z.string() }).partial().passthrough();
const legacy_jhs_asn_configuration = z.object({ target: z.unknown(), value: z.string() }).partial().passthrough();
const legacy_jhs_country_configuration = z.object({ target: z.unknown(), value: z.string() }).partial().passthrough();
const legacy_jhs_schemas_configuration = z.union([legacy_jhs_ip_configuration, legacy_jhs_ipv6_configuration, legacy_jhs_cidr_configuration, legacy_jhs_asn_configuration, legacy_jhs_country_configuration]);
const legacy_jhs_notes = z.string();
const legacy_jhs_api_response_single = legacy_jhs_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]).nullable() }).partial().passthrough());
const legacy_jhs_response_single = legacy_jhs_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const legacy_jhs_common_components_schemas_identifier = z.string();
const legacy_jhs_api_response_single_id = legacy_jhs_api_response_common.and(z.object({ result: z.object({ id: legacy_jhs_common_components_schemas_identifier.max(32) }).passthrough().nullable() }).partial().passthrough());
const legacy_jhs_rule_components_schemas_identifier = z.string();
const legacy_jhs_rule = z.object({ allowed_modes: z.array(legacy_jhs_schemas_mode), configuration: legacy_jhs_schemas_configuration, created_on: z.string().datetime({ offset: true }).optional(), id: legacy_jhs_rule_components_schemas_identifier.max(32), mode: legacy_jhs_schemas_mode, modified_on: z.string().datetime({ offset: true }).optional(), notes: legacy_jhs_notes.optional() }).passthrough();
const legacy_jhs_email = z.string();
const legacy_jhs_schemas_rule = legacy_jhs_rule.and(z.object({ scope: z.object({ email: legacy_jhs_email.max(90), id: legacy_jhs_common_components_schemas_identifier.max(32), type: z.unknown() }).partial().passthrough() }).partial().passthrough());
const magic_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const magic_api_response_common = z.object({ errors: magic_messages, messages: magic_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const magic_api_response_single = magic_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const magic_components_schemas_name = z.string();
const magic_schemas_created_on = z.string();
const magic_interconnect_components_schemas_description = z.string();
const magic_gre = z.object({ cloudflare_endpoint: z.string() }).partial().passthrough();
const magic_schemas_health_check = z.object({ enabled: z.boolean().default(true), rate: z.enum(["low", "mid", "high"]).default("mid"), target: z.string(), type: z.enum(["reply", "request"]).default("reply") }).partial().passthrough();
const magic_schemas_identifier = z.string();
const magic_interface_address = z.string();
const magic_schemas_modified_on = z.string();
const magic_schemas_mtu = z.number();
const magic_interconnect = z.object({ colo_name: magic_components_schemas_name, created_on: magic_schemas_created_on.datetime({ offset: true }), description: magic_interconnect_components_schemas_description, gre: magic_gre, health_check: magic_schemas_health_check, id: magic_schemas_identifier.max(32), interface_address: magic_interface_address, modified_on: magic_schemas_modified_on.datetime({ offset: true }), mtu: magic_schemas_mtu.int().default(1476), name: magic_components_schemas_name }).partial().passthrough();
const magic_components_schemas_tunnels_collection_response = magic_api_response_single.and(z.object({ result: z.object({ interconnects: z.array(magic_interconnect) }).partial().passthrough() }).partial().passthrough());
const magic_api_response_common_failure = z.object({ errors: magic_messages, messages: magic_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const magic_components_schemas_modified_tunnels_collection_response = magic_api_response_single.and(z.object({ result: z.object({ modified: z.boolean(), modified_interconnects: z.array(magic_interconnect) }).partial().passthrough() }).partial().passthrough());
const magic_components_schemas_tunnel_single_response = magic_api_response_single.and(z.object({ result: z.object({ interconnect: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_components_schemas_tunnel_update_request = z.object({ description: magic_interconnect_components_schemas_description, gre: magic_gre, health_check: magic_schemas_health_check, interface_address: magic_interface_address, mtu: magic_schemas_mtu.int().default(1476) }).partial().passthrough();
const magic_components_schemas_tunnel_modified_response = magic_api_response_single.and(z.object({ result: z.object({ modified: z.boolean(), modified_interconnect: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_cloudflare_gre_endpoint = z.string();
const magic_customer_gre_endpoint = z.string();
const magic_schemas_description = z.string();
const magic_health_check = z.object({ direction: z.enum(["unidirectional", "bidirectional"]).default("unidirectional"), enabled: z.boolean().default(true), rate: z.enum(["low", "mid", "high"]).default("mid"), target: z.string(), type: z.enum(["reply", "request"]).default("reply") }).partial().passthrough();
const magic_mtu = z.number();
const magic_name = z.string();
const magic_ttl = z.number();
const magic_gre_tunnel = z.object({ cloudflare_gre_endpoint: magic_cloudflare_gre_endpoint, created_on: magic_schemas_created_on.datetime({ offset: true }).optional(), customer_gre_endpoint: magic_customer_gre_endpoint, description: magic_schemas_description.optional(), health_check: magic_health_check.optional(), id: magic_schemas_identifier.max(32).optional(), interface_address: magic_interface_address, modified_on: magic_schemas_modified_on.datetime({ offset: true }).optional(), mtu: magic_mtu.int().optional().default(1476), name: magic_name, ttl: magic_ttl.int().optional().default(64) }).passthrough();
const magic_tunnels_collection_response = magic_api_response_single.and(z.object({ result: z.object({ gre_tunnels: z.array(magic_gre_tunnel) }).partial().passthrough() }).partial().passthrough());
const magic_modified_tunnels_collection_response = magic_api_response_single.and(z.object({ result: z.object({ modified: z.boolean(), modified_gre_tunnels: z.array(magic_gre_tunnel) }).partial().passthrough() }).partial().passthrough());
const magic_tunnel_deleted_response = magic_api_response_single.and(z.object({ result: z.object({ deleted: z.boolean(), deleted_gre_tunnel: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_tunnel_single_response = magic_api_response_single.and(z.object({ result: z.object({ gre_tunnel: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_tunnel_add_single_request = z.object({ cloudflare_gre_endpoint: magic_cloudflare_gre_endpoint, customer_gre_endpoint: magic_customer_gre_endpoint, description: magic_schemas_description.optional(), health_check: magic_health_check.optional(), interface_address: magic_interface_address, mtu: magic_mtu.int().optional().default(1476), name: magic_name, ttl: magic_ttl.int().optional().default(64) }).passthrough();
const magic_tunnel_update_request = magic_tunnel_add_single_request;
const magic_tunnel_modified_response = magic_api_response_single.and(z.object({ result: z.object({ modified: z.boolean(), modified_gre_tunnel: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_allow_null_cipher = z.boolean();
const magic_cloudflare_ipsec_endpoint = z.string();
const magic_customer_ipsec_endpoint = z.string();
const magic_components_schemas_description = z.string();
const magic_schemas_name = z.string();
const magic_psk_metadata = z.object({ last_generated_on: magic_schemas_modified_on.datetime({ offset: true }) }).partial().passthrough();
const magic_replay_protection = z.boolean();
const magic_tunnel_health_check = z.object({ enabled: z.boolean().default(true), rate: z.enum(["low", "mid", "high"]).default("mid"), target: z.string(), type: z.enum(["reply", "request"]).default("reply") }).partial().passthrough();
const magic_ipsec_tunnel = z.object({ allow_null_cipher: magic_allow_null_cipher.optional(), cloudflare_endpoint: magic_cloudflare_ipsec_endpoint, created_on: magic_schemas_created_on.datetime({ offset: true }).optional(), customer_endpoint: magic_customer_ipsec_endpoint.optional(), description: magic_components_schemas_description.optional(), id: magic_schemas_identifier.max(32).optional(), interface_address: magic_interface_address, modified_on: magic_schemas_modified_on.datetime({ offset: true }).optional(), name: magic_schemas_name, psk_metadata: magic_psk_metadata.optional(), replay_protection: magic_replay_protection.optional(), tunnel_health_check: magic_tunnel_health_check.optional() }).passthrough();
const magic_schemas_tunnels_collection_response = magic_api_response_single.and(z.object({ result: z.object({ ipsec_tunnels: z.array(magic_ipsec_tunnel) }).partial().passthrough() }).partial().passthrough());
const magic_psk = z.string();
const magic_schemas_tunnel_add_single_request = z.object({ cloudflare_endpoint: magic_cloudflare_ipsec_endpoint, customer_endpoint: magic_customer_ipsec_endpoint.optional(), description: magic_components_schemas_description.optional(), health_check: magic_health_check.optional(), interface_address: magic_interface_address, name: magic_schemas_name, psk: magic_psk.optional(), replay_protection: magic_replay_protection.optional() }).passthrough();
const magic_schemas_tunnel_add_request = magic_schemas_tunnel_add_single_request;
const magic_schemas_modified_tunnels_collection_response = magic_api_response_single.and(z.object({ result: z.object({ modified: z.boolean(), modified_ipsec_tunnels: z.array(magic_ipsec_tunnel) }).partial().passthrough() }).partial().passthrough());
const magic_schemas_tunnel_deleted_response = magic_api_response_single.and(z.object({ result: z.object({ deleted: z.boolean(), deleted_ipsec_tunnel: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_schemas_tunnel_single_response = magic_api_response_single.and(z.object({ result: z.object({ ipsec_tunnel: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_schemas_tunnel_update_request = magic_schemas_tunnel_add_single_request;
const magic_schemas_tunnel_modified_response = magic_api_response_single.and(z.object({ result: z.object({ modified: z.boolean(), modified_ipsec_tunnel: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_identifier = z.string();
const magic_psk_generation_response = magic_api_response_single.and(z.object({ result: z.object({ ipsec_tunnel_id: magic_identifier.max(32), psk: magic_psk, psk_metadata: magic_psk_metadata }).partial().passthrough() }).partial().passthrough());
const magic_route_delete_id = z.object({ id: magic_identifier.max(32) }).passthrough();
const magic_route_delete_many_request = z.object({ routes: z.array(magic_route_delete_id) }).passthrough();
const magic_multiple_route_delete_response = magic_api_response_single.and(z.object({ result: z.object({ deleted: z.boolean(), deleted_routes: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_created_on = z.string();
const magic_description = z.string();
const magic_modified_on = z.string();
const magic_nexthop = z.string();
const magic_prefix = z.string();
const magic_priority = z.number();
const magic_colo_name = z.string();
const magic_colo_names = z.array(magic_colo_name);
const magic_colo_region = z.string();
const magic_colo_regions = z.array(magic_colo_region);
const magic_scope = z.object({ colo_names: magic_colo_names, colo_regions: magic_colo_regions }).partial().passthrough();
const magic_weight = z.number();
const magic_route = z.object({ created_on: magic_created_on.datetime({ offset: true }).optional(), description: magic_description.optional(), id: magic_identifier.max(32).optional(), modified_on: magic_modified_on.datetime({ offset: true }).optional(), nexthop: magic_nexthop, prefix: magic_prefix, priority: magic_priority.int(), scope: magic_scope.optional(), weight: magic_weight.int().optional() }).passthrough();
const magic_routes_collection_response = magic_api_response_single.and(z.object({ result: z.object({ routes: z.array(magic_route) }).partial().passthrough() }).partial().passthrough());
const magic_route_add_single_request = z.object({ description: magic_description.optional(), nexthop: magic_nexthop, prefix: magic_prefix, priority: magic_priority.int(), scope: magic_scope.optional(), weight: magic_weight.int().optional() }).passthrough();
const magic_route_update_single_request = z.object({ id: magic_identifier.max(32) }).passthrough().and(magic_route_add_single_request);
const magic_route_update_many_request = z.object({ routes: z.array(magic_route_update_single_request) }).passthrough();
const magic_multiple_route_modified_response = magic_api_response_single.and(z.object({ result: z.object({ modified: z.boolean(), modified_routes: z.array(magic_route) }).partial().passthrough() }).partial().passthrough());
const magic_route_deleted_response = magic_api_response_single.and(z.object({ result: z.object({ deleted: z.boolean(), deleted_route: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_route_single_response = magic_api_response_single.and(z.object({ result: z.object({ route: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_route_update_request = magic_route_add_single_request;
const magic_route_modified_response = magic_api_response_single.and(z.object({ result: z.object({ modified: z.boolean(), modified_route: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const magic_connector_id = z.string();
const magic_site_location = z.object({ lat: z.string(), lon: z.string() }).partial().passthrough();
const magic_site_name = z.string();
const magic_secondary_connector_id = z.string();
const magic_site = z.object({ connector_id: magic_connector_id, description: z.string(), ha_mode: z.boolean(), id: magic_identifier.max(32), location: magic_site_location, name: magic_site_name, secondary_connector_id: magic_secondary_connector_id }).partial().passthrough();
const magic_sites_collection_response = magic_api_response_single.and(z.object({ result: z.object({ sites: z.array(magic_site) }).partial().passthrough() }).partial().passthrough());
const magic_sites_add_single_request = z.object({ site: z.object({ connector_id: magic_connector_id.optional(), description: z.string().optional(), ha_mode: z.boolean().optional(), location: magic_site_location.optional(), name: magic_site_name, secondary_connector_id: magic_secondary_connector_id.optional() }).passthrough() }).partial().passthrough();
const magic_site_single_response = magic_api_response_single.and(z.object({ result: z.object({ site: magic_site }).partial().passthrough() }).partial().passthrough());
const magic_site_deleted_response = magic_api_response_single.and(z.object({ result: z.object({ deleted: z.boolean(), deleted_site: magic_site }).partial().passthrough() }).partial().passthrough());
const magic_site_update_request = z.object({ site: z.object({ connector_id: magic_connector_id, description: z.string(), location: magic_site_location, name: magic_site_name, secondary_connector_id: magic_secondary_connector_id }).partial().passthrough() }).partial().passthrough();
const magic_site_modified_response = magic_api_response_single.and(z.object({ result: z.object({ site: magic_site }).partial().passthrough() }).partial().passthrough());
const magic_port = z.number();
const magic_ip_address = z.string();
const magic_cidr = z.string();
const magic_acl_subnet = z.union([magic_ip_address, magic_cidr]);
const magic_lan_acl_configuration = z.object({ lan_id: z.string(), lan_name: z.string().optional(), ports: z.array(magic_port).optional(), subnets: z.array(magic_acl_subnet).optional() }).passthrough();
const magic_acl = z.object({ description: z.string(), id: magic_identifier.max(32), lan_1: magic_lan_acl_configuration, lan_2: magic_lan_acl_configuration, name: z.string(), protocols: z.array(z.enum(["tcp", "udp", "icmp"])) }).partial().passthrough();
const magic_acls_collection_response = magic_api_response_single.and(z.object({ result: z.object({ acls: z.array(magic_acl) }).partial().passthrough() }).partial().passthrough());
const magic_acls_add_single_request = z.object({ acl: z.object({ description: z.string().optional(), lan_1: magic_lan_acl_configuration, lan_2: magic_lan_acl_configuration, name: z.string(), protocols: z.array(z.enum(["tcp", "udp", "icmp"])).optional() }).passthrough() }).partial().passthrough();
const magic_acl_deleted_response = magic_api_response_single.and(z.object({ result: z.object({ deleted: z.boolean(), deleted_acl: magic_acl }).partial().passthrough() }).partial().passthrough());
const magic_acl_single_response = magic_api_response_single.and(z.object({ result: z.object({ acl: magic_acl }).partial().passthrough() }).partial().passthrough());
const magic_acl_update_request = z.object({ acl: z.object({ description: z.string(), lan_1: magic_lan_acl_configuration, lan_2: magic_lan_acl_configuration, name: z.string(), protocols: z.array(z.enum(["tcp", "udp", "icmp"])) }).partial().passthrough() }).partial().passthrough();
const magic_acl_modified_response = magic_api_response_single.and(z.object({ result: z.object({ acl: magic_acl }).partial().passthrough() }).partial().passthrough());
const magic_nat = z.object({ static_prefix: magic_cidr }).partial().passthrough();
const magic_routed_subnet = z.object({ nat: magic_nat.optional(), next_hop: magic_ip_address, prefix: magic_cidr }).passthrough();
const magic_lan_dhcp_relay = z.object({ server_addresses: z.array(magic_ip_address) }).partial().passthrough();
const magic_lan_dhcp_server = z.object({ dhcp_pool_end: magic_ip_address, dhcp_pool_start: magic_ip_address, dns_server: magic_ip_address, reservations: z.record(z.string()) }).partial().passthrough();
const magic_lan_static_addressing = z.object({ address: magic_cidr, dhcp_relay: magic_lan_dhcp_relay.optional(), dhcp_server: magic_lan_dhcp_server.optional(), secondary_address: magic_cidr.optional(), virtual_address: magic_cidr.optional() }).passthrough();
const magic_vlan_tag = z.number();
const magic_lan = z.object({ description: z.string(), ha_link: z.boolean(), id: magic_identifier.max(32), nat: magic_nat, physport: magic_port.int(), routed_subnets: z.array(magic_routed_subnet), site_id: magic_identifier.max(32), static_addressing: magic_lan_static_addressing, vlan_tag: magic_vlan_tag.int() }).partial().passthrough();
const magic_lans_collection_response = magic_api_response_single.and(z.object({ result: z.object({ lans: z.array(magic_lan) }).partial().passthrough() }).partial().passthrough());
const magic_lans_add_single_request = z.object({ lan: z.object({ description: z.string().optional(), ha_link: z.boolean().optional(), nat: magic_nat.optional(), physport: magic_port.int(), routed_subnets: z.array(magic_routed_subnet).optional(), static_addressing: magic_lan_static_addressing.optional(), vlan_tag: magic_vlan_tag.int() }).passthrough() }).partial().passthrough();
const magic_lan_deleted_response = magic_api_response_single.and(z.object({ result: z.object({ deleted: z.boolean(), deleted_lan: magic_lan }).partial().passthrough() }).partial().passthrough());
const magic_lan_single_response = magic_api_response_single.and(z.object({ result: z.object({ lan: magic_lan }).partial().passthrough() }).partial().passthrough());
const magic_lan_update_request = z.object({ lan: z.object({ description: z.string(), nat: magic_nat, physport: magic_port.int(), routed_subnets: z.array(magic_routed_subnet), static_addressing: magic_lan_static_addressing, vlan_tag: magic_vlan_tag.int() }).partial().passthrough() }).partial().passthrough();
const magic_lan_modified_response = magic_api_response_single.and(z.object({ result: z.object({ lan: magic_lan }).partial().passthrough() }).partial().passthrough());
const magic_wan_static_addressing = z.object({ address: magic_cidr, gateway_address: magic_ip_address, secondary_address: magic_cidr.optional() }).passthrough();
const magic_wan = z.object({ description: z.string(), id: magic_identifier.max(32), physport: magic_port.int(), priority: z.number().int(), site_id: magic_identifier.max(32), static_addressing: magic_wan_static_addressing, vlan_tag: magic_vlan_tag.int() }).partial().passthrough();
const magic_wans_collection_response = magic_api_response_single.and(z.object({ result: z.object({ wans: z.array(magic_wan) }).partial().passthrough() }).partial().passthrough());
const magic_wans_add_single_request = z.object({ wan: z.object({ description: z.string().optional(), physport: magic_port.int(), priority: z.number().int().optional(), static_addressing: magic_wan_static_addressing.optional(), vlan_tag: magic_vlan_tag.int() }).passthrough() }).partial().passthrough();
const magic_wan_deleted_response = magic_api_response_single.and(z.object({ result: z.object({ deleted: z.boolean(), deleted_wan: magic_wan }).partial().passthrough() }).partial().passthrough());
const magic_wan_single_response = magic_api_response_single.and(z.object({ result: z.object({ wan: magic_wan }).partial().passthrough() }).partial().passthrough());
const magic_wan_update_request = z.object({ wan: z.object({ description: z.string(), physport: magic_port.int(), priority: z.number().int(), static_addressing: magic_wan_static_addressing, vlan_tag: magic_vlan_tag.int() }).partial().passthrough() }).partial().passthrough();
const magic_wan_modified_response = magic_api_response_single.and(z.object({ result: z.object({ wan: magic_wan }).partial().passthrough() }).partial().passthrough());
const magic_visibility_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const magic_visibility_api_response_common = z.object({ errors: magic_visibility_messages, messages: magic_visibility_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const magic_visibility_api_response_single = magic_visibility_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const magic_visibility_mnm_config_default_sampling = z.number();
const magic_visibility_mnm_config_name = z.string();
const magic_visibility_mnm_config_router_ip = z.string();
const magic_visibility_mnm_config_router_ips = z.array(magic_visibility_mnm_config_router_ip);
const magic_visibility_mnm_config = z.object({ default_sampling: magic_visibility_mnm_config_default_sampling.gte(1).default(1), name: magic_visibility_mnm_config_name, router_ips: magic_visibility_mnm_config_router_ips }).passthrough();
const magic_visibility_mnm_config_single_response = magic_visibility_api_response_single.and(z.object({ result: magic_visibility_mnm_config }).partial().passthrough());
const magic_visibility_api_response_common_failure = z.object({ errors: magic_visibility_messages, messages: magic_visibility_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const magic_visibility_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const magic_visibility_api_response_collection = magic_visibility_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: magic_visibility_result_info }).partial().passthrough());
const magic_visibility_mnm_rule_automatic_advertisement = z.boolean();
const magic_visibility_mnm_rule_bandwidth_threshold = z.number();
const magic_visibility_mnm_rule_duration = z.string();
const magic_visibility_rule_identifier = z.unknown();
const magic_visibility_mnm_rule_name = z.string();
const magic_visibility_mnm_rule_packet_threshold = z.number();
const magic_visibility_mnm_rule_ip_prefix = z.string();
const magic_visibility_mnm_rule_ip_prefixes = z.array(magic_visibility_mnm_rule_ip_prefix);
const magic_visibility_mnm_rule = z.object({ automatic_advertisement: magic_visibility_mnm_rule_automatic_advertisement.nullable(), bandwidth_threshold: magic_visibility_mnm_rule_bandwidth_threshold.gte(1).optional(), duration: magic_visibility_mnm_rule_duration.default("1m"), id: magic_visibility_rule_identifier.optional(), name: magic_visibility_mnm_rule_name, packet_threshold: magic_visibility_mnm_rule_packet_threshold.gte(1).optional(), prefixes: magic_visibility_mnm_rule_ip_prefixes }).passthrough();
const magic_visibility_mnm_rules_collection_response = magic_visibility_api_response_collection.and(z.object({ result: z.array(magic_visibility_mnm_rule).nullable() }).partial().passthrough());
const magic_visibility_mnm_rules_single_response = magic_visibility_api_response_single.and(z.object({ result: magic_visibility_mnm_rule.nullable() }).partial().passthrough());
const magic_visibility_mnm_rule_advertisable_response = z.object({ automatic_advertisement: magic_visibility_mnm_rule_automatic_advertisement.nullable() }).passthrough();
const magic_visibility_mnm_rule_advertisement_single_response = magic_visibility_api_response_single.and(z.object({ result: magic_visibility_mnm_rule_advertisable_response.nullable() }).partial().passthrough());
const account_request_tracer_request_trace_Body = z.object({ body: z.object({ base64: z.string(), json: z.object({}).partial().passthrough(), plain_text: z.string() }).partial().passthrough().optional(), context: z.object({ bot_score: z.number().int(), geoloc: z.object({ city: z.string(), continent: z.string(), is_eu_country: z.boolean(), iso_code: z.string(), latitude: z.number(), longitude: z.number(), postal_code: z.string(), region_code: z.string(), subdivision_2_iso_code: z.string(), timezone: z.string() }).partial().passthrough(), skip_challenge: z.boolean(), threat_score: z.number().int() }).partial().passthrough().optional(), cookies: z.record(z.string()).optional(), headers: z.record(z.string()).optional(), method: z.string(), protocol: z.string().optional(), skip_response: z.boolean().optional(), url: z.string() }).passthrough();
const request_tracer_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const request_tracer_api_response_common = z.object({ errors: request_tracer_messages, messages: request_tracer_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const request_tracer_trace: z.ZodType<request_tracer_trace> = z.lazy(() => z.array(z.object({ action: z.string().regex(/^[a-z_]+$/), action_parameters: z.object({}).partial().passthrough(), description: z.string(), expression: z.string(), kind: z.string(), matched: z.boolean(), name: z.string(), step_name: z.string(), trace: request_tracer_trace, type: z.string() }).partial().passthrough()));
const request_tracer_api_response_common_failure = z.object({ errors: request_tracer_messages, messages: request_tracer_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const lists_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const lists_api_response_common = z.object({ errors: lists_messages, messages: lists_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown())]), success: z.literal(true) }).passthrough();
const lists_api_response_collection = lists_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable() }).partial().passthrough());
const lists_operation_id = z.string();
const lists_operation = z.object({ completed: z.string().optional(), error: z.string().optional(), id: lists_operation_id, status: z.enum(["pending", "running", "completed", "failed"]) }).passthrough();
const lists_bulk_operation_response_collection = lists_api_response_collection.and(z.object({ result: lists_operation }).partial().passthrough());
const lists_api_response_common_failure = z.object({ errors: lists_messages, messages: lists_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const lists_item_ip = z.string();
const lists_item_redirect = z.object({ include_subdomains: z.boolean().optional(), preserve_path_suffix: z.boolean().optional(), preserve_query_string: z.boolean().optional(), source_url: z.string(), status_code: z.union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)]).optional().default(301), subpath_matching: z.boolean().optional(), target_url: z.string() }).passthrough();
const lists_item_hostname = z.object({ url_hostname: z.string() }).passthrough();
const lists_item_asn = z.number();
const lists_item = z.union([lists_item_ip, lists_item_redirect, lists_item_hostname, lists_item_asn]);
const lists_item_response_collection = lists_api_response_collection.and(z.object({ result: lists_item }).partial().passthrough());
const bill_subs_api_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const bill_subs_api_api_response_common = z.object({ errors: bill_subs_api_messages, messages: bill_subs_api_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const bill_subs_api_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const bill_subs_api_api_response_collection = bill_subs_api_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: bill_subs_api_result_info }).partial().passthrough());
const bill_subs_api_install_id = z.string();
const bill_subs_api_component_value = z.object({ default: z.number(), name: z.string(), price: z.number(), value: z.number() }).partial().passthrough();
const bill_subs_api_component_values = z.array(bill_subs_api_component_value);
const bill_subs_api_currency = z.string();
const bill_subs_api_current_period_end = z.string();
const bill_subs_api_current_period_start = z.string();
const bill_subs_api_frequency = z.enum(["weekly", "monthly", "quarterly", "yearly"]);
const bill_subs_api_schemas_identifier = z.string();
const bill_subs_api_price = z.number();
const bill_subs_api_rate_plan = z.object({ currency: z.string(), externally_managed: z.boolean(), id: z.unknown(), is_contract: z.boolean(), public_name: z.string(), scope: z.string(), sets: z.array(z.string()) }).partial().passthrough();
const bill_subs_api_state = z.enum(["Trial", "Provisioned", "Paid", "AwaitingPayment", "Cancelled", "Failed", "Expired"]);
const bill_subs_api_identifier = z.string();
const bill_subs_api_name = z.string();
const bill_subs_api_zone = z.object({ id: bill_subs_api_identifier.max(32), name: bill_subs_api_name.max(253).regex(/^([a-zA-Z0-9][\-a-zA-Z0-9]*\.)+[\-a-zA-Z0-9]{2,20}$/) }).partial().passthrough();
const bill_subs_api_subscription_v2 = z.object({ app: z.object({ install_id: bill_subs_api_install_id }).partial().passthrough(), component_values: bill_subs_api_component_values, currency: bill_subs_api_currency, current_period_end: bill_subs_api_current_period_end.datetime({ offset: true }), current_period_start: bill_subs_api_current_period_start.datetime({ offset: true }), frequency: bill_subs_api_frequency, id: bill_subs_api_schemas_identifier.max(32), price: bill_subs_api_price, rate_plan: bill_subs_api_rate_plan, state: bill_subs_api_state, zone: bill_subs_api_zone }).partial().passthrough();
const bill_subs_api_subscription = bill_subs_api_subscription_v2;
const bill_subs_api_account_subscription_response_collection = bill_subs_api_api_response_collection.and(z.object({ result: z.array(bill_subs_api_subscription) }).partial().passthrough());
const bill_subs_api_api_response_common_failure = z.object({ errors: bill_subs_api_messages, messages: bill_subs_api_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const bill_subs_api_api_response_single = bill_subs_api_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const bill_subs_api_account_subscription_response_single = bill_subs_api_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const vectorize_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const vectorize_api_response_common = z.object({ errors: vectorize_messages, messages: vectorize_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const vectorize_index_dimensions = z.number();
const vectorize_index_metric = z.enum(["cosine", "euclidean", "dot-product"]);
const vectorize_index_dimension_configuration = z.object({ dimensions: vectorize_index_dimensions.int().gte(1).lte(1536), metric: vectorize_index_metric }).passthrough();
const vectorize_index_description = z.string();
const vectorize_index_name = z.string();
const vectorize_create_index_response = z.object({ config: vectorize_index_dimension_configuration, created_on: z.unknown(), description: vectorize_index_description, modified_on: z.unknown(), name: vectorize_index_name.regex(/^([a-z]+[a-z0-9_-]*[a-z0-9]+)$/) }).partial().passthrough();
const vectorize_api_response_single = vectorize_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]).nullable() }).partial().passthrough());
const vectorize_api_response_common_failure = z.object({ errors: vectorize_messages, messages: vectorize_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const vectorize_index_preset = z.enum(["@cf/baai/bge-small-en-v1.5", "@cf/baai/bge-base-en-v1.5", "@cf/baai/bge-large-en-v1.5", "openai/text-embedding-ada-002", "cohere/embed-multilingual-v2.0"]);
const vectorize_index_preset_configuration = z.object({ preset: vectorize_index_preset }).passthrough();
const vectorize_index_configuration = z.union([vectorize_index_preset_configuration, vectorize_index_dimension_configuration]);
const vectorize_create_index_request = z.object({ config: vectorize_index_configuration.and(z.object({ preset: z.unknown(), dimensions: z.unknown(), metric: z.unknown() }).passthrough()), description: vectorize_index_description.optional(), name: vectorize_index_name.regex(/^([a-z]+[a-z0-9_-]*[a-z0-9]+)$/) }).passthrough();
const vectorize_update_index_request = z.object({ description: vectorize_index_description }).passthrough();
const vectorize_identifier = z.string();
const vectorize_index_delete_vectors_by_id_request = z.object({ ids: z.array(vectorize_identifier) }).partial().passthrough();
const vectorize_index_delete_vectors_by_id_response = z.object({ count: z.number().int(), ids: z.array(vectorize_identifier) }).partial().passthrough();
const vectorize_index_get_vectors_by_id_request = z.object({ ids: z.array(vectorize_identifier) }).partial().passthrough();
const vectorize_index_get_vectors_by_id_response = z.array(z.object({ id: vectorize_identifier.max(32), metadata: z.object({}).partial().passthrough(), namespace: z.string().nullable(), values: z.array(z.number()) }).partial().passthrough());
const vectorize_index_insert_response = z.object({ count: z.number().int(), ids: z.array(vectorize_identifier) }).partial().passthrough();
const vectorize_index_query_request = z.object({ returnMetadata: z.boolean(), returnValues: z.boolean(), topK: z.number().default(5), vector: z.array(z.number()) }).partial().passthrough();
const vectorize_index_query_response = z.object({ count: z.number().int(), matches: z.array(z.object({ id: vectorize_identifier.max(32), metadata: z.object({}).partial().passthrough(), score: z.number(), values: z.array(z.number()) }).partial().passthrough()) }).partial().passthrough();
const vectorize_index_upsert_response = z.object({ count: z.number().int(), ids: z.array(vectorize_identifier) }).partial().passthrough();
const iam_api_response_single = iam_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const iam_response_single = iam_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const iam_common_components_schemas_identifier = z.string();
const iam_account = z.object({ created_on: z.string().datetime({ offset: true }).optional(), id: iam_common_components_schemas_identifier.max(32), name: z.string().max(100), settings: z.object({ default_nameservers: z.enum(["cloudflare.standard", "custom.account", "custom.tenant"]).default("cloudflare.standard"), enforce_twofactor: z.boolean(), use_account_custom_ns_by_default: z.boolean() }).partial().passthrough().optional() }).passthrough();
const iam_components_schemas_account = iam_account;
const addressing_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const addressing_api_response_common = z.object({ errors: addressing_messages, messages: addressing_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const addressing_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const addressing_api_response_collection = addressing_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: addressing_result_info }).partial().passthrough());
const addressing_can_delete = z.boolean();
const addressing_can_modify_ips = z.boolean();
const addressing_timestamp = z.string();
const addressing_default_sni = z.string();
const addressing_schemas_description = z.string();
const addressing_enabled = z.boolean();
const addressing_identifier = z.string();
const addressing_address_maps = z.object({ can_delete: addressing_can_delete, can_modify_ips: addressing_can_modify_ips, created_at: addressing_timestamp.datetime({ offset: true }), default_sni: addressing_default_sni.nullable(), description: addressing_schemas_description.nullable(), enabled: addressing_enabled.nullable(), id: addressing_identifier.max(32), modified_at: addressing_timestamp.datetime({ offset: true }) }).partial().passthrough();
const addressing_components_schemas_response_collection = addressing_api_response_collection.and(z.object({ result: z.array(addressing_address_maps) }).partial().passthrough());
const addressing_api_response_common_failure = z.object({ errors: addressing_messages, messages: addressing_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const addressing_api_response_single = addressing_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const addressing_ip = z.string();
const addressing_address_maps_ip = z.object({ created_at: addressing_timestamp.datetime({ offset: true }), ip: addressing_ip }).partial().passthrough();
const addressing_schemas_ips = z.array(addressing_address_maps_ip);
const addressing_schemas_can_delete = z.boolean();
const addressing_kind = z.enum(["zone", "account"]);
const addressing_address_maps_membership = z.object({ can_delete: addressing_schemas_can_delete, created_at: addressing_timestamp.datetime({ offset: true }), identifier: addressing_identifier.max(32), kind: addressing_kind }).partial().passthrough();
const addressing_memberships = z.array(addressing_address_maps_membership);
const addressing_full_response = addressing_api_response_single.and(z.object({ result: addressing_address_maps.and(z.object({ ips: addressing_schemas_ips, memberships: addressing_memberships }).partial().passthrough()) }).partial().passthrough());
const addressing_components_schemas_single_response = addressing_api_response_single.and(z.object({ result: addressing_address_maps }).partial().passthrough());
const addressing_loa_upload_response = addressing_api_response_single.and(z.object({ result: z.object({ filename: z.string() }).partial().passthrough() }).partial().passthrough());
const addressing_advertised = z.boolean();
const addressing_modified_at_nullable = z.string();
const addressing_approved = z.string();
const addressing_asn = z.number();
const addressing_cidr = z.string();
const addressing_description = z.string();
const addressing_loa_document_identifier = z.string();
const addressing_on_demand_enabled = z.boolean();
const addressing_on_demand_locked = z.boolean();
const addressing_ipam_prefixes = z.object({ account_id: addressing_identifier.max(32), advertised: addressing_advertised.nullable(), advertised_modified_at: addressing_modified_at_nullable.datetime({ offset: true }).nullable(), approved: addressing_approved, asn: addressing_asn.int().nullable(), cidr: addressing_cidr, created_at: addressing_timestamp.datetime({ offset: true }), description: addressing_description.max(1000), id: addressing_identifier.max(32), loa_document_id: addressing_loa_document_identifier.max(32).nullable(), modified_at: addressing_timestamp.datetime({ offset: true }), on_demand_enabled: addressing_on_demand_enabled, on_demand_locked: addressing_on_demand_locked }).partial().passthrough();
const addressing_response_collection = addressing_api_response_collection.and(z.object({ result: z.array(addressing_ipam_prefixes) }).partial().passthrough());
const addressing_single_response = addressing_api_response_single.and(z.object({ result: addressing_ipam_prefixes }).partial().passthrough());
const addressing_bgp_signaling_enabled = z.boolean();
const addressing_bgp_signaling_modified_at = z.string();
const addressing_bgp_signal_opts = z.object({ enabled: addressing_bgp_signaling_enabled, modified_at: addressing_bgp_signaling_modified_at.datetime({ offset: true }).nullable() }).partial().passthrough();
const addressing_bgp_on_demand = z.object({ advertised: addressing_advertised.nullable(), advertised_modified_at: addressing_modified_at_nullable.datetime({ offset: true }).nullable(), on_demand_enabled: addressing_on_demand_enabled, on_demand_locked: addressing_on_demand_locked }).partial().passthrough();
const addressing_ipam_bgp_prefixes = z.object({ asn: addressing_asn.int().nullable(), bgp_signal_opts: addressing_bgp_signal_opts, cidr: addressing_cidr, created_at: addressing_timestamp.datetime({ offset: true }), id: addressing_identifier.max(32), modified_at: addressing_timestamp.datetime({ offset: true }), on_demand: addressing_bgp_on_demand }).partial().passthrough();
const addressing_response_collection_bgp = addressing_api_response_collection.and(z.object({ result: z.array(addressing_ipam_bgp_prefixes) }).partial().passthrough());
const addressing_single_response_bgp = addressing_api_response_single.and(z.object({ result: addressing_ipam_bgp_prefixes }).partial().passthrough());
const addressing_bgp_prefix_update_advertisement = z.object({ on_demand: z.object({ advertised: z.boolean() }).partial().passthrough() }).partial().passthrough();
const addressing_schemas_advertised = z.boolean();
const addressing_advertised_response = addressing_api_response_single.and(z.object({ result: z.object({ advertised: addressing_schemas_advertised, advertised_modified_at: addressing_modified_at_nullable.datetime({ offset: true }).nullable() }).partial().passthrough() }).partial().passthrough());
const addressing_provisioning = z.object({ state: z.enum(["provisioning", "active"]) }).partial().passthrough();
const addressing_service_identifier = z.string();
const addressing_service_name = z.string();
const addressing_service_binding = z.object({ cidr: addressing_cidr, id: addressing_identifier.max(32), provisioning: addressing_provisioning, service_id: addressing_service_identifier.max(32), service_name: addressing_service_name }).partial().passthrough();
const addressing_create_binding_request = z.object({ cidr: addressing_cidr, service_id: addressing_service_identifier.max(32) }).partial().passthrough();
const addressing_delegated_account_identifier = z.string();
const addressing_delegation_identifier = z.string();
const addressing_ipam_delegations = z.object({ cidr: addressing_cidr, created_at: addressing_timestamp.datetime({ offset: true }), delegated_account_id: addressing_delegated_account_identifier.max(32), id: addressing_delegation_identifier.max(32), modified_at: addressing_timestamp.datetime({ offset: true }), parent_prefix_id: addressing_identifier.max(32) }).partial().passthrough();
const addressing_schemas_response_collection = addressing_api_response_collection.and(z.object({ result: z.array(addressing_ipam_delegations) }).partial().passthrough());
const addressing_schemas_single_response = addressing_api_response_single.and(z.object({ result: addressing_ipam_delegations }).partial().passthrough());
const addressing_id_response = addressing_api_response_single.and(z.object({ result: z.object({ id: addressing_delegation_identifier.max(32) }).partial().passthrough() }).partial().passthrough());
const workers_ai_post_run_cf_baai_bge_base_en_v1_5_Body = z.object({ text: z.union([z.string(), z.array(z.string())]) }).passthrough();
const workers_ai_post_run_cf_bytedance_stable_diffusion_xl_lightning_Body = z.object({ guidance: z.number().optional().default(7.5), image: z.array(z.number()).optional(), mask: z.array(z.number()).optional(), num_steps: z.number().int().lte(20).optional().default(20), prompt: z.string(), strength: z.number().optional().default(1) }).passthrough();
const workers_ai_post_run_cf_facebook_bart_large_cnn_Body = z.object({ input_text: z.string(), max_length: z.number().int().optional().default(1024) }).passthrough();
const workers_ai_post_run_cf_meta_m2m100_1_2b_Body = z.object({ source_lang: z.string().optional().default("en"), target_lang: z.string(), text: z.string() }).passthrough();
const workers_ai_post_run_hf_sentence_transformers_all_minilm_l6_v2_Body = z.object({ sentences: z.array(z.string()), source: z.string() }).passthrough();
const aaa_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const aaa_api_response_common = z.object({ errors: aaa_messages, messages: aaa_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const aaa_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const aaa_api_response_collection = aaa_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: aaa_result_info }).partial().passthrough());
const aaa_description = z.string();
const aaa_display_name = z.string();
const aaa_filter_options = z.array(z.unknown());
const aaa_type = z.string();
const aaa_alert_types = z.object({ description: aaa_description, display_name: aaa_display_name, filter_options: aaa_filter_options, type: aaa_type }).partial().passthrough();
const aaa_response_collection = aaa_api_response_collection.and(z.object({ result: z.record(z.array(aaa_alert_types)) }).partial().passthrough());
const aaa_api_response_common_failure = z.object({ errors: aaa_messages, messages: aaa_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const aaa_eligible = z.boolean();
const aaa_ready = z.boolean();
const aaa_schemas_type = z.enum(["email", "pagerduty", "webhook"]);
const aaa_eligibility = z.object({ eligible: aaa_eligible, ready: aaa_ready, type: aaa_schemas_type }).partial().passthrough();
const aaa_schemas_response_collection = aaa_api_response_collection.and(z.object({ result: z.record(z.array(aaa_eligibility)) }).partial().passthrough());
const aaa_uuid = z.string();
const aaa_name = z.string();
const aaa_pagerduty = z.object({ id: aaa_uuid.max(36), name: aaa_name }).partial().passthrough();
const aaa_components_schemas_response_collection = aaa_api_response_collection.and(z.object({ result: z.array(aaa_pagerduty) }).partial().passthrough());
const aaa_api_response_single = aaa_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const aaa_token = z.string();
const aaa_sensitive_id_response = aaa_api_response_single.and(z.object({ result: z.object({ id: aaa_token.max(36) }).partial().passthrough() }).partial().passthrough());
const aaa_id_response = aaa_api_response_single.and(z.object({ result: z.object({ id: aaa_uuid.max(36) }).partial().passthrough() }).partial().passthrough());
const aaa_created_at = z.string();
const aaa_webhook_id = z.string();
const aaa_last_failure = z.string();
const aaa_last_success = z.string();
const aaa_components_schemas_name = z.string();
const aaa_secret = z.string();
const aaa_components_schemas_type = z.enum(["slack", "generic", "gchat"]);
const aaa_url = z.string();
const aaa_webhooks = z.object({ created_at: aaa_created_at.datetime({ offset: true }), id: aaa_webhook_id.max(36), last_failure: aaa_last_failure.datetime({ offset: true }), last_success: aaa_last_success.datetime({ offset: true }), name: aaa_components_schemas_name, secret: aaa_secret, type: aaa_components_schemas_type, url: aaa_url }).partial().passthrough();
const aaa_webhooks_components_schemas_response_collection = aaa_api_response_collection.and(z.object({ result: z.array(aaa_webhooks) }).partial().passthrough());
const aaa_schemas_single_response = aaa_api_response_single.and(z.object({ result: aaa_webhooks }).partial().passthrough());
const aaa_alert_body = z.string();
const aaa_schemas_alert_type = z.string();
const aaa_components_schemas_description = z.string();
const aaa_mechanism = z.string();
const aaa_mechanism_type = z.enum(["email", "pagerduty", "webhook"]);
const aaa_schemas_name = z.string();
const aaa_policy_id = z.string();
const aaa_sent = z.string();
const aaa_history = z.object({ alert_body: aaa_alert_body, alert_type: aaa_schemas_alert_type, description: aaa_components_schemas_description, id: aaa_uuid.max(36), mechanism: aaa_mechanism, mechanism_type: aaa_mechanism_type, name: aaa_schemas_name, policy_id: aaa_policy_id.max(36), sent: aaa_sent.datetime({ offset: true }) }).partial().passthrough();
const aaa_history_components_schemas_response_collection = aaa_api_response_collection.and(z.object({ result: z.array(aaa_history), result_info: z.object({}).partial().passthrough() }).partial().passthrough());
const aaa_alert_type = z.enum(["access_custom_certificate_expiration_type", "advanced_ddos_attack_l4_alert", "advanced_ddos_attack_l7_alert", "advanced_http_alert_error", "bgp_hijack_notification", "billing_usage_alert", "block_notification_block_removed", "block_notification_new_block", "block_notification_review_rejected", "brand_protection_alert", "brand_protection_digest", "clickhouse_alert_fw_anomaly", "clickhouse_alert_fw_ent_anomaly", "custom_ssl_certificate_event_type", "dedicated_ssl_certificate_event_type", "dos_attack_l4", "dos_attack_l7", "expiring_service_token_alert", "failing_logpush_job_disabled_alert", "fbm_auto_advertisement", "fbm_dosd_attack", "fbm_volumetric_attack", "health_check_status_notification", "hostname_aop_custom_certificate_expiration_type", "http_alert_edge_error", "http_alert_origin_error", "incident_alert", "load_balancing_health_alert", "load_balancing_pool_enablement_alert", "logo_match_alert", "magic_tunnel_health_check_event", "maintenance_event_notification", "mtls_certificate_store_certificate_expiration_type", "pages_event_alert", "radar_notification", "real_origin_monitoring", "scriptmonitor_alert_new_code_change_detections", "scriptmonitor_alert_new_hosts", "scriptmonitor_alert_new_malicious_hosts", "scriptmonitor_alert_new_malicious_scripts", "scriptmonitor_alert_new_malicious_url", "scriptmonitor_alert_new_max_length_resource_url", "scriptmonitor_alert_new_resources", "secondary_dns_all_primaries_failing", "secondary_dns_primaries_failing", "secondary_dns_zone_successfully_updated", "secondary_dns_zone_validation_warning", "sentinel_alert", "stream_live_notifications", "traffic_anomalies_alert", "tunnel_health_event", "tunnel_update_event", "universal_ssl_event_type", "web_analytics_metrics_update", "zone_aop_custom_certificate_expiration_type"]);
const aaa_timestamp = z.string();
const aaa_schemas_description = z.string();
const aaa_enabled = z.boolean();
const aaa_filters = z.object({ actions: z.array(z.string()), affected_asns: z.array(z.string()), affected_components: z.array(z.string()), affected_locations: z.array(z.string()), airport_code: z.array(z.string()), alert_trigger_preferences: z.array(z.string()), alert_trigger_preferences_value: z.array(z.enum(["99.0", "98.0", "97.0"])), enabled: z.array(z.string()), environment: z.array(z.string()), event: z.array(z.string()), event_source: z.array(z.string()), event_type: z.array(z.string()), group_by: z.array(z.string()), health_check_id: z.array(z.string()), incident_impact: z.array(z.enum(["INCIDENT_IMPACT_NONE", "INCIDENT_IMPACT_MINOR", "INCIDENT_IMPACT_MAJOR", "INCIDENT_IMPACT_CRITICAL"])), input_id: z.array(z.string()), limit: z.array(z.string()), logo_tag: z.array(z.string()), megabits_per_second: z.array(z.string()), new_health: z.array(z.string()), new_status: z.array(z.string()), packets_per_second: z.array(z.string()), pool_id: z.array(z.string()), product: z.array(z.string()), project_id: z.array(z.string()), protocol: z.array(z.string()), query_tag: z.array(z.string()), requests_per_second: z.array(z.string()), selectors: z.array(z.string()), services: z.array(z.string()), slo: z.array(z.string()), status: z.array(z.string()), target_hostname: z.array(z.string()), target_ip: z.array(z.string()), target_zone_name: z.array(z.string()), traffic_exclusions: z.array(z.literal("security_events")), tunnel_id: z.array(z.string()), tunnel_name: z.array(z.string()), where: z.array(z.string()), zones: z.array(z.string()) }).partial().passthrough();
const aaa_mechanisms = z.record(z.array(z.object({ id: z.union([aaa_uuid, z.string()]) }).partial().passthrough()));
const aaa_policies = z.object({ alert_type: aaa_alert_type, created: aaa_timestamp.datetime({ offset: true }), description: aaa_schemas_description, enabled: aaa_enabled.default(true), filters: aaa_filters, id: aaa_policy_id.max(36), mechanisms: aaa_mechanisms, modified: aaa_timestamp.datetime({ offset: true }), name: aaa_schemas_name }).partial().passthrough();
const aaa_policies_components_schemas_response_collection = aaa_api_response_collection.and(z.object({ result: z.array(aaa_policies) }).partial().passthrough());
const aaa_single_response = aaa_api_response_single.and(z.object({ result: aaa_policies }).partial().passthrough());
const aaa_identifier = z.string();
const aaa_audit_logs = z.object({ action: z.object({ result: z.boolean(), type: z.string() }).partial().passthrough(), actor: z.object({ email: z.string().email(), id: z.string(), ip: z.string(), type: z.enum(["user", "admin", "Cloudflare"]) }).partial().passthrough(), id: z.string(), interface: z.string(), metadata: z.object({}).partial().passthrough(), newValue: z.string(), oldValue: z.string(), owner: z.object({ id: aaa_identifier.max(32) }).partial().passthrough(), resource: z.object({ id: z.string(), type: z.string() }).partial().passthrough(), when: z.string().datetime({ offset: true }) }).partial().passthrough();
const aaa_audit_logs_response_collection = z.union([z.object({ errors: z.object({}).partial().passthrough().nullable(), messages: z.array(z.unknown()), result: z.array(aaa_audit_logs), success: z.boolean() }).partial().passthrough(), aaa_api_response_common]);
const intel_url = z.string();
const intel_url_param = z.object({ url: intel_url.url() }).partial().passthrough();
const phishing_url_scanner_submit_suspicious_url_for_scanning_Body = intel_url_param;
const intel_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const intel_api_response_common = z.object({ errors: intel_messages, messages: intel_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const intel_api_response_single = intel_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const intel_phishing_url_submit = z.object({ excluded_urls: z.array(z.object({ url: z.string() }).partial().passthrough()), skipped_urls: z.array(z.object({ url: z.string(), url_id: z.number().int() }).partial().passthrough()), submitted_urls: z.array(z.object({ url: z.string(), url_id: z.number().int() }).partial().passthrough()) }).partial().passthrough();
const intel_phishing_url_submit_components_schemas_single_response = intel_api_response_single.and(z.object({ result: intel_phishing_url_submit }).partial().passthrough());
const intel_api_response_common_failure = z.object({ errors: intel_messages, messages: intel_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const intel_url_id = z.number();
const url_id_param = z.object({ url_id: intel_url_id.int() }).partial().passthrough().optional();
const intel_phishing_url_info = z.object({ categorizations: z.array(z.object({ category: z.string(), verification_status: z.string() }).partial().passthrough()), model_results: z.array(z.object({ model_name: z.string(), model_score: z.number() }).partial().passthrough()), rule_matches: z.array(z.object({ banning: z.boolean(), blocking: z.boolean(), description: z.string(), name: z.string() }).partial().passthrough()), scan_status: z.object({ last_processed: z.string(), scan_complete: z.boolean(), status_code: z.number().int(), submission_id: z.number().int() }).partial().passthrough(), screenshot_download_signature: z.string(), screenshot_path: z.string(), url: z.string() }).partial().passthrough();
const intel_phishing_url_info_components_schemas_single_response = intel_api_response_single.and(z.object({ result: intel_phishing_url_info }).partial().passthrough());
const calls_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const calls_api_response_common = z.object({ errors: calls_messages, messages: calls_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const calls_created = z.string();
const calls_modified = z.string();
const calls_name = z.string();
const calls_identifier = z.string();
const calls_app = z.object({ created: calls_created.datetime({ offset: true }), modified: calls_modified.datetime({ offset: true }), name: calls_name, uid: calls_identifier.min(32).max(32) }).partial().passthrough();
const calls_app_response_collection = calls_api_response_common.and(z.object({ result: z.array(calls_app) }).partial().passthrough());
const calls_api_response_common_failure = z.object({ errors: calls_messages, messages: calls_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const calls_app_editable_fields = z.object({ name: calls_name }).partial().passthrough();
const calls_api_response_single = calls_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const calls_secret = z.string();
const calls_app_with_secret = z.object({ created: calls_created.datetime({ offset: true }), modified: calls_modified.datetime({ offset: true }), name: calls_name, secret: calls_secret.min(64).max(64), uid: calls_identifier.min(32).max(32) }).partial().passthrough();
const calls_app_response_single_with_secret = calls_api_response_single.and(z.object({ result: calls_app_with_secret }).partial().passthrough());
const calls_app_response_single = calls_api_response_single.and(z.object({ result: calls_app }).partial().passthrough());
const tunnel_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const tunnel_api_response_common = z.object({ errors: tunnel_messages, messages: tunnel_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const tunnel_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const tunnel_api_response_collection = tunnel_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: tunnel_result_info }).partial().passthrough());
const tunnel_cf_account_id = z.string();
const tunnel_version = z.string();
const tunnel_colo_name = z.string();
const tunnel_connection_id = z.string();
const tunnel_is_pending_reconnect = z.boolean();
const tunnel_schemas_connection = z.object({ client_id: z.unknown(), client_version: tunnel_version, colo_name: tunnel_colo_name, id: tunnel_connection_id.max(36), is_pending_reconnect: tunnel_is_pending_reconnect, opened_at: z.string().datetime({ offset: true }), origin_ip: z.string(), uuid: tunnel_connection_id.max(36) }).partial().passthrough();
const tunnel_connections = z.array(tunnel_schemas_connection);
const tunnel_conns_active_at = z.string();
const tunnel_conns_inactive_at = z.string();
const tunnel_created_at = z.string();
const tunnel_deleted_at = z.string();
const tunnel_tunnel_id = z.string();
const tunnel_metadata = z.object({}).partial().passthrough();
const tunnel_tunnel_name = z.string();
const tunnel_remote_config = z.boolean();
const tunnel_status = z.string();
const tunnel_tunnel_type = z.enum(["cfd_tunnel", "warp_connector", "ip_sec", "gre", "cni"]);
const tunnel_cfd_tunnel = z.object({ account_tag: tunnel_cf_account_id.max(32), connections: tunnel_connections, conns_active_at: tunnel_conns_active_at.datetime({ offset: true }).nullable(), conns_inactive_at: tunnel_conns_inactive_at.datetime({ offset: true }).nullable(), created_at: tunnel_created_at.datetime({ offset: true }), deleted_at: tunnel_deleted_at.datetime({ offset: true }).nullable(), id: tunnel_tunnel_id.max(36), metadata: tunnel_metadata, name: tunnel_tunnel_name, remote_config: tunnel_remote_config, status: tunnel_status, tun_type: tunnel_tunnel_type }).partial().passthrough();
const tunnel_warp_connector_tunnel = z.object({ account_tag: tunnel_cf_account_id.max(32), connections: tunnel_connections, conns_active_at: tunnel_conns_active_at.datetime({ offset: true }).nullable(), conns_inactive_at: tunnel_conns_inactive_at.datetime({ offset: true }).nullable(), created_at: tunnel_created_at.datetime({ offset: true }), deleted_at: tunnel_deleted_at.datetime({ offset: true }).nullable(), id: tunnel_tunnel_id.max(36), metadata: tunnel_metadata, name: tunnel_tunnel_name, status: tunnel_status, tun_type: tunnel_tunnel_type }).partial().passthrough();
const tunnel_tunnel_response_collection = tunnel_api_response_collection.and(z.object({ result: z.array(z.union([tunnel_cfd_tunnel, tunnel_warp_connector_tunnel])) }).partial().passthrough());
const tunnel_api_response_common_failure = z.object({ errors: tunnel_messages, messages: tunnel_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const tunnel_config_src = z.enum(["local", "cloudflare"]);
const tunnel_tunnel_secret = z.string();
const cloudflare_tunnel_create_a_cloudflare_tunnel_Body = z.object({ config_src: tunnel_config_src.optional().default("local"), name: tunnel_tunnel_name, tunnel_secret: tunnel_tunnel_secret.optional() }).passthrough();
const tunnel_tunnel_response_single = tunnel_api_response_common.and(z.object({ result: z.union([tunnel_cfd_tunnel, tunnel_warp_connector_tunnel]) }).partial().passthrough());
const cloudflare_tunnel_update_a_cloudflare_tunnel_Body = z.object({ name: tunnel_tunnel_name, tunnel_secret: tunnel_tunnel_secret }).partial().passthrough();
const tunnel_config_response_single = tunnel_api_response_common.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const tunnel_originRequest = z.object({ access: z.object({ audTag: z.array(z.string()), required: z.boolean().optional(), teamName: z.string().default("Your Zero Trust authentication domain.") }).passthrough(), caPool: z.string(), connectTimeout: z.number().int().default(10), disableChunkedEncoding: z.boolean(), http2Origin: z.boolean(), httpHostHeader: z.string(), keepAliveConnections: z.number().int().default(100), keepAliveTimeout: z.number().int().default(90), noHappyEyeballs: z.boolean(), noTLSVerify: z.boolean(), originServerName: z.string(), proxyType: z.string(), tcpKeepAlive: z.number().int().default(30), tlsTimeout: z.number().int().default(10) }).partial().passthrough();
const tunnel_ingressRule = z.object({ hostname: z.string(), originRequest: tunnel_originRequest.optional(), path: z.string().optional(), service: z.string() }).passthrough();
const tunnel_config = z.object({ ingress: z.array(tunnel_ingressRule), originRequest: tunnel_originRequest, "warp-routing": z.object({ enabled: z.boolean() }).partial().passthrough() }).partial().passthrough();
const cloudflare_tunnel_configuration_put_configuration_Body = z.object({ config: tunnel_config }).partial().passthrough();
const tunnel_empty_response = tunnel_api_response_common.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const tunnel_arch = z.string();
const tunnel_config_version = z.number();
const tunnel_features = z.array(z.string());
const tunnel_run_at = z.string();
const tunnel_tunnel_client = z.object({ arch: tunnel_arch, config_version: tunnel_config_version.int(), conns: tunnel_connections, features: tunnel_features, id: tunnel_connection_id.max(36), run_at: tunnel_run_at.datetime({ offset: true }), version: tunnel_version }).partial().passthrough();
const tunnel_tunnel_connections_response = tunnel_api_response_collection.and(z.object({ result: z.array(tunnel_tunnel_client) }).partial().passthrough());
const tunnel_tunnel_client_response = tunnel_api_response_common.and(z.object({ result: tunnel_tunnel_client }).partial().passthrough());
const tunnel_management_resources = z.literal("logs");
const cloudflare_tunnel_get_a_cloudflare_tunnel_management_token_Body = z.object({ resources: z.array(tunnel_management_resources) }).passthrough();
const tunnel_tunnel_response_token = tunnel_api_response_common.and(z.object({ result: z.string() }).partial().passthrough());
const dns_custom_nameservers_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const dns_custom_nameservers_api_response_common = z.object({ errors: dns_custom_nameservers_messages, messages: dns_custom_nameservers_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const dns_custom_nameservers_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const dns_custom_nameservers_api_response_collection = dns_custom_nameservers_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: dns_custom_nameservers_result_info }).partial().passthrough());
const dns_custom_nameservers_ns_name = z.string();
const dns_custom_nameservers_ns_set = z.number();
const dns_custom_nameservers_schemas_identifier = z.string();
const dns_custom_nameservers_CustomNS = z.object({ dns_records: z.array(z.object({ type: z.enum(["A", "AAAA"]), value: z.string() }).partial().passthrough()), ns_name: dns_custom_nameservers_ns_name.url(), ns_set: dns_custom_nameservers_ns_set.gte(1).lte(5).optional().default(1), status: z.enum(["moved", "pending", "verified"]), zone_tag: dns_custom_nameservers_schemas_identifier.max(32) }).passthrough();
const dns_custom_nameservers_acns_response_collection = dns_custom_nameservers_api_response_collection.and(z.object({ result: z.array(dns_custom_nameservers_CustomNS) }).partial().passthrough());
const dns_custom_nameservers_api_response_common_failure = z.object({ errors: dns_custom_nameservers_messages, messages: dns_custom_nameservers_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const dns_custom_nameservers_CustomNSInput = z.object({ ns_name: dns_custom_nameservers_ns_name.url(), ns_set: dns_custom_nameservers_ns_set.gte(1).lte(5).optional().default(1) }).passthrough();
const dns_custom_nameservers_api_response_single = dns_custom_nameservers_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const dns_custom_nameservers_acns_response_single = dns_custom_nameservers_api_response_single.and(z.object({ result: dns_custom_nameservers_CustomNS }).partial().passthrough());
const dns_custom_nameservers_availability_response = dns_custom_nameservers_api_response_collection.and(z.object({ result: z.array(z.string()) }).partial().passthrough());
const dns_custom_nameservers_empty_response = dns_custom_nameservers_api_response_collection.and(z.object({ result: z.array(z.unknown()) }).partial().passthrough());
const d1_create_database_response = z.object({ created_at: z.unknown(), name: d1_database_name.regex(/^[a-z0-9][a-z0-9-_]*$/), uuid: d1_database_identifier, version: d1_database_version.regex(/^(alpha|beta)$/) }).partial().passthrough();
const cloudflare_d1_create_database_Body = z.object({ name: d1_database_name.regex(/^[a-z0-9][a-z0-9-_]*$/) }).passthrough();
const teams_devices_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const teams_devices_api_response_common = z.object({ errors: teams_devices_messages, messages: teams_devices_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const teams_devices_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const teams_devices_api_response_collection = teams_devices_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: teams_devices_result_info }).partial().passthrough());
const teams_devices_created = z.string();
const teams_devices_deleted = z.boolean();
const teams_devices_platform = z.enum(["windows", "mac", "linux", "android", "ios"]);
const teams_devices_schemas_uuid = z.string();
const teams_devices_ip = z.string();
const teams_devices_key = z.string();
const teams_devices_last_seen = z.string();
const teams_devices_mac_address = z.string();
const teams_devices_manufacturer = z.string();
const teams_devices_model = z.string();
const teams_devices_schemas_name = z.string();
const teams_devices_os_distro_name = z.string();
const teams_devices_os_distro_revision = z.string();
const teams_devices_os_version = z.string();
const teams_devices_os_version_extra = z.string();
const teams_devices_revoked_at = z.string();
const teams_devices_serial_number = z.string();
const teams_devices_updated = z.string();
const teams_devices_email = z.string();
const teams_devices_components_schemas_uuid = z.string();
const teams_devices_user = z.object({ email: teams_devices_email.max(90), id: teams_devices_components_schemas_uuid.max(36), name: z.string() }).partial().passthrough();
const teams_devices_version = z.string();
const teams_devices_devices = z.object({ created: teams_devices_created.datetime({ offset: true }), deleted: teams_devices_deleted, device_type: teams_devices_platform, id: teams_devices_schemas_uuid.max(36), ip: teams_devices_ip, key: teams_devices_key, last_seen: teams_devices_last_seen.datetime({ offset: true }), mac_address: teams_devices_mac_address, manufacturer: teams_devices_manufacturer, model: teams_devices_model, name: teams_devices_schemas_name, os_distro_name: teams_devices_os_distro_name, os_distro_revision: teams_devices_os_distro_revision, os_version: teams_devices_os_version, os_version_extra: teams_devices_os_version_extra, revoked_at: teams_devices_revoked_at.datetime({ offset: true }), serial_number: teams_devices_serial_number, updated: teams_devices_updated.datetime({ offset: true }), user: teams_devices_user, version: teams_devices_version }).partial().passthrough();
const teams_devices_devices_response = teams_devices_api_response_collection.and(z.object({ result: z.array(teams_devices_devices) }).partial().passthrough());
const teams_devices_api_response_common_failure = z.object({ errors: teams_devices_messages, messages: teams_devices_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const teams_devices_api_response_collection_common = teams_devices_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable() }).partial().passthrough());
const teams_devices_device_dex_test_schemas_data = z.object({ host: z.string(), kind: z.string(), method: z.string() }).partial().passthrough();
const teams_devices_device_dex_test_schemas_description = z.string();
const teams_devices_device_dex_test_schemas_enabled = z.boolean();
const teams_devices_device_dex_test_schemas_interval = z.string();
const teams_devices_device_dex_test_schemas_name = z.string();
const teams_devices_device_dex_test_schemas_http = z.object({ data: teams_devices_device_dex_test_schemas_data, description: teams_devices_device_dex_test_schemas_description.optional(), enabled: teams_devices_device_dex_test_schemas_enabled, interval: teams_devices_device_dex_test_schemas_interval, name: teams_devices_device_dex_test_schemas_name }).passthrough();
const teams_devices_dex_response_collection = teams_devices_api_response_collection_common.and(z.object({ result: z.array(teams_devices_device_dex_test_schemas_http) }).partial().passthrough());
const teams_devices_api_response_single = teams_devices_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]).nullable() }).partial().passthrough());
const teams_devices_dex_single_response = teams_devices_api_response_single.and(z.object({ result: teams_devices_device_dex_test_schemas_http }).partial().passthrough());
const teams_devices_tls_config_response = z.object({ sha256: z.string().optional(), tls_sockaddr: z.string() }).passthrough();
const teams_devices_schemas_config_response = teams_devices_tls_config_response;
const teams_devices_device_managed_networks_components_schemas_name = z.string();
const teams_devices_uuid = z.string();
const teams_devices_components_schemas_type = z.literal("tls");
const teams_devices_device_managed_networks = z.object({ config: teams_devices_schemas_config_response, name: teams_devices_device_managed_networks_components_schemas_name, network_id: teams_devices_uuid.max(36), type: teams_devices_components_schemas_type }).partial().passthrough();
const teams_devices_components_schemas_response_collection = teams_devices_api_response_collection.and(z.object({ result: z.array(teams_devices_device_managed_networks) }).partial().passthrough());
const teams_devices_tls_config_request = z.object({ sha256: z.string().optional(), tls_sockaddr: z.string() }).passthrough();
const teams_devices_schemas_config_request = teams_devices_tls_config_request;
const teams_devices_components_schemas_single_response = teams_devices_api_response_single.and(z.object({ result: teams_devices_device_managed_networks }).partial().passthrough());
const teams_devices_allow_mode_switch = z.boolean();
const teams_devices_allow_updates = z.boolean();
const teams_devices_allowed_to_leave = z.boolean();
const teams_devices_auto_connect = z.number();
const teams_devices_captive_portal = z.number();
const teams_devices_default = z.boolean();
const teams_devices_schemas_description = z.string();
const teams_devices_disable_auto_fallback = z.boolean();
const teams_devices_split_tunnel = z.object({ address: z.string(), description: z.string().max(100), host: z.string().optional() }).passthrough();
const teams_devices_exclude = z.array(teams_devices_split_tunnel);
const teams_devices_exclude_office_ips = z.boolean();
const teams_devices_fallback_domain = z.object({ description: z.string().max(100).optional(), dns_server: z.array(z.unknown()).optional(), suffix: z.string() }).passthrough();
const teams_devices_fallback_domains = z.array(teams_devices_fallback_domain);
const teams_devices_gateway_unique_id = z.string();
const teams_devices_split_tunnel_include = z.object({ address: z.string(), description: z.string().max(100), host: z.string().optional() }).passthrough();
const teams_devices_include = z.array(teams_devices_split_tunnel_include);
const teams_devices_lan_allow_minutes = z.number();
const teams_devices_lan_allow_subnet_size = z.number();
const teams_devices_schemas_match = z.string();
const teams_devices_precedence = z.number();
const teams_devices_service_mode_v2 = z.object({ mode: z.string(), port: z.number() }).partial().passthrough();
const teams_devices_support_url = z.string();
const teams_devices_switch_locked = z.boolean();
const teams_devices_device_settings_policy = z.object({ allow_mode_switch: teams_devices_allow_mode_switch, allow_updates: teams_devices_allow_updates, allowed_to_leave: teams_devices_allowed_to_leave, auto_connect: teams_devices_auto_connect, captive_portal: teams_devices_captive_portal, default: teams_devices_default, description: teams_devices_schemas_description.max(500), disable_auto_fallback: teams_devices_disable_auto_fallback, enabled: z.boolean(), exclude: teams_devices_exclude, exclude_office_ips: teams_devices_exclude_office_ips, fallback_domains: teams_devices_fallback_domains, gateway_unique_id: teams_devices_gateway_unique_id, include: teams_devices_include, lan_allow_minutes: teams_devices_lan_allow_minutes, lan_allow_subnet_size: teams_devices_lan_allow_subnet_size, match: teams_devices_schemas_match.max(500), name: z.string().max(100), policy_id: teams_devices_schemas_uuid.max(36), precedence: teams_devices_precedence, service_mode_v2: teams_devices_service_mode_v2, support_url: teams_devices_support_url, switch_locked: teams_devices_switch_locked }).partial().passthrough();
const teams_devices_device_settings_response_collection = teams_devices_api_response_collection.and(z.object({ result: z.array(teams_devices_device_settings_policy) }).partial().passthrough());
const teams_devices_default_device_settings_policy = z.object({ allow_mode_switch: teams_devices_allow_mode_switch, allow_updates: teams_devices_allow_updates, allowed_to_leave: teams_devices_allowed_to_leave, auto_connect: teams_devices_auto_connect, captive_portal: teams_devices_captive_portal, default: z.boolean(), disable_auto_fallback: teams_devices_disable_auto_fallback, enabled: z.boolean(), exclude: teams_devices_exclude, exclude_office_ips: teams_devices_exclude_office_ips, fallback_domains: teams_devices_fallback_domains, gateway_unique_id: teams_devices_gateway_unique_id, include: teams_devices_include, service_mode_v2: teams_devices_service_mode_v2, support_url: teams_devices_support_url, switch_locked: teams_devices_switch_locked }).partial().passthrough();
const teams_devices_default_device_settings_response = teams_devices_api_response_collection.and(z.object({ result: teams_devices_default_device_settings_policy }).partial().passthrough());
const teams_devices_device_settings_response = teams_devices_api_response_collection.and(z.object({ result: teams_devices_device_settings_policy }).partial().passthrough());
const teams_devices_split_tunnel_response_collection = teams_devices_api_response_collection.and(z.object({ result: z.array(teams_devices_split_tunnel) }).partial().passthrough());
const teams_devices_fallback_domain_response_collection = teams_devices_api_response_collection.and(z.object({ result: z.array(teams_devices_fallback_domain) }).partial().passthrough());
const teams_devices_split_tunnel_include_response_collection = teams_devices_api_response_collection.and(z.object({ result: z.array(teams_devices_split_tunnel_include) }).partial().passthrough());
const teams_devices_description = z.string();
const teams_devices_expiration = z.string();
const teams_devices_file_input_request = z.object({ exists: z.boolean().optional(), operating_system: z.enum(["windows", "linux", "mac"]), path: z.string(), sha256: z.string().optional(), thumbprint: z.string().optional() }).passthrough();
const teams_devices_unique_client_id_input_request = z.object({ id: z.string(), operating_system: z.enum(["android", "ios", "chromeos"]) }).passthrough();
const teams_devices_domain_joined_input_request = z.object({ domain: z.string().optional(), operating_system: z.literal("windows") }).passthrough();
const teams_devices_os_version_input_request = z.object({ operating_system: z.literal("windows"), operator: z.enum(["<", "<=", ">", ">=", "=="]), os_distro_name: z.string().optional(), os_distro_revision: z.string().optional(), os_version_extra: z.string().optional(), version: z.string() }).passthrough();
const teams_devices_firewall_input_request = z.object({ enabled: z.boolean(), operating_system: z.enum(["windows", "mac"]) }).passthrough();
const teams_devices_sentinelone_input_request = z.object({ operating_system: z.enum(["windows", "linux", "mac"]), path: z.string(), sha256: z.string().optional(), thumbprint: z.string().optional() }).passthrough();
const teams_devices_carbonblack_input_request = z.object({ operating_system: z.enum(["windows", "linux", "mac"]), path: z.string(), sha256: z.string().optional(), thumbprint: z.string().optional() }).passthrough();
const teams_devices_checkDisks = z.array(z.string());
const teams_devices_requireAll = z.boolean();
const teams_devices_disk_encryption_input_request = z.object({ checkDisks: teams_devices_checkDisks, requireAll: teams_devices_requireAll }).partial().passthrough();
const teams_devices_application_input_request = z.object({ operating_system: z.enum(["windows", "linux", "mac"]), path: z.string(), sha256: z.string().optional(), thumbprint: z.string().optional() }).passthrough();
const teams_devices_client_certificate_input_request = z.object({ certificate_id: z.string().max(36), cn: z.string() }).passthrough();
const teams_devices_workspace_one_input_request = z.object({ compliance_status: z.enum(["compliant", "noncompliant", "unknown"]), connection_id: z.string() }).passthrough();
const teams_devices_crowdstrike_input_request = z.object({ connection_id: z.string(), last_seen: z.string().optional(), operator: z.enum(["<", "<=", ">", ">=", "=="]).optional(), os: z.string().optional(), overall: z.string().optional(), sensor_config: z.string().optional(), state: z.enum(["online", "offline", "unknown"]).optional(), version: z.string().optional(), versionOperator: z.enum(["<", "<=", ">", ">=", "=="]).optional() }).passthrough();
const teams_devices_intune_input_request = z.object({ compliance_status: z.enum(["compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error"]), connection_id: z.string() }).passthrough();
const teams_devices_kolide_input_request = z.object({ connection_id: z.string(), countOperator: z.enum(["<", "<=", ">", ">=", "=="]), issue_count: z.string() }).passthrough();
const teams_devices_tanium_input_request = z.object({ connection_id: z.string(), eid_last_seen: z.string().optional(), operator: z.enum(["<", "<=", ">", ">=", "=="]).optional(), risk_level: z.enum(["low", "medium", "high", "critical"]).optional(), scoreOperator: z.enum(["<", "<=", ">", ">=", "=="]).optional(), total_score: z.number().optional() }).passthrough();
const teams_devices_sentinelone_s2s_input_request = z.object({ active_threats: z.number().optional(), connection_id: z.string(), infected: z.boolean().optional(), is_active: z.boolean().optional(), network_status: z.enum(["connected", "disconnected", "disconnecting", "connecting"]).optional(), operator: z.enum(["<", "<=", ">", ">=", "=="]).optional() }).passthrough();
const teams_devices_input = z.union([teams_devices_file_input_request, teams_devices_unique_client_id_input_request, teams_devices_domain_joined_input_request, teams_devices_os_version_input_request, teams_devices_firewall_input_request, teams_devices_sentinelone_input_request, teams_devices_carbonblack_input_request, teams_devices_disk_encryption_input_request, teams_devices_application_input_request, teams_devices_client_certificate_input_request, teams_devices_workspace_one_input_request, teams_devices_crowdstrike_input_request, teams_devices_intune_input_request, teams_devices_kolide_input_request, teams_devices_tanium_input_request, teams_devices_sentinelone_s2s_input_request]);
const teams_devices_match_item = z.object({ platform: teams_devices_platform }).partial().passthrough();
const teams_devices_match = z.array(teams_devices_match_item);
const teams_devices_name = z.string();
const teams_devices_schedule = z.string();
const teams_devices_type = z.enum(["file", "application", "tanium", "gateway", "warp", "disk_encryption", "sentinelone", "carbonblack", "firewall", "os_version", "domain_joined", "client_certificate", "unique_client_id", "kolide", "tanium_s2s", "crowdstrike_s2s", "intune", "workspace_one", "sentinelone_s2s"]);
const teams_devices_device_posture_rules = z.object({ description: teams_devices_description, expiration: teams_devices_expiration, id: teams_devices_uuid.max(36), input: teams_devices_input, match: teams_devices_match, name: teams_devices_name, schedule: teams_devices_schedule, type: teams_devices_type }).partial().passthrough();
const teams_devices_response_collection = teams_devices_api_response_collection.and(z.object({ result: z.array(teams_devices_device_posture_rules) }).partial().passthrough());
const teams_devices_single_response = teams_devices_api_response_single.and(z.object({ result: teams_devices_device_posture_rules }).partial().passthrough());
const teams_devices_workspace_one_config_response = z.object({ api_url: z.string(), auth_url: z.string(), client_id: z.string() }).passthrough();
const teams_devices_config_response = teams_devices_workspace_one_config_response;
const teams_devices_interval = z.string();
const teams_devices_components_schemas_name = z.string();
const teams_devices_schemas_type = z.enum(["workspace_one", "crowdstrike_s2s", "uptycs", "intune", "kolide", "tanium", "sentinelone_s2s"]);
const teams_devices_device_posture_integrations = z.object({ config: teams_devices_config_response, id: teams_devices_uuid.max(36), interval: teams_devices_interval, name: teams_devices_components_schemas_name, type: teams_devices_schemas_type }).partial().passthrough();
const teams_devices_schemas_response_collection = teams_devices_api_response_collection.and(z.object({ result: z.array(teams_devices_device_posture_integrations) }).partial().passthrough());
const teams_devices_workspace_one_config_request = z.object({ api_url: z.string(), auth_url: z.string(), client_id: z.string(), client_secret: z.string() }).passthrough();
const teams_devices_crowdstrike_config_request = z.object({ api_url: z.string(), client_id: z.string(), client_secret: z.string(), customer_id: z.string() }).passthrough();
const teams_devices_uptycs_config_request = z.object({ api_url: z.string(), client_key: z.string(), client_secret: z.string(), customer_id: z.string() }).passthrough();
const teams_devices_intune_config_request = z.object({ client_id: z.string(), client_secret: z.string(), customer_id: z.string() }).passthrough();
const teams_devices_kolide_config_request = z.object({ client_id: z.string(), client_secret: z.string() }).passthrough();
const teams_devices_tanium_config_request = z.object({ access_client_id: z.string().optional(), access_client_secret: z.string().optional(), api_url: z.string(), client_secret: z.string() }).passthrough();
const teams_devices_sentinelone_s2s_config_request = z.object({ api_url: z.string(), client_secret: z.string() }).passthrough();
const teams_devices_config_request = z.union([teams_devices_workspace_one_config_request, teams_devices_crowdstrike_config_request, teams_devices_uptycs_config_request, teams_devices_intune_config_request, teams_devices_kolide_config_request, teams_devices_tanium_config_request, teams_devices_sentinelone_s2s_config_request]);
const teams_devices_schemas_single_response = teams_devices_api_response_single.and(z.object({ result: teams_devices_device_posture_integrations }).partial().passthrough());
const teams_devices_schemas_id_response = teams_devices_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough());
const teams_devices_id_response = teams_devices_api_response_single.and(z.object({ result: z.object({ id: teams_devices_uuid.max(36) }).partial().passthrough() }).partial().passthrough());
const teams_devices_revoke_devices_request = z.array(teams_devices_schemas_uuid);
const teams_devices_zero_trust_account_device_settings = z.object({ gateway_proxy_enabled: z.boolean(), gateway_udp_proxy_enabled: z.boolean(), root_certificate_installation_enabled: z.boolean(), use_zt_virtual_ip: z.boolean() }).partial().passthrough();
const teams_devices_zero_trust_account_device_settings_response = teams_devices_api_response_single.and(z.object({ result: teams_devices_zero_trust_account_device_settings }).partial().passthrough());
const teams_devices_unrevoke_devices_request = z.array(teams_devices_schemas_uuid);
const teams_devices_device_response = teams_devices_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const teams_devices_disable_for_time = z.object({ "1": z.unknown(), "3": z.unknown(), "6": z.unknown(), "12": z.unknown(), "24": z.unknown() }).partial().passthrough();
const teams_devices_override_codes_response = teams_devices_api_response_collection.and(z.object({ result: z.object({ disable_for_time: teams_devices_disable_for_time }).partial().passthrough() }).partial().passthrough());
const digital_experience_monitoring_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const digital_experience_monitoring_api_response_common = z.object({ errors: digital_experience_monitoring_messages, messages: digital_experience_monitoring_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const digital_experience_monitoring_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const digital_experience_monitoring_api_response_collection = digital_experience_monitoring_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: digital_experience_monitoring_result_info }).partial().passthrough());
const digital_experience_monitoring_colos_response = z.array(z.object({ airportCode: z.string(), city: z.string(), countryCode: z.string() }).passthrough());
const digital_experience_monitoring_api_response_common_failure = z.object({ errors: digital_experience_monitoring_messages, messages: digital_experience_monitoring_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const digital_experience_monitoring_colo = z.string();
const digital_experience_monitoring_personEmail = z.string();
const digital_experience_monitoring_platform = z.string();
const digital_experience_monitoring_status = z.string();
const digital_experience_monitoring_version = z.string();
const digital_experience_monitoring_device = z.object({ colo: digital_experience_monitoring_colo, deviceId: z.string(), deviceName: z.string().optional(), personEmail: digital_experience_monitoring_personEmail.optional(), platform: digital_experience_monitoring_platform, status: digital_experience_monitoring_status, version: digital_experience_monitoring_version }).passthrough();
const digital_experience_monitoring_fleet_status_devices_response = digital_experience_monitoring_api_response_collection.and(z.object({ result: z.array(digital_experience_monitoring_device) }).partial().passthrough());
const digital_experience_monitoring_api_response_single = digital_experience_monitoring_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const digital_experience_monitoring_uniqueDevicesTotal = z.number();
const digital_experience_monitoring_live_stat = z.object({ uniqueDevicesTotal: digital_experience_monitoring_uniqueDevicesTotal, value: z.string() }).partial().passthrough();
const digital_experience_monitoring_fleet_status_live_response = digital_experience_monitoring_api_response_single.and(z.object({ result: z.object({ deviceStats: z.object({ byColo: z.array(digital_experience_monitoring_live_stat).nullable(), byMode: z.array(digital_experience_monitoring_live_stat).nullable(), byPlatform: z.array(digital_experience_monitoring_live_stat).nullable(), byStatus: z.array(digital_experience_monitoring_live_stat).nullable(), byVersion: z.array(digital_experience_monitoring_live_stat).nullable(), uniqueDevicesTotal: digital_experience_monitoring_uniqueDevicesTotal }).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const digital_experience_monitoring_test_stat_over_time = z.object({ avg: z.number().int().nullish(), max: z.number().int().nullish(), min: z.number().int().nullish(), slots: z.array(z.object({ timestamp: z.string(), value: z.number().int() }).passthrough()) }).passthrough();
const digital_experience_monitoring_http_details_response = z.object({ host: z.string(), httpStats: z.object({ dnsResponseTimeMs: digital_experience_monitoring_test_stat_over_time, httpStatusCode: z.array(z.object({ status200: z.number().int(), status300: z.number().int(), status400: z.number().int(), status500: z.number().int(), timestamp: z.string() }).passthrough()), resourceFetchTimeMs: digital_experience_monitoring_test_stat_over_time, serverResponseTimeMs: digital_experience_monitoring_test_stat_over_time, uniqueDevicesTotal: z.number().int() }).passthrough().nullable(), httpStatsByColo: z.array(z.object({ colo: z.string(), dnsResponseTimeMs: digital_experience_monitoring_test_stat_over_time, httpStatusCode: z.array(z.object({ status200: z.number().int(), status300: z.number().int(), status400: z.number().int(), status500: z.number().int(), timestamp: z.string() }).passthrough()), resourceFetchTimeMs: digital_experience_monitoring_test_stat_over_time, serverResponseTimeMs: digital_experience_monitoring_test_stat_over_time, uniqueDevicesTotal: z.number().int() }).passthrough()), interval: z.string(), kind: z.unknown(), method: z.string(), name: z.string() }).partial().passthrough();
const digital_experience_monitoring_percentiles = z.object({ p50: z.number().nullable(), p90: z.number().nullable(), p95: z.number().nullable(), p99: z.number().nullable() }).partial().passthrough();
const digital_experience_monitoring_http_details_percentiles_response = z.object({ dnsResponseTimeMs: digital_experience_monitoring_percentiles, resourceFetchTimeMs: digital_experience_monitoring_percentiles, serverResponseTimeMs: digital_experience_monitoring_percentiles }).partial().passthrough();
const digital_experience_monitoring_aggregate_time_period = z.object({ units: z.enum(["hours", "days", "testRuns"]), value: z.number().int() }).passthrough();
const digital_experience_monitoring_aggregate_stat = z.object({ avgMs: z.number().int().nullish(), deltaPct: z.number().nullish(), timePeriod: digital_experience_monitoring_aggregate_time_period }).passthrough();
const digital_experience_monitoring_aggregate_time_slot = z.object({ avgMs: z.number().int(), timestamp: z.string() }).passthrough();
const digital_experience_monitoring_timing_aggregates = z.object({ avgMs: z.number().int().nullish(), history: z.array(digital_experience_monitoring_aggregate_stat), overTime: z.object({ timePeriod: digital_experience_monitoring_aggregate_time_period, values: z.array(digital_experience_monitoring_aggregate_time_slot) }).passthrough().nullish() }).passthrough();
const digital_experience_monitoring_uuid = z.string();
const digital_experience_monitoring_tests_response = z.object({ overviewMetrics: z.object({ avgTracerouteAvailabilityPct: z.number().nullish(), testsTotal: z.number().int() }).passthrough(), tests: z.array(z.object({ created: z.string(), description: z.string(), enabled: z.boolean(), host: z.string(), httpResults: z.object({ resourceFetchTime: digital_experience_monitoring_timing_aggregates }).passthrough().nullish(), httpResultsByColo: z.array(z.object({ colo: z.string(), resourceFetchTime: digital_experience_monitoring_timing_aggregates }).passthrough()).optional(), id: digital_experience_monitoring_uuid.max(36), interval: z.string(), kind: z.enum(["http", "traceroute"]), method: z.string().optional(), name: z.string(), tracerouteResults: z.object({ roundTripTime: digital_experience_monitoring_timing_aggregates }).passthrough().nullish(), tracerouteResultsByColo: z.array(z.object({ colo: z.string(), roundTripTime: digital_experience_monitoring_timing_aggregates }).passthrough()).optional(), updated: z.string() }).passthrough()) }).passthrough();
const digital_experience_monitoring_unique_devices_response = z.object({ uniqueDevicesTotal: z.number().int() }).passthrough();
const digital_experience_monitoring_traceroute_test_result_network_path_response = z.object({ deviceName: z.string().optional(), hops: z.array(z.object({ asn: z.number().int().nullish(), aso: z.string().nullish(), ipAddress: z.string().nullish(), location: z.object({ city: z.string().nullable(), state: z.string().nullable(), zip: z.string().nullable() }).partial().passthrough().nullish(), mile: z.enum(["client-to-app", "client-to-cf-egress", "client-to-cf-ingress", "client-to-isp"]).nullish(), name: z.string().nullish(), packetLossPct: z.number().nullish(), rttMs: z.number().int().nullish(), ttl: z.number().int() }).passthrough()), resultId: digital_experience_monitoring_uuid.max(36), testId: digital_experience_monitoring_uuid.max(36).optional(), testName: z.string().optional(), time_start: z.string() }).passthrough();
const digital_experience_monitoring_test_stat_pct_over_time = z.object({ avg: z.number().nullish(), max: z.number().nullish(), min: z.number().nullish(), slots: z.array(z.object({ timestamp: z.string(), value: z.number() }).passthrough()) }).passthrough();
const digital_experience_monitoring_traceroute_details_response = z.object({ host: z.string(), interval: z.string(), kind: z.unknown(), name: z.string(), tracerouteStats: z.object({ availabilityPct: digital_experience_monitoring_test_stat_pct_over_time, hopsCount: digital_experience_monitoring_test_stat_over_time, packetLossPct: digital_experience_monitoring_test_stat_pct_over_time, roundTripTimeMs: digital_experience_monitoring_test_stat_over_time, uniqueDevicesTotal: z.number().int() }).passthrough().nullish(), tracerouteStatsByColo: z.array(z.object({ availabilityPct: digital_experience_monitoring_test_stat_pct_over_time, colo: z.string(), hopsCount: digital_experience_monitoring_test_stat_over_time, packetLossPct: digital_experience_monitoring_test_stat_pct_over_time, roundTripTimeMs: digital_experience_monitoring_test_stat_over_time, uniqueDevicesTotal: z.number().int() }).passthrough()).optional() }).passthrough();
const digital_experience_monitoring_traceroute_test_network_path_response = z.object({ deviceName: z.string().optional(), id: digital_experience_monitoring_uuid.max(36), interval: z.string().optional(), kind: z.unknown().optional(), name: z.string().optional(), networkPath: z.object({ sampling: z.object({ unit: z.unknown(), value: z.number().int() }).passthrough().nullish(), slots: z.array(z.object({ clientToAppRttMs: z.number().int().nullable(), clientToCfEgressRttMs: z.number().int().nullable(), clientToCfIngressRttMs: z.number().int().nullable(), clientToIspRttMs: z.number().int().nullish(), id: digital_experience_monitoring_uuid.max(36), timestamp: z.string() }).passthrough()) }).passthrough().nullish(), url: z.string().optional() }).passthrough();
const digital_experience_monitoring_traceroute_details_percentiles_response = z.object({ hopsCount: digital_experience_monitoring_percentiles, packetLossPct: digital_experience_monitoring_percentiles, roundTripTimeMs: digital_experience_monitoring_percentiles }).partial().passthrough();
const magic_transit_colos = z.array(z.string());
const magic_transit_max_ttl = z.number();
const magic_transit_packet_type = z.enum(["icmp", "tcp", "udp", "gre", "gre+icmp"]);
const magic_transit_packets_per_ttl = z.number();
const magic_transit_port = z.number();
const magic_transit_wait_time = z.number();
const magic_transit_options = z.object({ max_ttl: magic_transit_max_ttl.int().gte(0).lte(64).default(15), packet_type: magic_transit_packet_type.default("icmp"), packets_per_ttl: magic_transit_packets_per_ttl.int().gte(0).lte(10).default(3), port: magic_transit_port.int().gte(0).lte(65535), wait_time: magic_transit_wait_time.int().gte(1).lte(5).default(1) }).partial().passthrough();
const magic_transit_targets = z.array(z.string());
const magic_transit_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const magic_transit_api_response_common = z.object({ errors: magic_transit_messages, messages: magic_transit_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const magic_transit_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const magic_transit_api_response_collection = magic_transit_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: magic_transit_result_info }).partial().passthrough());
const magic_transit_colo_city = z.string();
const magic_transit_colo_name = z.string();
const magic_transit_colo = z.object({ city: magic_transit_colo_city, name: magic_transit_colo_name }).partial().passthrough();
const magic_transit_error = z.enum(["", "Could not gather traceroute data: Code 1", "Could not gather traceroute data: Code 2", "Could not gather traceroute data: Code 3", "Could not gather traceroute data: Code 4"]);
const magic_transit_asn = z.string();
const magic_transit_ip = z.string();
const magic_transit_labels = z.array(z.string());
const magic_transit_max_rtt_ms = z.number();
const magic_transit_mean_rtt_ms = z.number();
const magic_transit_min_rtt_ms = z.number();
const magic_transit_name = z.string();
const magic_transit_packet_count = z.number();
const magic_transit_std_dev_rtt_ms = z.number();
const magic_transit_node_result = z.object({ asn: magic_transit_asn, ip: magic_transit_ip, labels: magic_transit_labels, max_rtt_ms: magic_transit_max_rtt_ms, mean_rtt_ms: magic_transit_mean_rtt_ms, min_rtt_ms: magic_transit_min_rtt_ms, name: magic_transit_name, packet_count: magic_transit_packet_count.int(), std_dev_rtt_ms: magic_transit_std_dev_rtt_ms }).partial().passthrough();
const magic_transit_packets_lost = z.number();
const magic_transit_packets_sent = z.number();
const magic_transit_packets_ttl = z.number();
const magic_transit_hop_result = z.object({ nodes: z.array(magic_transit_node_result), packets_lost: magic_transit_packets_lost.int(), packets_sent: magic_transit_packets_sent.int(), packets_ttl: magic_transit_packets_ttl.int() }).partial().passthrough();
const magic_transit_target_summary = z.object({}).partial().passthrough();
const magic_transit_traceroute_time_ms = z.number();
const magic_transit_colo_result = z.object({ colo: magic_transit_colo, error: magic_transit_error, hops: z.array(magic_transit_hop_result), target_summary: magic_transit_target_summary, traceroute_time_ms: magic_transit_traceroute_time_ms.int() }).partial().passthrough();
const magic_transit_target = z.string();
const magic_transit_target_result = z.object({ colos: z.array(magic_transit_colo_result), target: magic_transit_target }).partial().passthrough();
const magic_transit_traceroute_response_collection = magic_transit_api_response_collection.and(z.object({ result: z.array(magic_transit_target_result) }).partial().passthrough());
const magic_transit_api_response_common_failure = z.object({ errors: magic_transit_messages, messages: magic_transit_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const dlp_V4ResponseMessage = z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough();
const dlp_V4ResponsePagination = z.object({ count: z.number().int().gte(0), page: z.number().int().gte(0), per_page: z.number().int().gte(0), total_count: z.number().int().gte(0) }).passthrough();
const dlp_V4Response = z.object({ errors: z.array(dlp_V4ResponseMessage), messages: z.array(dlp_V4ResponseMessage), result_info: dlp_V4ResponsePagination.optional(), success: z.boolean() }).passthrough();
const dlp_DatasetUploadStatus = z.enum(["empty", "uploading", "failed", "complete"]);
const dlp_DatasetUpload = z.object({ num_cells: z.number().int(), status: dlp_DatasetUploadStatus, version: z.number().int() }).passthrough();
const dlp_Dataset = z.object({ created_at: z.string().datetime({ offset: true }), description: z.string().nullish(), id: z.string().uuid(), name: z.string(), num_cells: z.number().int(), secret: z.boolean(), status: dlp_DatasetUploadStatus, updated_at: z.string().datetime({ offset: true }), uploads: z.array(dlp_DatasetUpload) }).passthrough();
const dlp_DatasetArray = z.array(dlp_Dataset);
const dlp_DatasetArrayResponse = dlp_V4Response.and(z.object({ result: dlp_DatasetArray }).partial().passthrough());
const dlp_V4ResponseError = z.object({ errors: z.array(dlp_V4ResponseMessage), messages: z.array(dlp_V4ResponseMessage), result: z.object({}).partial().passthrough().nullish(), success: z.boolean() }).passthrough();
const dlp_NewDataset = z.object({ description: z.string().nullish(), name: z.string(), secret: z.boolean().optional() }).passthrough();
const dlp_DatasetCreation = z.object({ dataset: dlp_Dataset, max_cells: z.number().int().gte(0), secret: z.string().optional(), version: z.number().int() }).passthrough();
const dlp_DatasetCreationResponse = dlp_V4Response.and(z.object({ result: dlp_DatasetCreation }).partial().passthrough());
const dlp_DatasetResponse = dlp_V4Response.and(z.object({ result: dlp_Dataset }).partial().passthrough());
const dlp_DatasetUpdate = z.object({ description: z.string().nullable(), name: z.string().nullable() }).partial().passthrough();
const dlp_DatasetNewVersion = z.object({ max_cells: z.number().int().gte(0), secret: z.string().optional(), version: z.number().int() }).passthrough();
const dlp_DatasetNewVersionResponse = dlp_V4Response.and(z.object({ result: dlp_DatasetNewVersion }).partial().passthrough());
const dlp_validate_pattern = z.object({ regex: z.string() }).passthrough();
const dlp_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const dlp_api_response_common = z.object({ errors: dlp_messages, messages: dlp_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const dlp_api_response_single = dlp_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const dlp_validate_response = dlp_api_response_single.and(z.object({ result: z.object({ valid: z.boolean() }).partial().passthrough() }).partial().passthrough());
const dlp_api_response_common_failure = z.object({ errors: dlp_messages, messages: dlp_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const dlp_get_settings_response = dlp_api_response_single.and(z.object({ result: z.object({ public_key: z.string().nullable() }).passthrough() }).partial().passthrough());
const dlp_update_settings = z.object({ public_key: z.string().nullable() }).passthrough();
const dlp_update_settings_response = dlp_api_response_single.and(z.object({ result: z.object({ public_key: z.string().nullable() }).passthrough() }).partial().passthrough());
const dlp_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const dlp_api_response_collection = dlp_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: dlp_result_info }).partial().passthrough());
const dlp_allowed_match_count = z.number();
const dlp_SkipConfig = z.object({ files: z.boolean() }).passthrough();
const dlp_ContextAwareness = z.object({ enabled: z.boolean(), skip: dlp_SkipConfig }).passthrough();
const dlp_uuid = z.string();
const dlp_entry_id = dlp_uuid;
const dlp_predefined_entry = z.object({ enabled: z.boolean(), id: dlp_entry_id, name: z.string(), profile_id: z.unknown() }).partial().passthrough();
const dlp_profile_id = dlp_uuid;
const dlp_predefined_profile = z.object({ allowed_match_count: dlp_allowed_match_count.gte(0).lte(1000), context_awareness: dlp_ContextAwareness, entries: z.array(dlp_predefined_entry), id: dlp_profile_id, name: z.string(), type: z.literal("predefined") }).partial().passthrough();
const dlp_timestamp = z.string();
const dlp_pattern = z.object({ regex: z.string(), validation: z.literal("luhn").optional() }).passthrough();
const dlp_custom_entry = z.object({ created_at: dlp_timestamp.datetime({ offset: true }), enabled: z.boolean(), id: dlp_entry_id, name: z.string(), pattern: dlp_pattern, profile_id: z.unknown(), updated_at: dlp_timestamp.datetime({ offset: true }) }).partial().passthrough();
const dlp_custom_profile = z.object({ allowed_match_count: dlp_allowed_match_count.gte(0).lte(1000), context_awareness: dlp_ContextAwareness, created_at: dlp_timestamp.datetime({ offset: true }), description: z.string(), entries: z.array(dlp_custom_entry), id: dlp_profile_id, name: z.string(), type: z.literal("custom"), updated_at: dlp_timestamp.datetime({ offset: true }) }).partial().passthrough();
const dlp_integration_entry = z.object({ created_at: dlp_timestamp.datetime({ offset: true }), enabled: z.boolean(), id: dlp_entry_id, name: z.string(), profile_id: z.unknown(), updated_at: dlp_timestamp.datetime({ offset: true }) }).partial().passthrough();
const dlp_integration_profile = z.object({ created_at: dlp_timestamp.datetime({ offset: true }), description: z.string(), entries: z.array(dlp_integration_entry), id: dlp_profile_id, name: z.string(), type: z.literal("integration"), updated_at: dlp_timestamp.datetime({ offset: true }) }).partial().passthrough();
const dlp_profiles = z.union([dlp_predefined_profile, dlp_custom_profile, dlp_integration_profile]);
const dlp_response_collection = dlp_api_response_collection.and(z.object({ result: z.array(dlp_profiles) }).partial().passthrough());
const dlp_new_custom_entry = z.object({ enabled: z.boolean(), name: z.string(), pattern: dlp_pattern }).passthrough();
const dlp_new_custom_profile = z.object({ allowed_match_count: dlp_allowed_match_count.gte(0).lte(1000), context_awareness: dlp_ContextAwareness, description: z.string(), entries: z.array(dlp_new_custom_entry), name: z.string() }).partial().passthrough();
const dlp_create_custom_profiles = z.object({ profiles: z.array(dlp_new_custom_profile) }).passthrough();
const dlp_create_custom_profile_response = dlp_api_response_collection.and(z.object({ result: z.array(dlp_custom_profile) }).partial().passthrough());
const profile_id = dlp_uuid;
const dlp_custom_profile_response = dlp_api_response_single.and(z.object({ result: dlp_custom_profile }).partial().passthrough());
const dlp_shared_entry_update_predefined = z.object({ enabled: z.boolean(), entry_id: dlp_entry_id }).partial().passthrough();
const dlp_shared_entry_update_integration = z.object({ enabled: z.boolean(), entry_id: dlp_entry_id }).partial().passthrough();
const dlp_update_custom_profile = z.object({ allowed_match_count: dlp_allowed_match_count.gte(0).lte(1000), context_awareness: dlp_ContextAwareness, description: z.string(), entries: z.array(dlp_custom_entry), name: z.string(), shared_entries: z.array(z.union([dlp_shared_entry_update_predefined, dlp_shared_entry_update_integration])) }).partial().passthrough();
const dlp_predefined_profile_response = dlp_api_response_single.and(z.object({ result: dlp_predefined_profile }).partial().passthrough());
const dlp_update_predefined_profile = z.object({ allowed_match_count: dlp_allowed_match_count.gte(0).lte(1000), context_awareness: dlp_ContextAwareness, entries: z.array(z.object({ enabled: z.boolean(), id: dlp_entry_id }).partial().passthrough()) }).partial().passthrough();
const dlp_either_profile_response = dlp_api_response_single.and(z.object({ result: z.union([dlp_predefined_profile, dlp_custom_profile, dlp_integration_profile]) }).partial().passthrough());
const dns_firewall_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const dns_firewall_api_response_common = z.object({ errors: dns_firewall_messages, messages: dns_firewall_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const dns_firewall_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const dns_firewall_api_response_collection = dns_firewall_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: dns_firewall_result_info }).partial().passthrough());
const dns_firewall_attack_mitigation = z.object({ enabled: z.boolean(), only_when_origin_unhealthy: z.unknown(), only_when_upstream_unhealthy: z.boolean().default(true) }).partial().passthrough();
const dns_firewall_deprecate_any_requests = z.boolean();
const dns_firewall_dns_firewall_ips = z.array(z.union([z.string(), z.string()]));
const dns_firewall_ecs_fallback = z.boolean();
const dns_firewall_identifier = z.string();
const dns_firewall_maximum_cache_ttl = z.number();
const dns_firewall_minimum_cache_ttl = z.number();
const dns_firewall_modified_on = z.string();
const dns_firewall_name = z.string();
const dns_firewall_negative_cache_ttl = z.number();
const dns_firewall_ratelimit = z.number();
const dns_firewall_retries = z.number();
const dns_firewall_upstream_ips = z.array(z.union([z.string(), z.string()]));
const dns_firewall_dns_firewall = z.object({ attack_mitigation: dns_firewall_attack_mitigation.nullish(), deprecate_any_requests: dns_firewall_deprecate_any_requests, dns_firewall_ips: dns_firewall_dns_firewall_ips, ecs_fallback: dns_firewall_ecs_fallback, id: dns_firewall_identifier.max(32), maximum_cache_ttl: dns_firewall_maximum_cache_ttl.gte(30).lte(36000).default(900), minimum_cache_ttl: dns_firewall_minimum_cache_ttl.gte(30).lte(36000).default(60), modified_on: dns_firewall_modified_on.datetime({ offset: true }), name: dns_firewall_name.max(160), negative_cache_ttl: dns_firewall_negative_cache_ttl.gte(30).lte(36000).nullish(), origin_ips: z.unknown().optional(), ratelimit: dns_firewall_ratelimit.gte(100).lte(1000000000).nullish(), retries: dns_firewall_retries.gte(0).lte(2).optional().default(2), upstream_ips: dns_firewall_upstream_ips }).passthrough();
const dns_firewall_dns_firewall_response_collection = dns_firewall_api_response_collection.and(z.object({ result: z.array(dns_firewall_dns_firewall) }).partial().passthrough());
const dns_firewall_api_response_common_failure = z.object({ errors: dns_firewall_messages, messages: dns_firewall_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const dns_firewall_api_response_single = dns_firewall_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const dns_firewall_dns_firewall_single_response = dns_firewall_api_response_single.and(z.object({ result: dns_firewall_dns_firewall }).partial().passthrough());
const dns_firewall_schemas_dns_firewall = dns_firewall_dns_firewall;
const zero_trust_gateway_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const zero_trust_gateway_api_response_common = z.object({ errors: zero_trust_gateway_messages, messages: zero_trust_gateway_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const zero_trust_gateway_api_response_single = zero_trust_gateway_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const zero_trust_gateway_gateway_tag = z.string();
const zero_trust_gateway_cf_account_id = z.string();
const zero_trust_gateway_provider_name = z.string();
const zero_trust_gateway_gateway_account = zero_trust_gateway_api_response_single.and(z.object({ result: z.object({ gateway_tag: zero_trust_gateway_gateway_tag.max(32), id: zero_trust_gateway_cf_account_id.max(32), provider_name: zero_trust_gateway_provider_name }).partial().passthrough() }).partial().passthrough());
const zero_trust_gateway_api_response_common_failure = z.object({ errors: zero_trust_gateway_messages, messages: zero_trust_gateway_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const zero_trust_gateway_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const zero_trust_gateway_api_response_collection = zero_trust_gateway_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: zero_trust_gateway_result_info }).partial().passthrough());
const zero_trust_gateway_app_type_id = z.number();
const zero_trust_gateway_timestamp = z.string();
const zero_trust_gateway_app_id = z.number();
const zero_trust_gateway_app_types_components_schemas_name = z.string();
const zero_trust_gateway_application = z.object({ application_type_id: zero_trust_gateway_app_type_id.int(), created_at: zero_trust_gateway_timestamp.datetime({ offset: true }), id: zero_trust_gateway_app_id.int(), name: zero_trust_gateway_app_types_components_schemas_name }).partial().passthrough();
const zero_trust_gateway_application_type = z.object({ created_at: zero_trust_gateway_timestamp.datetime({ offset: true }), description: z.string(), id: zero_trust_gateway_app_type_id.int(), name: zero_trust_gateway_app_types_components_schemas_name }).partial().passthrough();
const zero_trust_gateway_app_types = z.union([zero_trust_gateway_application, zero_trust_gateway_application_type]);
const zero_trust_gateway_app_types_components_schemas_response_collection = zero_trust_gateway_api_response_collection.and(z.object({ result: z.array(zero_trust_gateway_app_types) }).partial().passthrough());
const zero_trust_gateway_public_key = z.string();
const zero_trust_gateway_audit_ssh_settings_components_schemas_uuid = z.string();
const zero_trust_gateway_settings = z.object({ created_at: zero_trust_gateway_timestamp.datetime({ offset: true }), public_key: zero_trust_gateway_public_key, seed_id: zero_trust_gateway_audit_ssh_settings_components_schemas_uuid.max(36), updated_at: zero_trust_gateway_timestamp.datetime({ offset: true }) }).partial().passthrough();
const zero_trust_gateway_audit_ssh_settings_components_schemas_single_response = zero_trust_gateway_api_response_single.and(z.object({ result: zero_trust_gateway_settings }).partial().passthrough());
const zero_trust_gateway_beta = z.boolean();
const zero_trust_gateway_class = z.enum(["free", "premium", "blocked", "removalPending", "noBlock"]);
const zero_trust_gateway_components_schemas_description = z.string();
const zero_trust_gateway_id = z.number();
const zero_trust_gateway_categories_components_schemas_name = z.string();
const zero_trust_gateway_subcategory = z.object({ beta: zero_trust_gateway_beta, class: zero_trust_gateway_class, description: zero_trust_gateway_components_schemas_description, id: zero_trust_gateway_id.int(), name: zero_trust_gateway_categories_components_schemas_name }).partial().passthrough();
const zero_trust_gateway_categories = z.object({ beta: zero_trust_gateway_beta, class: zero_trust_gateway_class, description: zero_trust_gateway_components_schemas_description, id: zero_trust_gateway_id.int(), name: zero_trust_gateway_categories_components_schemas_name, subcategories: z.array(zero_trust_gateway_subcategory) }).partial().passthrough();
const zero_trust_gateway_categories_components_schemas_response_collection = zero_trust_gateway_api_response_collection.and(z.object({ result: z.array(zero_trust_gateway_categories) }).partial().passthrough());
const zero_trust_gateway_activity_log_settings = z.object({ enabled: z.boolean() }).partial().passthrough();
const zero_trust_gateway_enabled_download_phase = z.boolean();
const zero_trust_gateway_enabled_upload_phase = z.boolean();
const zero_trust_gateway_fail_closed = z.boolean();
const zero_trust_gateway_notification_settings = z.object({ enabled: z.boolean(), msg: z.string(), support_url: z.string() }).partial().passthrough();
const zero_trust_gateway_anti_virus_settings = z.object({ enabled_download_phase: zero_trust_gateway_enabled_download_phase, enabled_upload_phase: zero_trust_gateway_enabled_upload_phase, fail_closed: zero_trust_gateway_fail_closed, notification_settings: zero_trust_gateway_notification_settings }).partial().passthrough();
const zero_trust_gateway_block_page_settings = z.object({ background_color: z.string(), enabled: z.boolean(), footer_text: z.string(), header_text: z.string(), logo_path: z.string(), mailto_address: z.string(), mailto_subject: z.string(), name: z.string(), suppress_footer: z.boolean() }).partial().passthrough();
const zero_trust_gateway_body_scanning_settings = z.object({ inspection_mode: z.string() }).partial().passthrough();
const zero_trust_gateway_browser_isolation_settings = z.object({ non_identity_enabled: z.boolean(), url_browser_isolation_enabled: z.boolean() }).partial().passthrough();
const zero_trust_gateway_custom_certificate_settings = z.object({ binding_status: z.string().optional(), enabled: z.boolean(), id: z.string().optional(), updated_at: z.string().datetime({ offset: true }).optional() }).passthrough();
const zero_trust_gateway_extended_email_matching = z.object({ enabled: z.boolean() }).partial().passthrough();
const zero_trust_gateway_fips_settings = z.object({ tls: z.boolean() }).partial().passthrough();
const zero_trust_gateway_protocol_detection = z.object({ enabled: z.boolean() }).partial().passthrough();
const zero_trust_gateway_tls_settings = z.object({ enabled: z.boolean() }).partial().passthrough();
const zero_trust_gateway_gateway_account_settings = z.object({ settings: z.object({ activity_log: zero_trust_gateway_activity_log_settings, antivirus: zero_trust_gateway_anti_virus_settings, block_page: zero_trust_gateway_block_page_settings, body_scanning: zero_trust_gateway_body_scanning_settings, browser_isolation: zero_trust_gateway_browser_isolation_settings, custom_certificate: zero_trust_gateway_custom_certificate_settings, extended_email_matching: zero_trust_gateway_extended_email_matching, fips: zero_trust_gateway_fips_settings, protocol_detection: zero_trust_gateway_protocol_detection, tls_decrypt: zero_trust_gateway_tls_settings }).partial().passthrough() }).partial().passthrough();
const zero_trust_gateway_gateway_account_config = zero_trust_gateway_api_response_single.and(z.object({ result: zero_trust_gateway_gateway_account_settings.and(z.object({ created_at: zero_trust_gateway_timestamp.datetime({ offset: true }), updated_at: zero_trust_gateway_timestamp.datetime({ offset: true }) }).partial().passthrough()) }).partial().passthrough());
const zero_trust_gateway_count = z.number();
const zero_trust_gateway_description = z.string();
const zero_trust_gateway_uuid = z.string();
const zero_trust_gateway_name = z.string();
const zero_trust_gateway_type = z.enum(["SERIAL", "URL", "DOMAIN", "EMAIL", "IP"]);
const zero_trust_gateway_lists = z.object({ count: zero_trust_gateway_count, created_at: zero_trust_gateway_timestamp.datetime({ offset: true }), description: zero_trust_gateway_description, id: zero_trust_gateway_uuid.max(36), name: zero_trust_gateway_name, type: zero_trust_gateway_type, updated_at: zero_trust_gateway_timestamp.datetime({ offset: true }) }).partial().passthrough();
const zero_trust_gateway_response_collection = zero_trust_gateway_api_response_collection.and(z.object({ result: z.array(zero_trust_gateway_lists) }).partial().passthrough());
const zero_trust_gateway_value = z.string();
const zero_trust_gateway_items = z.array(z.object({ created_at: zero_trust_gateway_timestamp.datetime({ offset: true }), value: zero_trust_gateway_value }).partial().passthrough());
const zero_trust_gateway_single_response_with_list_items = zero_trust_gateway_api_response_single.and(z.object({ result: z.object({ created_at: zero_trust_gateway_timestamp.datetime({ offset: true }), description: zero_trust_gateway_description, id: zero_trust_gateway_uuid.max(36), items: zero_trust_gateway_items, name: zero_trust_gateway_name, type: zero_trust_gateway_type, updated_at: zero_trust_gateway_timestamp.datetime({ offset: true }) }).partial().passthrough() }).partial().passthrough());
const zero_trust_gateway_empty_response = zero_trust_gateway_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const zero_trust_gateway_single_response = zero_trust_gateway_api_response_single.and(z.object({ result: zero_trust_gateway_lists }).partial().passthrough());
const zero_trust_gateway_list_item_response_collection = zero_trust_gateway_api_response_collection.and(z.object({ result: z.array(zero_trust_gateway_items) }).partial().passthrough()).and(z.object({ result_info: z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough() }).partial().passthrough());
const zero_trust_gateway_client_default = z.boolean();
const zero_trust_gateway_subdomain = z.string();
const zero_trust_gateway_ecs_support = z.boolean();
const zero_trust_gateway_schemas_uuid = z.unknown();
const zero_trust_gateway_ip = z.string();
const zero_trust_gateway_schemas_name = z.string();
const zero_trust_gateway_network = z.object({ network: z.string() }).passthrough();
const zero_trust_gateway_networks = z.array(zero_trust_gateway_network);
const zero_trust_gateway_locations = z.object({ client_default: zero_trust_gateway_client_default, created_at: zero_trust_gateway_timestamp.datetime({ offset: true }), doh_subdomain: zero_trust_gateway_subdomain, ecs_support: zero_trust_gateway_ecs_support, id: zero_trust_gateway_schemas_uuid, ip: zero_trust_gateway_ip, name: zero_trust_gateway_schemas_name, networks: zero_trust_gateway_networks, updated_at: zero_trust_gateway_timestamp.datetime({ offset: true }) }).partial().passthrough();
const zero_trust_gateway_schemas_response_collection = zero_trust_gateway_api_response_collection.and(z.object({ result: z.array(zero_trust_gateway_locations) }).partial().passthrough());
const zero_trust_gateway_schemas_single_response = zero_trust_gateway_api_response_single.and(z.object({ result: zero_trust_gateway_locations }).partial().passthrough());
const zero_trust_gateway_gateway_account_logging_settings = z.object({ redact_pii: z.boolean(), settings_by_rule_type: z.object({ dns: z.object({}).partial().passthrough(), http: z.object({}).partial().passthrough(), l4: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough();
const zero_trust_gateway_gateway_account_logging_settings_response = zero_trust_gateway_api_response_single.and(z.object({ result: zero_trust_gateway_gateway_account_logging_settings }).partial().passthrough());
const zero_trust_gateway_ips = z.array(z.string());
const zero_trust_gateway_proxy_endpoints_components_schemas_name = z.string();
const zero_trust_gateway_schemas_subdomain = z.string();
const zero_trust_gateway_proxy_endpoints = z.object({ created_at: zero_trust_gateway_timestamp.datetime({ offset: true }), id: zero_trust_gateway_schemas_uuid, ips: zero_trust_gateway_ips, name: zero_trust_gateway_proxy_endpoints_components_schemas_name, subdomain: zero_trust_gateway_schemas_subdomain, updated_at: zero_trust_gateway_timestamp.datetime({ offset: true }) }).partial().passthrough();
const zero_trust_gateway_proxy_endpoints_components_schemas_response_collection = zero_trust_gateway_api_response_collection.and(z.object({ result: z.array(zero_trust_gateway_proxy_endpoints) }).partial().passthrough());
const zero_trust_gateway_proxy_endpoints_components_schemas_single_response = zero_trust_gateway_api_response_single.and(z.object({ result: zero_trust_gateway_proxy_endpoints }).partial().passthrough());
const zero_trust_gateway_action = z.enum(["on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "audit_ssh"]);
const zero_trust_gateway_deleted_at = z.string();
const zero_trust_gateway_schemas_description = z.string();
const zero_trust_gateway_device_posture = z.string();
const zero_trust_gateway_enabled = z.boolean();
const zero_trust_gateway_filters = z.array(z.enum(["http", "dns", "l4", "egress"]));
const zero_trust_gateway_components_schemas_uuid = z.string();
const zero_trust_gateway_identity = z.string();
const zero_trust_gateway_components_schemas_name = z.string();
const zero_trust_gateway_precedence = z.number();
const zero_trust_gateway_dns_resolver_settings = z.object({ ip: z.string(), port: z.number().int().optional(), route_through_private_network: z.boolean().optional(), vnet_id: z.string().optional() }).passthrough();
const zero_trust_gateway_rule_settings = z.object({ add_headers: z.object({}).partial().passthrough(), allow_child_bypass: z.boolean(), audit_ssh: z.object({ command_logging: z.boolean() }).partial().passthrough(), biso_admin_controls: z.object({ dcp: z.boolean(), dd: z.boolean(), dk: z.boolean(), dp: z.boolean(), du: z.boolean() }).partial().passthrough(), block_page_enabled: z.boolean(), block_reason: z.string(), bypass_parent_rule: z.boolean(), check_session: z.object({ duration: z.string(), enforce: z.boolean() }).partial().passthrough(), dns_resolvers: z.object({ ipv4: z.array(zero_trust_gateway_dns_resolver_settings), ipv6: z.array(zero_trust_gateway_dns_resolver_settings) }).partial().passthrough(), egress: z.object({ ipv4: z.string(), ipv4_fallback: z.string(), ipv6: z.string() }).partial().passthrough(), insecure_disable_dnssec_validation: z.boolean(), ip_categories: z.boolean(), ip_indicator_feeds: z.boolean(), l4override: z.object({ ip: z.string(), port: z.number().int() }).partial().passthrough(), notification_settings: z.object({ enabled: z.boolean(), msg: z.string(), support_url: z.string() }).partial().passthrough(), override_host: z.string(), override_ips: z.array(z.string()), payload_log: z.object({ enabled: z.boolean() }).partial().passthrough(), resolve_dns_through_cloudflare: z.boolean(), untrusted_cert: z.object({ action: z.enum(["pass_through", "block", "error"]) }).partial().passthrough() }).partial().passthrough();
const zero_trust_gateway_schedule = z.object({ fri: z.string(), mon: z.string(), sat: z.string(), sun: z.string(), thu: z.string(), time_zone: z.string(), tue: z.string(), wed: z.string() }).partial().passthrough();
const zero_trust_gateway_traffic = z.string();
const zero_trust_gateway_rules = z.object({ action: zero_trust_gateway_action, created_at: zero_trust_gateway_timestamp.datetime({ offset: true }), deleted_at: zero_trust_gateway_deleted_at.datetime({ offset: true }).nullable(), description: zero_trust_gateway_schemas_description, device_posture: zero_trust_gateway_device_posture, enabled: zero_trust_gateway_enabled, filters: zero_trust_gateway_filters, id: zero_trust_gateway_components_schemas_uuid.max(36), identity: zero_trust_gateway_identity, name: zero_trust_gateway_components_schemas_name, precedence: zero_trust_gateway_precedence.int(), rule_settings: zero_trust_gateway_rule_settings, schedule: zero_trust_gateway_schedule, traffic: zero_trust_gateway_traffic, updated_at: zero_trust_gateway_timestamp.datetime({ offset: true }) }).partial().passthrough();
const zero_trust_gateway_components_schemas_response_collection = zero_trust_gateway_api_response_collection.and(z.object({ result: z.array(zero_trust_gateway_rules) }).partial().passthrough());
const zero_trust_gateway_components_schemas_single_response = zero_trust_gateway_api_response_single.and(z.object({ result: zero_trust_gateway_rules }).partial().passthrough());
const hyperdrive_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const hyperdrive_api_response_common = z.object({ errors: hyperdrive_messages, messages: hyperdrive_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const hyperdrive_hyperdrive_caching = z.object({ disabled: z.boolean(), max_age: z.number().int(), stale_while_revalidate: z.number().int() }).partial().passthrough();
const hyperdrive_hyperdrive_name = z.string();
const hyperdrive_hyperdrive_scheme = z.enum(["postgres", "postgresql"]);
const hyperdrive_hyperdrive_origin = z.object({ database: z.string(), host: z.string(), port: z.number().int(), scheme: hyperdrive_hyperdrive_scheme.default("postgres"), user: z.string() }).passthrough();
const hyperdrive_hyperdrive = z.object({ caching: hyperdrive_hyperdrive_caching, name: hyperdrive_hyperdrive_name, origin: hyperdrive_hyperdrive_origin }).partial().passthrough();
const hyperdrive_hyperdrive_with_identifier = hyperdrive_hyperdrive;
const hyperdrive_api_response_single = hyperdrive_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]).nullable() }).partial().passthrough());
const hyperdrive_api_response_common_failure = z.object({ errors: hyperdrive_messages, messages: hyperdrive_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const hyperdrive_create_update_hyperdrive_config = hyperdrive_hyperdrive;
const hyperdrive_patch_hyperdrive_config = hyperdrive_hyperdrive;
const images_image_upload_via_file = z.object({ file: z.unknown() }).passthrough();
const images_image_upload_via_url = z.object({ url: z.string() }).passthrough();
const images_image_basic_upload = z.union([images_image_upload_via_file, images_image_upload_via_url]);
const images_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const images_api_response_common = z.object({ errors: images_messages, messages: images_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const images_api_response_single = images_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const images_image_filename = z.string();
const images_image_identifier = z.string();
const images_image_metadata = z.object({}).partial().passthrough();
const images_image_requireSignedURLs = z.boolean();
const images_image_uploaded = z.string();
const images_image_thumbnail_url = z.string();
const images_image_hero_url = z.string();
const images_image_original_url = z.string();
const images_image_variants = z.array(z.union([images_image_thumbnail_url, images_image_hero_url, images_image_original_url]));
const images_image = z.object({ filename: images_image_filename.max(32), id: images_image_identifier.max(32), meta: images_image_metadata, requireSignedURLs: images_image_requireSignedURLs, uploaded: images_image_uploaded.datetime({ offset: true }), variants: images_image_variants }).partial().passthrough();
const images_image_response_single = images_api_response_single.and(z.object({ result: images_image }).partial().passthrough());
const images_api_response_common_failure = z.object({ errors: images_messages, messages: images_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const images_image_key_name = z.string();
const images_image_key_value = z.string();
const images_image_keys = z.object({ name: images_image_key_name, value: images_image_key_value }).partial().passthrough();
const images_image_keys_response = z.object({ keys: z.array(images_image_keys) }).partial().passthrough();
const images_image_key_response_collection = images_api_response_common.and(z.object({ result: images_image_keys_response }).partial().passthrough());
const images_images_stats_allowed = z.number();
const images_images_stats_current = z.number();
const images_images_stats_count = z.object({ allowed: images_images_stats_allowed, current: images_images_stats_current }).partial().passthrough();
const images_images_stats = z.object({ count: images_images_stats_count }).partial().passthrough();
const images_images_stats_response = images_api_response_single.and(z.object({ result: images_images_stats }).partial().passthrough());
const images_image_variant_identifier = z.unknown();
const images_image_variant_neverRequireSignedURLs = z.boolean();
const images_image_variant_fit = z.enum(["scale-down", "contain", "cover", "crop", "pad"]);
const images_image_variant_height = z.number();
const images_image_variant_schemas_metadata = z.enum(["keep", "copyright", "none"]);
const images_image_variant_width = z.number();
const images_image_variant_options = z.object({ fit: images_image_variant_fit, height: images_image_variant_height.gte(1), metadata: images_image_variant_schemas_metadata, width: images_image_variant_width.gte(1) }).passthrough();
const images_image_variant_public_request = z.object({ hero: z.object({ id: images_image_variant_identifier, neverRequireSignedURLs: images_image_variant_neverRequireSignedURLs.optional(), options: images_image_variant_options }).passthrough() }).partial().passthrough();
const images_image_variants_response = z.object({ variants: images_image_variant_public_request }).partial().passthrough();
const images_image_variant_list_response = images_api_response_common.and(z.object({ result: images_image_variants_response }).partial().passthrough());
const images_image_variant_definition = z.object({ id: images_image_variant_identifier, neverRequireSignedURLs: images_image_variant_neverRequireSignedURLs.optional(), options: images_image_variant_options }).passthrough();
const images_image_variant_response = z.object({ variant: images_image_variant_definition }).partial().passthrough();
const images_image_variant_simple_response = images_api_response_single.and(z.object({ result: images_image_variant_response }).partial().passthrough());
const images_deleted_response = images_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const images_image_variant_patch_request = z.object({ neverRequireSignedURLs: images_image_variant_neverRequireSignedURLs.optional(), options: images_image_variant_options }).passthrough();
const images_image_patch_request = z.object({ metadata: z.object({}).partial().passthrough(), requireSignedURLs: z.boolean() }).partial().passthrough();
const images_image_response_blob = z.union([z.string(), z.object({}).partial().passthrough()]);
const images_images_list_continuation_token = z.string();
const images_api_response_collection_v2 = images_api_response_common.and(z.object({ result: z.object({ continuation_token: images_images_list_continuation_token.max(32).nullable() }).partial().passthrough() }).partial().passthrough());
const images_images_list_response_v2 = images_api_response_collection_v2.and(z.object({ result: z.object({ images: z.array(images_image) }).partial().passthrough() }).partial().passthrough());
const images_image_direct_upload_request_v2 = z.object({ expiry: z.string().datetime({ offset: true }).default("Now + 30 minutes"), id: z.string().max(1024), metadata: z.object({}).partial().passthrough(), requireSignedURLs: z.boolean() }).partial().passthrough();
const images_image_direct_upload_response_v2 = images_api_response_single.and(z.object({ result: z.object({ id: z.string().max(32), uploadURL: z.string() }).partial().passthrough() }).partial().passthrough());
const intel_asn = z.number();
const intel_asn_components_schemas_response = intel_api_response_single.and(z.object({ result: intel_asn.int() }).partial().passthrough());
const intel_count = z.number();
const intel_page = z.number();
const intel_per_page = z.number();
const security_center_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const security_center_api_response_common = z.object({ errors: security_center_messages, messages: security_center_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const security_center_api_response_common_failure = z.object({ errors: security_center_messages, messages: security_center_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const security_center_issueClass = z.string();
const security_center_issueType = z.enum(["compliance_violation", "email_security", "exposed_infrastructure", "insecure_configuration", "weak_authentication"]);
const security_center_subject = z.string();
const security_center_page = z.number();
const page = security_center_page.optional().default(1);
const security_center_perPage = z.number();
const per_page = security_center_perPage.optional().default(25);
const security_center_count = z.number();
const security_center_issue = z.object({ dismissed: z.boolean(), id: z.string(), issue_class: security_center_issueClass, issue_type: security_center_issueType, payload: z.object({}).partial().passthrough(), resolve_link: z.string(), resolve_text: z.string(), severity: z.enum(["Low", "Moderate", "Critical"]), since: z.string().datetime({ offset: true }), subject: security_center_subject, timestamp: z.string().datetime({ offset: true }) }).partial().passthrough();
const security_center_valueCountsResponse = security_center_api_response_common.and(z.object({ result: z.array(z.object({ count: z.number().int(), value: z.string() }).partial().passthrough()) }).partial().passthrough());
const security_center_api_response_single = security_center_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const start_end_params = z.object({ end: z.string(), start: z.string() }).partial().passthrough().optional();
const intel_passive_dns_by_ip = z.object({ count: z.number(), page: z.number(), per_page: z.number(), reverse_records: z.array(z.object({ first_seen: z.string(), hostname: z.unknown(), last_seen: z.string() }).partial().passthrough()) }).partial().passthrough();
const intel_components_schemas_single_response = intel_api_response_single.and(z.object({ result: intel_passive_dns_by_ip }).partial().passthrough());
const intel_additional_information = z.object({ suspected_malware_family: z.string() }).partial().passthrough();
const intel_application = z.object({ id: z.number().int(), name: z.string() }).partial().passthrough();
const intel_content_categories = z.unknown();
const intel_domain_name = z.string();
const intel_category_with_super_category_id = z.object({ id: z.number().int(), name: z.string(), super_category_id: z.number().int() }).partial().passthrough();
const intel_categories_with_super_category_ids_example_empty = z.array(intel_category_with_super_category_id);
const intel_inherited_from = z.string();
const intel_popularity_rank = z.number();
const intel_stix_identifier = z.string();
const intel_resolves_to_ref = z.object({ id: intel_stix_identifier, value: z.string() }).partial().passthrough();
const intel_resolves_to_refs = z.array(intel_resolves_to_ref);
const intel_risk_score = z.number();
const intel_risk_types = z.unknown();
const intel_domain = z.object({ additional_information: intel_additional_information, application: intel_application, content_categories: intel_content_categories, domain: intel_domain_name, inherited_content_categories: intel_categories_with_super_category_ids_example_empty, inherited_from: intel_inherited_from, inherited_risk_types: intel_categories_with_super_category_ids_example_empty, popularity_rank: intel_popularity_rank.int(), resolves_to_refs: intel_resolves_to_refs, risk_score: intel_risk_score, risk_types: intel_risk_types }).partial().passthrough();
const intel_single_response = intel_api_response_single.and(z.object({ result: intel_domain }).partial().passthrough());
const intel_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const intel_api_response_collection = intel_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: intel_result_info }).partial().passthrough());
const intel_domain_history = z.object({ categorizations: z.array(z.object({ categories: z.unknown(), end: z.string(), start: z.string() }).partial().passthrough()), domain: intel_domain_name }).partial().passthrough();
const intel_response = intel_api_response_collection.and(z.object({ result: z.array(intel_domain_history) }).partial().passthrough());
const intel_collection_response = intel_api_response_collection.and(z.object({ result: z.array(z.object({ additional_information: intel_additional_information, application: intel_application, content_categories: intel_content_categories, domain: intel_domain_name, inherited_content_categories: intel_categories_with_super_category_ids_example_empty, inherited_from: intel_inherited_from, inherited_risk_types: intel_categories_with_super_category_ids_example_empty, popularity_rank: intel_popularity_rank.int(), risk_score: intel_risk_score, risk_types: intel_risk_types }).partial().passthrough()) }).partial().passthrough());
const intel_description = z.string();
const intel_id = z.number();
const intel_name = z.string();
const intel_indicator_feed_item = z.object({ created_on: z.string().datetime({ offset: true }), description: intel_description, id: intel_id.int(), modified_on: z.string().datetime({ offset: true }), name: intel_name }).partial().passthrough();
const intel_indicator_feed_response = intel_api_response_common.and(z.object({ result: z.array(intel_indicator_feed_item) }).partial().passthrough());
const intel_create_feed = z.object({ description: intel_description, name: intel_name }).partial().passthrough();
const intel_create_feed_response = intel_api_response_single.and(z.object({ result: intel_indicator_feed_item }).partial().passthrough());
const intel_permissions_request = z.object({ account_tag: z.string(), feed_id: z.number().int() }).partial().passthrough();
const intel_permissions_update = z.object({ success: z.boolean() }).partial().passthrough();
const intel_permissions_response = intel_api_response_single.and(z.object({ result: intel_permissions_update }).partial().passthrough());
const intel_permission_list_item = z.object({ description: intel_description, id: intel_id.int(), name: intel_name }).partial().passthrough();
const intel_permission_list_item_response = intel_api_response_common.and(z.object({ result: z.array(intel_permission_list_item) }).partial().passthrough());
const intel_indicator_feed_metadata = z.object({ created_on: z.string().datetime({ offset: true }), description: intel_description, id: intel_id.int(), latest_upload_status: z.enum(["Mirroring", "Unifying", "Loading", "Provisioning", "Complete", "Error"]), modified_on: z.string().datetime({ offset: true }), name: intel_name }).partial().passthrough();
const intel_indicator_feed_metadata_response = intel_api_response_single.and(z.object({ result: intel_indicator_feed_metadata }).partial().passthrough());
const intel_update_feed = z.object({ file_id: z.number().int(), filename: z.string(), status: z.string() }).partial().passthrough();
const intel_update_feed_response = intel_api_response_single.and(z.object({ result: intel_update_feed }).partial().passthrough());
const intel_ipv4 = z.string();
const intel_ipv6 = z.string();
const intel_ip = z.union([intel_ipv4, intel_ipv6]);
const intel_schemas_ip = z.object({ belongs_to_ref: z.object({ country: z.string(), description: z.string(), id: z.unknown(), type: z.enum(["hosting_provider", "isp", "organization"]), value: z.string() }).partial().passthrough(), ip: intel_ip, risk_types: z.unknown() }).partial().passthrough();
const intel_schemas_response = intel_api_response_collection.and(z.object({ result: z.array(intel_schemas_ip) }).partial().passthrough());
const intel_ip_list = z.object({ description: z.string(), id: z.number().int(), name: z.string() }).partial().passthrough();
const intel_components_schemas_response = intel_api_response_collection.and(z.object({ result: z.array(intel_ip_list) }).partial().passthrough());
const intel_miscategorization = z.object({ content_adds: z.unknown(), content_removes: z.unknown(), indicator_type: z.unknown(), ip: z.unknown(), security_adds: z.unknown(), security_removes: z.unknown(), url: z.string() }).partial().passthrough();
const intel_sinkholes_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const intel_sinkholes_api_response_common = z.object({ errors: intel_sinkholes_messages, messages: intel_sinkholes_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const intel_sinkholes_id = z.number();
const intel_sinkholes_name = z.string();
const intel_sinkholes_sinkhole_item = z.object({ account_tag: z.string(), created_on: z.string().datetime({ offset: true }), id: intel_sinkholes_id.int(), modified_on: z.string().datetime({ offset: true }), name: intel_sinkholes_name, r2_bucket: z.string(), r2_id: z.string() }).partial().passthrough();
const intel_sinkholes_get_sinkholes_response = intel_sinkholes_api_response_common.and(z.object({ result: z.array(intel_sinkholes_sinkhole_item) }).partial().passthrough());
const intel_whois = z.object({ created_date: z.string(), domain: intel_domain_name, nameservers: z.array(z.string()), registrant: z.string(), registrant_country: z.string(), registrant_email: z.string(), registrant_org: z.string(), registrar: z.string(), updated_date: z.string() }).partial().passthrough();
const intel_schemas_single_response = intel_api_response_single.and(z.object({ result: intel_whois }).partial().passthrough());
const load_balancing_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const load_balancing_api_response_common = z.object({ errors: load_balancing_messages, messages: load_balancing_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const load_balancing_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const load_balancing_api_response_collection = load_balancing_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: load_balancing_result_info }).partial().passthrough());
const load_balancing_allow_insecure = z.boolean();
const load_balancing_consecutive_down = z.number();
const load_balancing_consecutive_up = z.number();
const load_balancing_description = z.string();
const load_balancing_expected_body = z.string();
const load_balancing_expected_codes = z.string();
const load_balancing_follow_redirects = z.boolean();
const load_balancing_header = z.object({}).partial().passthrough();
const load_balancing_interval = z.number();
const load_balancing_method = z.string();
const load_balancing_path = z.string();
const load_balancing_port = z.number();
const load_balancing_probe_zone = z.string();
const load_balancing_retries = z.number();
const load_balancing_timeout = z.number();
const load_balancing_type = z.enum(["http", "https", "tcp", "udp_icmp", "icmp_ping", "smtp"]);
const load_balancing_monitor_editable = z.object({ allow_insecure: load_balancing_allow_insecure, consecutive_down: load_balancing_consecutive_down.int(), consecutive_up: load_balancing_consecutive_up.int(), description: load_balancing_description, expected_body: load_balancing_expected_body, expected_codes: load_balancing_expected_codes.default("200"), follow_redirects: load_balancing_follow_redirects, header: load_balancing_header, interval: load_balancing_interval.int().default(60), method: load_balancing_method.default("GET"), path: load_balancing_path.default("/"), port: load_balancing_port.int(), probe_zone: load_balancing_probe_zone, retries: load_balancing_retries.int().default(2), timeout: load_balancing_timeout.int().default(5), type: load_balancing_type.default("http") }).partial().passthrough();
const load_balancing_timestamp = z.string();
const load_balancing_identifier = z.string();
const load_balancing_monitor = load_balancing_monitor_editable.and(z.object({ created_on: load_balancing_timestamp.datetime({ offset: true }), id: load_balancing_identifier, modified_on: load_balancing_timestamp.datetime({ offset: true }) }).partial().passthrough());
const load_balancing_monitor_response_collection = load_balancing_api_response_collection.and(z.object({ result: z.array(load_balancing_monitor) }).partial().passthrough());
const load_balancing_api_response_common_failure = z.object({ errors: load_balancing_messages, messages: load_balancing_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const account_load_balancer_monitors_create_monitor_Body = load_balancing_monitor_editable.and(z.object({ expected_codes: load_balancing_expected_codes.default("200") }).passthrough());
const load_balancing_api_response_single = load_balancing_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const load_balancing_monitor_response_single = load_balancing_api_response_single.and(z.object({ result: load_balancing_monitor }).partial().passthrough());
const load_balancing_id_response = load_balancing_api_response_single.and(z.object({ result: z.object({ id: load_balancing_identifier }).partial().passthrough() }).partial().passthrough());
const load_balancing_preview_response = load_balancing_api_response_single.and(z.object({ result: z.object({ pools: z.record(z.string()), preview_id: load_balancing_identifier }).partial().passthrough() }).partial().passthrough());
const load_balancing_references_response = load_balancing_api_response_collection.and(z.object({ result: z.array(z.object({ reference_type: z.enum(["*", "referral", "referrer"]), resource_id: z.string(), resource_name: z.string(), resource_type: z.string() }).partial().passthrough()) }).partial().passthrough());
const load_balancing_check_regions = z.array(z.enum(["WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS", "ALL_REGIONS"]));
const load_balancing_schemas_description = z.string();
const load_balancing_schemas_disabled_at = z.string();
const load_balancing_enabled = z.boolean();
const load_balancing_schemas_identifier = z.string();
const load_balancing_latitude = z.number();
const load_balancing_load_shedding = z.object({ default_percent: z.number().gte(0).lte(100), default_policy: z.enum(["random", "hash"]).default("random"), session_percent: z.number().gte(0).lte(100), session_policy: z.literal("hash").default("hash") }).partial().passthrough();
const load_balancing_longitude = z.number();
const load_balancing_minimum_origins = z.number();
const load_balancing_monitor_id = z.unknown();
const load_balancing_name = z.string();
const load_balancing_notification_email = z.string();
const load_balancing_filter_options = z.object({ disable: z.boolean(), healthy: z.boolean().nullable() }).partial().passthrough();
const load_balancing_notification_filter = z.object({ origin: load_balancing_filter_options.nullable(), pool: load_balancing_filter_options.nullable() }).partial().passthrough();
const load_balancing_origin_steering = z.object({ policy: z.enum(["random", "hash", "least_outstanding_requests", "least_connections"]).default("random") }).partial().passthrough();
const load_balancing_address = z.string();
const load_balancing_disabled_at = z.string();
const load_balancing_schemas_enabled = z.boolean();
const load_balancing_Host = z.array(z.string());
const load_balancing_schemas_header = z.object({ Host: load_balancing_Host }).partial().passthrough();
const load_balancing_schemas_name = z.string();
const load_balancing_virtual_network_id = z.string();
const load_balancing_weight = z.number();
const load_balancing_origin = z.object({ address: load_balancing_address, disabled_at: load_balancing_disabled_at.datetime({ offset: true }), enabled: load_balancing_schemas_enabled.default(true), header: load_balancing_schemas_header, name: load_balancing_schemas_name, virtual_network_id: load_balancing_virtual_network_id, weight: load_balancing_weight.gte(0).lte(1).multipleOf(0.01).default(1) }).partial().passthrough();
const load_balancing_origins = z.array(load_balancing_origin);
const load_balancing_pool = z.object({ check_regions: load_balancing_check_regions.nullable(), created_on: load_balancing_timestamp.datetime({ offset: true }), description: load_balancing_schemas_description, disabled_at: load_balancing_schemas_disabled_at.datetime({ offset: true }), enabled: load_balancing_enabled.default(true), id: load_balancing_schemas_identifier, latitude: load_balancing_latitude, load_shedding: load_balancing_load_shedding, longitude: load_balancing_longitude, minimum_origins: load_balancing_minimum_origins.int().default(1), modified_on: load_balancing_timestamp.datetime({ offset: true }), monitor: load_balancing_monitor_id, name: load_balancing_name, notification_email: load_balancing_notification_email, notification_filter: load_balancing_notification_filter.nullable(), origin_steering: load_balancing_origin_steering, origins: load_balancing_origins }).partial().passthrough();
const load_balancing_schemas_response_collection = load_balancing_api_response_collection.and(z.object({ result: z.array(load_balancing_pool) }).partial().passthrough());
const load_balancing_patch_pools_notification_email = z.literal("""");
const load_balancing_schemas_single_response = load_balancing_api_response_single.and(z.object({ result: load_balancing_pool }).partial().passthrough());
const load_balancing_schemas_id_response = load_balancing_api_response_single.and(z.object({ result: z.object({ id: load_balancing_schemas_identifier }).partial().passthrough() }).partial().passthrough());
const load_balancing_health_details = load_balancing_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const load_balancing_schemas_references_response = load_balancing_api_response_collection.and(z.object({ result: z.array(z.object({ reference_type: z.enum(["*", "referral", "referrer"]), resource_id: z.string(), resource_name: z.string(), resource_type: z.string() }).partial().passthrough()) }).partial().passthrough());
const load_balancing_origin_health_data = z.object({ failure_reason: z.string(), healthy: z.boolean(), response_code: z.number(), rtt: z.string() }).partial().passthrough();
const load_balancing_preview_result = z.record(z.object({ healthy: z.boolean(), origins: z.array(z.record(load_balancing_origin_health_data)) }).partial().passthrough());
const load_balancing_preview_result_response = load_balancing_api_response_single.and(z.object({ result: load_balancing_preview_result }).partial().passthrough());
const load_balancing_region_components_schemas_response_collection = load_balancing_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const load_balancing_components_schemas_single_response = load_balancing_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const search_params = z.object({ query: z.string(), references: z.enum(["", "*", "referral", "referrer"]) }).partial().passthrough().optional();
const load_balancing_resource_reference = z.object({ reference_type: z.enum(["referral", "referrer"]), references: z.array(z.object({}).partial().passthrough()), resource_id: z.unknown(), resource_name: z.string(), resource_type: z.enum(["load_balancer", "monitor", "pool"]) }).partial().passthrough();
const load_balancing_search = z.object({ resources: z.array(load_balancing_resource_reference) }).partial().passthrough();
const load_balancing_search_result = z.object({ result: load_balancing_search }).partial().passthrough();
const logpush_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const logpush_api_response_common = z.object({ errors: logpush_messages, messages: logpush_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const logpush_logpush_field_response_collection = logpush_api_response_common.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const logpush_api_response_common_failure = z.object({ errors: logpush_messages, messages: logpush_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const logpush_dataset = z.string();
const logpush_destination_conf = z.string();
const logpush_enabled = z.boolean();
const logpush_error_message = z.string();
const logpush_frequency = z.enum(["high", "low"]);
const logpush_id = z.number();
const logpush_last_complete = z.string();
const logpush_last_error = z.string();
const logpush_logpull_options = z.string();
const logpush_name = z.string();
const logpush_output_options = z.object({ "CVE-2021-4428": z.boolean().nullable(), batch_prefix: z.string().nullable(), batch_suffix: z.string().nullable(), field_delimiter: z.string().nullable().default(","), field_names: z.array(z.string()), output_type: z.enum(["ndjson", "csv"]).default("ndjson"), record_delimiter: z.string().nullable(), record_prefix: z.string().nullable().default("{"), record_suffix: z.string().nullable().default("}\n"), record_template: z.string().nullable(), sample_rate: z.number().gte(0).lte(1).nullable().default(1), timestamp_format: z.enum(["unixnano", "unix", "rfc3339"]).default("unixnano") }).partial().passthrough();
const logpush_logpush_job = z.object({ dataset: logpush_dataset.max(256).regex(/^[a-zA-Z0-9_\-]*$/).nullable(), destination_conf: logpush_destination_conf.max(4096).url(), enabled: logpush_enabled, error_message: logpush_error_message.datetime({ offset: true }).nullable(), frequency: logpush_frequency.nullable().default("high"), id: logpush_id.int().gte(1), last_complete: logpush_last_complete.datetime({ offset: true }).nullable(), last_error: logpush_last_error.datetime({ offset: true }).nullable(), logpull_options: logpush_logpull_options.max(4096).nullable(), name: logpush_name.max(512).regex(/^[a-zA-Z0-9\-\.]*$/).nullable(), output_options: logpush_output_options.nullable() }).partial().passthrough();
const logpush_logpush_job_response_collection = logpush_api_response_common.and(z.object({ result: z.array(logpush_logpush_job) }).partial().passthrough());
const logpush_ownership_challenge = z.string();
const logpush_api_response_single = logpush_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const logpush_logpush_job_response_single = logpush_api_response_single.and(z.object({ result: logpush_logpush_job.nullable() }).partial().passthrough());
const logpush_get_ownership_response = logpush_api_response_common.and(z.object({ result: z.object({ filename: z.string(), message: z.string(), valid: z.boolean() }).partial().passthrough().nullable() }).partial().passthrough());
const logpush_validate_ownership_response = logpush_api_response_common.and(z.object({ result: z.object({ valid: z.boolean() }).partial().passthrough().nullable() }).partial().passthrough());
const logpush_destination_exists_response = logpush_api_response_common.and(z.object({ result: z.object({ exists: z.boolean() }).partial().passthrough().nullable() }).partial().passthrough());
const logpush_validate_response = logpush_api_response_common.and(z.object({ result: z.object({ message: z.string(), valid: z.boolean() }).partial().passthrough().nullable() }).partial().passthrough());
const logcontrol_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const logcontrol_api_response_common = z.object({ errors: logcontrol_messages, messages: logcontrol_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const logcontrol_api_response_common_failure = z.object({ errors: logcontrol_messages, messages: logcontrol_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const logcontrol_api_response_single = logcontrol_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const logcontrol_regions = z.string();
const logcontrol_cmb_config = z.object({ regions: logcontrol_regions.max(256).regex(/^[a-z,]*$/) }).partial().passthrough();
const logcontrol_cmb_config_response_single = logcontrol_api_response_single.and(z.object({ result: logcontrol_cmb_config.nullable() }).partial().passthrough());
const iam_email = z.string();
const iam_member_components_schemas_name = z.string();
const iam_description = z.string();
const iam_role_components_schemas_identifier = z.string();
const iam_components_schemas_name = z.string();
const iam_schemas_permissions = z.array(z.string());
const iam_schemas_role = z.object({ description: iam_description, id: iam_role_components_schemas_identifier.max(32), name: iam_components_schemas_name.max(120), permissions: iam_schemas_permissions }).passthrough();
const iam_components_schemas_member = z.object({ email: iam_email.max(90), id: iam_common_components_schemas_identifier.max(32), name: iam_member_components_schemas_name.max(100).nullable(), roles: z.array(iam_schemas_role), status: z.unknown() }).passthrough();
const iam_collection_member_response = iam_api_response_collection.and(z.object({ result: z.array(iam_components_schemas_member) }).partial().passthrough());
const iam_create = z.object({ email: iam_email.max(90), roles: z.array(iam_role_components_schemas_identifier), status: z.unknown().optional().default("pending") }).passthrough();
const iam_membership_components_schemas_identifier = z.string();
const iam_grants = z.object({ read: z.boolean(), write: z.boolean() }).partial().passthrough();
const iam_permissions = z.object({ analytics: iam_grants, billing: iam_grants, cache_purge: iam_grants, dns: iam_grants, dns_records: iam_grants, lb: iam_grants, logs: iam_grants, organization: iam_grants, ssl: iam_grants, waf: iam_grants, zone_settings: iam_grants, zones: iam_grants }).partial().passthrough();
const iam_role = z.object({ description: z.string(), id: iam_role_components_schemas_identifier.max(32), name: z.string().max(120), permissions: iam_permissions.and(z.unknown()) }).passthrough();
const iam_first_name = z.string();
const iam_last_name = z.string();
const iam_two_factor_authentication_enabled = z.boolean();
const iam_member = z.object({ id: iam_membership_components_schemas_identifier.max(32), roles: z.array(iam_role), status: z.unknown(), user: z.object({ email: iam_email.max(90), first_name: iam_first_name.max(60).nullish(), id: iam_common_components_schemas_identifier.max(32).optional(), last_name: iam_last_name.max(60).nullish(), two_factor_authentication_enabled: iam_two_factor_authentication_enabled.optional() }).passthrough() }).passthrough();
const iam_code = z.string();
const iam_member_with_code = iam_member.and(z.object({ code: iam_code.max(64) }).partial().passthrough());
const iam_single_member_response_with_code = iam_api_response_single.and(z.object({ result: iam_member_with_code }).partial().passthrough());
const iam_api_response_single_id = iam_api_response_common.and(z.object({ result: z.object({ id: iam_common_components_schemas_identifier.max(32) }).passthrough().nullable() }).partial().passthrough());
const iam_single_member_response = iam_api_response_single.and(z.object({ result: iam_member }).partial().passthrough());
const iam_schemas_member = iam_member;
const tls_certificates_and_hostnames_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const tls_certificates_and_hostnames_api_response_common = z.object({ errors: tls_certificates_and_hostnames_messages, messages: tls_certificates_and_hostnames_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const tls_certificates_and_hostnames_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const tls_certificates_and_hostnames_api_response_collection = tls_certificates_and_hostnames_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: tls_certificates_and_hostnames_result_info }).partial().passthrough());
const tls_certificates_and_hostnames_ca = z.boolean();
const tls_certificates_and_hostnames_schemas_certificates = z.string();
const tls_certificates_and_hostnames_mtls_management_components_schemas_expires_on = z.string();
const tls_certificates_and_hostnames_identifier = z.string();
const tls_certificates_and_hostnames_schemas_issuer = z.string();
const tls_certificates_and_hostnames_schemas_name = z.string();
const tls_certificates_and_hostnames_schemas_serial_number = z.string();
const tls_certificates_and_hostnames_signature = z.string();
const tls_certificates_and_hostnames_mtls_management_components_schemas_uploaded_on = z.string();
const tls_certificates_and_hostnames_components_schemas_certificateObject = z.object({ ca: tls_certificates_and_hostnames_ca, certificates: tls_certificates_and_hostnames_schemas_certificates, expires_on: tls_certificates_and_hostnames_mtls_management_components_schemas_expires_on.datetime({ offset: true }), id: tls_certificates_and_hostnames_identifier.max(32), issuer: tls_certificates_and_hostnames_schemas_issuer, name: tls_certificates_and_hostnames_schemas_name, serial_number: tls_certificates_and_hostnames_schemas_serial_number, signature: tls_certificates_and_hostnames_signature, uploaded_on: tls_certificates_and_hostnames_mtls_management_components_schemas_uploaded_on.datetime({ offset: true }) }).partial().passthrough();
const tls_certificates_and_hostnames_mtls_management_components_schemas_certificate_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(tls_certificates_and_hostnames_components_schemas_certificateObject) }).partial().passthrough()).and(z.object({ result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown(), total_pages: z.unknown() }).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_api_response_common_failure = z.object({ errors: tls_certificates_and_hostnames_messages, messages: tls_certificates_and_hostnames_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const tls_certificates_and_hostnames_components_schemas_private_key = z.string();
const m_tls_certificate_management_upload_m_tls_certificate_Body = z.object({ ca: tls_certificates_and_hostnames_ca, certificates: tls_certificates_and_hostnames_schemas_certificates, name: tls_certificates_and_hostnames_schemas_name.optional(), private_key: tls_certificates_and_hostnames_components_schemas_private_key.optional() }).passthrough();
const tls_certificates_and_hostnames_api_response_single = tls_certificates_and_hostnames_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const tls_certificates_and_hostnames_schemas_updated_at = z.string();
const tls_certificates_and_hostnames_certificateObjectPost = z.object({ ca: tls_certificates_and_hostnames_ca, certificates: tls_certificates_and_hostnames_schemas_certificates, expires_on: tls_certificates_and_hostnames_mtls_management_components_schemas_expires_on.datetime({ offset: true }), id: tls_certificates_and_hostnames_identifier.max(32), issuer: tls_certificates_and_hostnames_schemas_issuer, name: tls_certificates_and_hostnames_schemas_name, serial_number: tls_certificates_and_hostnames_schemas_serial_number, signature: tls_certificates_and_hostnames_signature, updated_at: tls_certificates_and_hostnames_schemas_updated_at.datetime({ offset: true }), uploaded_on: tls_certificates_and_hostnames_mtls_management_components_schemas_uploaded_on.datetime({ offset: true }) }).partial().passthrough();
const tls_certificates_and_hostnames_certificate_response_single_post = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_certificateObjectPost }).partial().passthrough());
const tls_certificates_and_hostnames_mtls_management_components_schemas_certificate_response_single = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_components_schemas_certificateObject }).partial().passthrough());
const tls_certificates_and_hostnames_service = z.string();
const tls_certificates_and_hostnames_mtls_management_components_schemas_status = z.string();
const tls_certificates_and_hostnames_associationObject = z.object({ service: tls_certificates_and_hostnames_service, status: tls_certificates_and_hostnames_mtls_management_components_schemas_status }).partial().passthrough();
const tls_certificates_and_hostnames_association_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(tls_certificates_and_hostnames_associationObject) }).partial().passthrough());
const pages_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const pages_api_response_common = z.object({ errors: pages_messages, messages: pages_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const pages_stage = z.object({ ended_on: z.string().datetime({ offset: true }).nullable(), name: z.string().regex(/queued|initialize|clone_repo|build|deploy/), started_on: z.string().datetime({ offset: true }).nullable(), status: z.string().regex(/success|idle|active|failure|canceled/) }).partial().passthrough();
const pages_deployments = z.object({ aliases: z.array(z.unknown()).nullable(), build_config: z.unknown(), created_on: z.string().datetime({ offset: true }), deployment_trigger: z.object({ metadata: z.object({ branch: z.string(), commit_hash: z.string(), commit_message: z.string() }).partial().passthrough(), type: z.string().regex(/push|ad_hoc/) }).partial().passthrough(), env_vars: z.object({}).partial().passthrough(), environment: z.string().regex(/preview|production/), id: z.string(), is_skipped: z.boolean(), latest_stage: z.unknown(), modified_on: z.string().datetime({ offset: true }), project_id: z.string(), project_name: z.string(), short_id: z.string(), source: z.unknown(), stages: z.array(pages_stage), url: z.string() }).partial().passthrough();
const pages_projects_response = pages_api_response_common.and(z.object({ result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown() }).partial().passthrough() }).partial().passthrough()).and(z.object({ result: z.array(pages_deployments) }).partial().passthrough());
const pages_api_response_common_failure = z.object({ errors: pages_messages, messages: pages_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const pages_build_config = z.object({ build_caching: z.boolean().nullable(), build_command: z.string().nullable(), destination_dir: z.string().nullable(), root_dir: z.string().nullable(), web_analytics_tag: z.string().nullable(), web_analytics_token: z.string().nullable() }).partial().passthrough();
const pages_deployment_configs_values = z.object({ ai_bindings: z.object({ AI_BINDING: z.object({ project_id: z.unknown() }).partial().passthrough() }).partial().passthrough().nullable(), analytics_engine_datasets: z.object({ ANALYTICS_ENGINE_BINDING: z.object({ dataset: z.string() }).partial().passthrough() }).partial().passthrough().nullable(), compatibility_date: z.string(), compatibility_flags: z.array(z.unknown()), d1_databases: z.object({ D1_BINDING: z.object({ id: z.string() }).partial().passthrough() }).partial().passthrough().nullable(), durable_object_namespaces: z.object({ DO_BINDING: z.object({ namespace_id: z.string() }).partial().passthrough() }).partial().passthrough().nullable(), env_vars: z.object({ ENVIRONMENT_VARIABLE: z.object({ type: z.enum(["plain_text", "secret_text"]), value: z.string() }).partial().passthrough() }).partial().passthrough().nullable(), kv_namespaces: z.object({ KV_BINDING: z.object({ namespace_id: z.string() }).partial().passthrough() }).partial().passthrough(), placement: z.object({ mode: z.string() }).partial().passthrough().nullable(), queue_producers: z.object({ QUEUE_PRODUCER_BINDING: z.object({ name: z.string() }).partial().passthrough() }).partial().passthrough().nullable(), r2_buckets: z.object({ R2_BINDING: z.object({ name: z.string() }).partial().passthrough() }).partial().passthrough().nullable(), service_bindings: z.object({ SERVICE_BINDING: z.object({ environment: z.string(), service: z.string() }).partial().passthrough() }).partial().passthrough().nullable() }).partial().passthrough();
const pages_deployment_configs = z.object({ preview: pages_deployment_configs_values, production: pages_deployment_configs_values }).partial().passthrough();
const pages_projects = z.object({ build_config: pages_build_config, canonical_deployment: pages_deployments, created_on: z.string().datetime({ offset: true }), deployment_configs: pages_deployment_configs, domains: z.array(z.unknown()), id: z.string(), latest_deployment: pages_deployments, name: z.string(), production_branch: z.string(), source: z.unknown(), subdomain: z.string() }).partial().passthrough();
const pages_new_project_response = pages_api_response_common.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const pages_project_response = pages_api_response_common.and(z.object({ result: pages_projects }).partial().passthrough());
const pages_project_patch = z.unknown();
const pages_deployment_list_response = pages_api_response_common.and(z.object({ result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown() }).partial().passthrough() }).partial().passthrough()).and(z.object({ result: z.array(pages_deployments) }).partial().passthrough());
const pages_deployment_new_deployment = pages_api_response_common.and(z.object({ result: pages_deployments }).partial().passthrough());
const pages_deployment_response_details = pages_api_response_common.and(z.object({ result: pages_deployments }).partial().passthrough());
const pages_deployment_response_logs = pages_api_response_common.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const pages_domain_response_collection = pages_api_response_common.and(z.object({ result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown() }).partial().passthrough() }).partial().passthrough()).and(z.object({ result: z.array(z.object({}).partial().passthrough()) }).partial().passthrough());
const pages_domains_post = z.unknown();
const pages_api_response_single = pages_api_response_common.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough());
const pages_domain_response_single = pages_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const magic_visibility_pcaps_filter_v1 = z.object({ destination_address: z.string(), destination_port: z.number(), protocol: z.number(), source_address: z.string(), source_port: z.number() }).partial().passthrough();
const magic_visibility_pcaps_id = z.string();
const magic_visibility_pcaps_status = z.enum(["unknown", "success", "pending", "running", "conversion_pending", "conversion_running", "complete", "failed"]);
const magic_visibility_pcaps_submitted = z.string();
const magic_visibility_pcaps_system = z.literal("magic-transit");
const magic_visibility_pcaps_time_limit = z.number();
const magic_visibility_pcaps_type = z.enum(["simple", "full"]);
const magic_visibility_pcaps_response_simple = z.object({ filter_v1: magic_visibility_pcaps_filter_v1, id: magic_visibility_pcaps_id.min(32).max(32), status: magic_visibility_pcaps_status, submitted: magic_visibility_pcaps_submitted, system: magic_visibility_pcaps_system, time_limit: magic_visibility_pcaps_time_limit.gte(1).lte(300), type: magic_visibility_pcaps_type }).partial().passthrough();
const magic_visibility_pcaps_byte_limit = z.number();
const magic_visibility_pcaps_colo_name = z.string();
const magic_visibility_pcaps_destination_conf = z.string();
const magic_visibility_pcaps_error_message = z.string();
const magic_visibility_pcaps_response_full = z.object({ byte_limit: magic_visibility_pcaps_byte_limit.gte(1).lte(1000000000), colo_name: magic_visibility_pcaps_colo_name, destination_conf: magic_visibility_pcaps_destination_conf, error_message: magic_visibility_pcaps_error_message, filter_v1: magic_visibility_pcaps_filter_v1, id: magic_visibility_pcaps_id.min(32).max(32), status: magic_visibility_pcaps_status, submitted: magic_visibility_pcaps_submitted, system: magic_visibility_pcaps_system, time_limit: magic_visibility_pcaps_time_limit.gte(1).lte(300), type: magic_visibility_pcaps_type }).partial().passthrough();
const magic_visibility_pcaps_collection_response = magic_visibility_api_response_collection.and(z.object({ result: z.array(z.union([magic_visibility_pcaps_response_simple, magic_visibility_pcaps_response_full])) }).partial().passthrough());
const magic_visibility_pcaps_packet_limit = z.number();
const magic_visibility_pcaps_request_simple = z.object({ filter_v1: magic_visibility_pcaps_filter_v1.optional(), packet_limit: magic_visibility_pcaps_packet_limit.gte(1).lte(10000), system: magic_visibility_pcaps_system, time_limit: magic_visibility_pcaps_time_limit.gte(1).lte(300), type: magic_visibility_pcaps_type }).passthrough();
const magic_visibility_pcaps_request_full = z.object({ byte_limit: magic_visibility_pcaps_byte_limit.gte(1).lte(1000000000).optional(), colo_name: magic_visibility_pcaps_colo_name, destination_conf: magic_visibility_pcaps_destination_conf, filter_v1: magic_visibility_pcaps_filter_v1.optional(), packet_limit: magic_visibility_pcaps_packet_limit.gte(1).lte(10000).optional(), system: magic_visibility_pcaps_system, time_limit: magic_visibility_pcaps_time_limit.gte(1).lte(300), type: magic_visibility_pcaps_type }).passthrough();
const magic_visibility_pcaps_request_pcap = z.union([magic_visibility_pcaps_request_simple, magic_visibility_pcaps_request_full]);
const magic_visibility_pcaps_single_response = magic_visibility_api_response_single.and(z.object({ result: z.union([magic_visibility_pcaps_response_simple, magic_visibility_pcaps_response_full]) }).partial().passthrough());
const magic_visibility_pcaps_ownership_challenge = z.string();
const magic_visibility_pcaps_ownership_response = z.object({ destination_conf: magic_visibility_pcaps_destination_conf, filename: magic_visibility_pcaps_ownership_challenge, id: z.string().min(32).max(32), status: z.enum(["pending", "success", "failed"]), submitted: z.string(), validated: z.string().optional() }).passthrough();
const magic_visibility_pcaps_ownership_collection = magic_visibility_api_response_collection.and(z.object({ result: z.array(magic_visibility_pcaps_ownership_response).nullable() }).partial().passthrough());
const magic_visibility_pcaps_ownership_request = z.object({ destination_conf: magic_visibility_pcaps_destination_conf }).passthrough();
const magic_visibility_pcaps_ownership_single_response = magic_visibility_api_response_common.and(z.object({ result: magic_visibility_pcaps_ownership_response }).partial().passthrough());
const magic_visibility_pcaps_ownership_validate_request = z.object({ destination_conf: magic_visibility_pcaps_destination_conf, ownership_challenge: magic_visibility_pcaps_ownership_challenge }).passthrough();
const r2_errors = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const r2_messages = z.array(z.string());
const r2_v4_response = z.object({ errors: r2_errors, messages: r2_messages, result: z.object({}).partial().passthrough(), success: z.literal(true) }).passthrough();
const r2_result_info = z.object({ cursor: z.string(), per_page: z.number() }).partial().passthrough();
const r2_v4_response_list = r2_v4_response.and(z.object({ result_info: r2_result_info }).partial().passthrough());
const r2_bucket_location = z.enum(["apac", "eeur", "enam", "weur", "wnam"]);
const r2_bucket_name = z.string();
const r2_bucket = z.object({ creation_date: z.string(), location: r2_bucket_location, name: r2_bucket_name.min(3).max(64).regex(/^[a-z0-9][a-z0-9-]*[a-z0-9]/) }).partial().passthrough();
const r2_v4_response_failure = z.object({ errors: r2_errors, messages: r2_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const r2_create_bucket_Body = z.object({ locationHint: r2_bucket_location.optional(), name: r2_bucket_name.min(3).max(64).regex(/^[a-z0-9][a-z0-9-]*[a-z0-9]/) }).passthrough();
const r2_sippy = z.object({ destination: z.object({ accessKeyId: z.string(), account: z.string(), bucket: z.string(), provider: z.literal("r2") }).partial().passthrough(), enabled: z.boolean(), source: z.object({ bucket: z.string(), provider: z.enum(["aws", "gcs"]), region: z.string().nullable() }).partial().passthrough() }).partial().passthrough();
const r2_enable_sippy_aws = z.object({ destination: z.object({ accessKeyId: z.string(), provider: z.literal("r2"), secretAccessKey: z.string() }).partial().passthrough(), source: z.object({ accessKeyId: z.string(), bucket: z.string(), provider: z.literal("aws"), region: z.string(), secretAccessKey: z.string() }).partial().passthrough() }).partial().passthrough();
const r2_enable_sippy_gcs = z.object({ destination: z.object({ accessKeyId: z.string(), provider: z.literal("r2"), secretAccessKey: z.string() }).partial().passthrough(), source: z.object({ bucket: z.string(), clientEmail: z.string(), privateKey: z.string(), provider: z.literal("gcs") }).partial().passthrough() }).partial().passthrough();
const r2_put_bucket_sippy_config_Body = z.union([r2_enable_sippy_aws, r2_enable_sippy_gcs]);
const registrar_api_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const registrar_api_api_response_common = z.object({ errors: registrar_api_messages, messages: registrar_api_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const registrar_api_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const registrar_api_api_response_collection = registrar_api_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: registrar_api_result_info }).partial().passthrough());
const registrar_api_available = z.boolean();
const registrar_api_can_register = z.boolean();
const registrar_api_created_at = z.string();
const registrar_api_current_registrar = z.string();
const registrar_api_expires_at = z.string();
const registrar_api_domain_identifier = z.string();
const registrar_api_locked = z.boolean();
const registrar_api_address = z.string();
const registrar_api_address2 = z.string();
const registrar_api_city = z.string();
const registrar_api_country = z.string();
const registrar_api_email = z.string();
const registrar_api_fax = z.string();
const registrar_api_first_name = z.string();
const registrar_api_contact_identifier = z.string();
const registrar_api_last_name = z.string();
const registrar_api_organization = z.string();
const registrar_api_telephone = z.string();
const registrar_api_state = z.string();
const registrar_api_zipcode = z.string();
const registrar_api_contact_properties = z.object({ address: registrar_api_address, address2: registrar_api_address2.optional(), city: registrar_api_city, country: registrar_api_country.max(30).nullable(), email: registrar_api_email.max(90).optional(), fax: registrar_api_fax.optional(), first_name: registrar_api_first_name.max(60).nullable(), id: registrar_api_contact_identifier.max(32).optional(), last_name: registrar_api_last_name.max(60).nullable(), organization: registrar_api_organization, phone: registrar_api_telephone.max(20).nullable(), state: registrar_api_state, zip: registrar_api_zipcode.max(20).nullable() }).passthrough();
const registrar_api_contacts = registrar_api_contact_properties;
const registrar_api_registrant_contact = registrar_api_contacts;
const registrar_api_registry_statuses = z.string();
const registrar_api_supported_tld = z.boolean();
const registrar_api_transfer_in = z.object({ accept_foa: z.unknown(), approve_transfer: z.unknown(), can_cancel_transfer: z.boolean(), disable_privacy: z.unknown(), enter_auth_code: z.unknown(), unlock_domain: z.unknown() }).partial().passthrough();
const registrar_api_updated_at = z.string();
const registrar_api_domain_properties = z.object({ available: registrar_api_available, can_register: registrar_api_can_register, created_at: registrar_api_created_at.datetime({ offset: true }), current_registrar: registrar_api_current_registrar, expires_at: registrar_api_expires_at.datetime({ offset: true }), id: registrar_api_domain_identifier.max(32), locked: registrar_api_locked, registrant_contact: registrar_api_registrant_contact, registry_statuses: registrar_api_registry_statuses, supported_tld: registrar_api_supported_tld, transfer_in: registrar_api_transfer_in, updated_at: registrar_api_updated_at.datetime({ offset: true }) }).partial().passthrough();
const registrar_api_domains = registrar_api_domain_properties;
const registrar_api_domain_response_collection = registrar_api_api_response_collection.and(z.object({ result: z.array(registrar_api_domains) }).partial().passthrough());
const registrar_api_api_response_common_failure = z.object({ errors: registrar_api_messages, messages: registrar_api_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const registrar_api_api_response_single = registrar_api_api_response_common.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough());
const registrar_api_domain_response_single = registrar_api_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const registrar_api_auto_renew = z.boolean();
const registrar_api_privacy = z.boolean();
const registrar_api_domain_update_properties = z.object({ auto_renew: registrar_api_auto_renew, locked: registrar_api_locked, privacy: registrar_api_privacy }).partial().passthrough();
const registrar_domains_update_domain_Body = registrar_api_domain_update_properties;
const iam_collection_role_response = iam_api_response_collection.and(z.object({ result: z.array(iam_schemas_role) }).partial().passthrough());
const iam_single_role_response = iam_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const lists_created_on = z.string();
const lists_description = z.string();
const lists_list_id = z.string();
const lists_kind = z.unknown();
const lists_modified_on = z.string();
const lists_name = z.string();
const lists_num_items = z.number();
const lists_num_referencing_filters = z.number();
const lists_list = z.object({ created_on: lists_created_on, description: lists_description.max(500), id: lists_list_id.min(32).max(32), kind: lists_kind, modified_on: lists_modified_on, name: lists_name.max(50).regex(/^[a-zA-Z0-9_]+$/), num_items: lists_num_items, num_referencing_filters: lists_num_referencing_filters }).partial().passthrough();
const lists_lists_response_collection = lists_api_response_collection.and(z.object({ result: z.array(lists_list.and(z.object({}).passthrough())) }).partial().passthrough());
const lists_create_a_list_Body = z.object({ description: lists_description.max(500).optional(), kind: lists_kind, name: lists_name.max(50).regex(/^[a-zA-Z0-9_]+$/) }).passthrough();
const lists_list_response_collection = lists_api_response_collection.and(z.object({ result: lists_list }).partial().passthrough());
const lists_item_id = z.string();
const lists_list_delete_response_collection = lists_api_response_collection.and(z.object({ result: z.object({ id: lists_item_id }).partial().passthrough() }).partial().passthrough());
const lists_update_a_list_Body = z.object({ description: lists_description.max(500) }).partial().passthrough();
const lists_lists_async_response = lists_api_response_collection.and(z.object({ result: z.object({ operation_id: lists_operation_id }).partial().passthrough() }).partial().passthrough());
const lists_items = z.array(lists_item);
const lists_items_list_response_collection = lists_api_response_collection.and(z.object({ result: lists_items, result_info: z.object({ cursors: z.object({ after: z.string(), before: z.string() }).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const lists_item_comment = z.string();
const lists_items_update_request_collection = z.array(z.object({ asn: lists_item_asn.int(), comment: lists_item_comment, hostname: lists_item_hostname, ip: lists_item_ip, redirect: lists_item_redirect }).partial().passthrough());
const rulesets_Message = z.object({ code: z.number().int().optional(), message: z.string().min(1), source: z.object({ pointer: z.string().min(1) }).passthrough().optional() }).passthrough();
const rulesets_Errors = z.array(rulesets_Message);
const rulesets_Messages = z.array(rulesets_Message);
const rulesets_Response = z.object({ errors: rulesets_Errors.and(z.unknown()), messages: rulesets_Messages, result: z.unknown(), success: z.literal(true) }).passthrough();
const rulesets_RulesetId = z.string();
const rulesets_RulesetKind = z.enum(["managed", "custom", "root", "zone"]);
const rulesets_RulesetPhase = z.enum(["ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_select_configuration", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed"]);
const rulesets_RulesetVersion = z.string();
const rulesets_Ruleset = z.object({ description: z.string().optional(), id: rulesets_RulesetId.and(z.unknown()), kind: rulesets_RulesetKind.optional(), last_updated: z.string().datetime({ offset: true }), name: z.string().min(1).optional(), phase: rulesets_RulesetPhase.optional(), version: rulesets_RulesetVersion.regex(/^[0-9]+$/) }).passthrough();
const rulesets_RulesetsResponse = z.array(rulesets_Ruleset.and(z.object({ name: z.string().min(1), kind: rulesets_RulesetKind, phase: rulesets_RulesetPhase }).passthrough()));
const rulesets_FailureResponse = z.object({ errors: rulesets_Errors, messages: rulesets_Messages, result: z.unknown(), success: z.literal(false) }).passthrough();
const rulesets_RuleAction = z.string();
const rulesets_RuleCategory = z.string();
const rulesets_RuleEnabled = z.boolean();
const rulesets_RuleId = z.string();
const rulesets_Rule = z.object({ action: rulesets_RuleAction.regex(/^[a-z]+$/).optional(), action_parameters: z.object({}).partial().passthrough().optional(), categories: z.array(rulesets_RuleCategory).min(1).optional(), description: z.string().optional(), enabled: rulesets_RuleEnabled.and(z.unknown()).optional(), expression: z.string().min(1).optional(), id: rulesets_RuleId.regex(/^[0-9a-f]{32}$/).optional(), last_updated: z.string().datetime({ offset: true }), logging: z.object({ enabled: z.boolean() }).passthrough().optional(), ref: z.string().min(1).optional(), version: z.string().regex(/^[0-9]+$/) }).passthrough();
const rulesets_BlockRule = rulesets_Rule.and(z.object({ action: z.unknown(), action_parameters: z.object({ response: z.object({ content: z.string().min(1), content_type: z.string().min(1), status_code: z.number().int().gte(400).lte(499) }).passthrough() }).partial().passthrough(), description: z.unknown() }).partial().passthrough());
const rulesets_ExecuteSensitivityLevel = z.enum(["default", "medium", "low", "eoff"]);
const rulesets_ExecuteRule = rulesets_Rule.and(z.object({ action: z.unknown(), action_parameters: z.object({ id: rulesets_RulesetId.and(z.unknown()), matched_data: z.object({ public_key: z.string().min(1) }).passthrough().optional(), overrides: z.object({ action: rulesets_RuleAction.and(z.unknown()), categories: z.array(z.object({ action: rulesets_RuleAction.and(z.unknown()).optional(), category: rulesets_RuleCategory.and(z.unknown()), enabled: rulesets_RuleEnabled.and(z.unknown()).optional(), sensitivity_level: rulesets_ExecuteSensitivityLevel.and(z.unknown()).optional() }).passthrough()).min(1), enabled: rulesets_RuleEnabled.and(z.unknown()), rules: z.array(z.object({ action: rulesets_RuleAction.and(z.unknown()).optional(), enabled: rulesets_RuleEnabled.and(z.unknown()).optional(), id: rulesets_RuleId.and(z.unknown()), score_threshold: z.number().int().optional(), sensitivity_level: rulesets_ExecuteSensitivityLevel.and(z.unknown()).optional() }).passthrough()).min(1), sensitivity_level: rulesets_ExecuteSensitivityLevel.and(z.unknown()) }).partial().passthrough().optional() }).passthrough(), description: z.unknown() }).partial().passthrough());
const rulesets_LogRule = rulesets_Rule.and(z.object({ action: z.unknown(), action_parameters: z.unknown(), description: z.unknown() }).partial().passthrough());
const rulesets_SkipRule = rulesets_Rule.and(z.object({ action: z.unknown(), action_parameters: z.object({ phases: z.array(rulesets_RulesetPhase.and(z.unknown())).min(1), products: z.array(z.enum(["bic", "hot", "rateLimit", "securityLevel", "uaBlock", "waf", "zoneLockdown"])).min(1), rules: z.record(z.array(rulesets_RuleId.and(z.unknown())).min(1)), ruleset: z.literal("current"), rulesets: z.array(rulesets_RulesetId.and(z.unknown())).min(1) }).partial().passthrough(), description: z.unknown() }).partial().passthrough());
const rulesets_RuleRequest =
	z.discriminatedUnion("action", [rulesets_BlockRule, rulesets_ExecuteRule, rulesets_LogRule, rulesets_SkipRule])
	;
const rulesets_RulesRequest = z.array(rulesets_RuleRequest);
const rulesets_CreateRulesetRequest = rulesets_Ruleset.and(z.object({ rules: rulesets_RulesRequest }).passthrough());
const rulesets_RuleResponse = rulesets_RuleRequest.and(z.object({ id: z.unknown(), expression: z.unknown(), action: z.unknown(), ref: z.unknown(), enabled: z.unknown() }).passthrough());
const rulesets_RulesResponse = z.array(rulesets_RuleResponse);
const rulesets_RulesetResponse = rulesets_Ruleset.and(z.object({ rules: rulesets_RulesResponse }).passthrough());
const rulesets_UpdateRulesetRequest = rulesets_Ruleset.and(z.object({ rules: rulesets_RulesRequest }).passthrough());
const rulesets_RulePosition = z.object({}).partial().passthrough();
const rulesets_CreateOrUpdateRuleRequest = rulesets_RuleRequest.and(z.object({ position: z.union([rulesets_RulePosition.and(z.object({ before: z.string().regex(/^(?:[0-9a-f]{32})?$/) }).partial().passthrough()), rulesets_RulePosition.and(z.object({ after: z.string().regex(/^(?:[0-9a-f]{32})?$/) }).partial().passthrough()), rulesets_RulePosition.and(z.object({ index: z.number().gte(1) }).partial().passthrough())]) }).partial().passthrough());
const rum_auto_install = z.boolean();
const rum_zone_tag = z.string();
const rum_create_site_request = z.object({ auto_install: rum_auto_install, host: z.string(), zone_tag: rum_zone_tag }).partial().passthrough();
const rum_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const rum_api_response_common = z.object({ errors: rum_messages, messages: rum_messages, success: z.boolean() }).passthrough();
const rum_api_response_single = rum_api_response_common;
const rum_timestamp = z.string();
const rum_rule_identifier = z.string();
const rum_rule = z.object({ created: rum_timestamp.datetime({ offset: true }), host: z.string(), id: rum_rule_identifier, inclusive: z.boolean(), is_paused: z.boolean(), paths: z.array(z.string()), priority: z.number() }).partial().passthrough();
const rum_rules = z.array(rum_rule);
const rum_ruleset_identifier = z.string();
const rum_ruleset = z.object({ enabled: z.boolean(), id: rum_ruleset_identifier, zone_name: z.string(), zone_tag: rum_zone_tag }).partial().passthrough();
const rum_site_tag = z.string();
const rum_site_token = z.string();
const rum_snippet = z.string();
const rum_site = z.object({ auto_install: rum_auto_install, created: rum_timestamp.datetime({ offset: true }), rules: rum_rules, ruleset: rum_ruleset, site_tag: rum_site_tag, site_token: rum_site_token, snippet: rum_snippet }).partial().passthrough();
const rum_site_response_single = rum_api_response_single.and(z.object({ result: rum_site }).partial().passthrough());
const rum_api_response_common_failure = z.object({ errors: rum_messages, messages: rum_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const rum_api_response_collection = rum_api_response_common;
const rum_result_info = z.object({ count: z.number().int(), page: z.number().int(), per_page: z.number().int(), total_count: z.number().int(), total_pages: z.number().int().nullable() }).partial().passthrough();
const rum_sites_response_collection = rum_api_response_collection.and(z.object({ result: z.array(rum_site), result_info: rum_result_info }).partial().passthrough());
const rum_site_tag_response_single = rum_api_response_single.and(z.object({ result: z.object({ site_tag: rum_site_tag }).partial().passthrough() }).partial().passthrough());
const rum_create_rule_request = z.object({ host: z.string(), inclusive: z.boolean(), is_paused: z.boolean(), paths: z.array(z.string()) }).partial().passthrough();
const rum_rule_response_single = rum_api_response_single.and(z.object({ result: rum_rule }).partial().passthrough());
const rum_rule_id_response_single = rum_api_response_single.and(z.object({ result: z.object({ id: rum_rule_identifier }).partial().passthrough() }).partial().passthrough());
const rum_rules_response_collection = rum_api_response_collection.and(z.object({ result: z.object({ rules: rum_rules, ruleset: rum_ruleset }).partial().passthrough() }).partial().passthrough());
const rum_modify_rules_request = z.object({ delete_rules: z.array(rum_rule_identifier), rules: z.array(z.object({ host: z.string(), id: rum_rule_identifier, inclusive: z.boolean(), is_paused: z.boolean(), paths: z.array(z.string()) }).partial().passthrough()) }).partial().passthrough();
const secondary_dns_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const secondary_dns_api_response_common = z.object({ errors: secondary_dns_messages, messages: secondary_dns_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const secondary_dns_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const secondary_dns_api_response_collection = secondary_dns_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: secondary_dns_result_info }).partial().passthrough());
const secondary_dns_components_schemas_identifier = z.unknown();
const secondary_dns_ip_range = z.string();
const secondary_dns_acl_components_schemas_name = z.string();
const secondary_dns_acl = z.object({ id: secondary_dns_components_schemas_identifier, ip_range: secondary_dns_ip_range, name: secondary_dns_acl_components_schemas_name }).passthrough();
const secondary_dns_components_schemas_response_collection = secondary_dns_api_response_collection.and(z.object({ result: z.array(secondary_dns_acl) }).partial().passthrough());
const secondary_dns_api_response_common_failure = z.object({ errors: secondary_dns_messages, messages: secondary_dns_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const secondary_dns_api_response_single = secondary_dns_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const secondary_dns_components_schemas_single_response = secondary_dns_api_response_single.and(z.object({ result: secondary_dns_acl }).partial().passthrough());
const secondary_dns_components_schemas_id_response = secondary_dns_api_response_single.and(z.object({ result: z.object({ id: secondary_dns_components_schemas_identifier }).partial().passthrough() }).partial().passthrough());
const secondary_dns_ip = z.string();
const secondary_dns_ixfr_enable = z.boolean();
const secondary_dns_components_schemas_name = z.string();
const secondary_dns_port = z.number();
const secondary_dns_tsig_id = z.string();
const secondary_dns_peer = z.object({ id: secondary_dns_components_schemas_identifier, ip: secondary_dns_ip.optional(), ixfr_enable: secondary_dns_ixfr_enable.optional(), name: secondary_dns_components_schemas_name, port: secondary_dns_port.optional(), tsig_id: secondary_dns_tsig_id.optional() }).passthrough();
const secondary_dns_schemas_response_collection = secondary_dns_api_response_collection.and(z.object({ result: z.array(secondary_dns_peer) }).partial().passthrough());
const secondary_dns_schemas_single_response = secondary_dns_api_response_single.and(z.object({ result: secondary_dns_peer }).partial().passthrough());
const secondary_dns_algo = z.string();
const secondary_dns_schemas_identifier = z.unknown();
const secondary_dns_schemas_name = z.string();
const secondary_dns_secret = z.string();
const secondary_dns_tsig = z.object({ algo: secondary_dns_algo, id: secondary_dns_schemas_identifier, name: secondary_dns_schemas_name, secret: secondary_dns_secret }).passthrough();
const secondary_dns_response_collection = secondary_dns_api_response_collection.and(z.object({ result: z.array(secondary_dns_tsig) }).partial().passthrough());
const secondary_dns_single_response = secondary_dns_api_response_single.and(z.object({ result: secondary_dns_tsig }).partial().passthrough());
const secondary_dns_schemas_id_response = secondary_dns_api_response_single.and(z.object({ result: z.object({ id: secondary_dns_schemas_identifier }).partial().passthrough() }).partial().passthrough());
const workers_kv_query = z.object({ dimensions: z.array(z.string()).default("[]"), filters: z.string().default("\"\""), limit: z.number().int().default(10000), metrics: z.array(z.string()), since: z.string().datetime({ offset: true }).default("<6 hours ago>"), sort: z.array(z.unknown()).default("[]"), until: z.string().datetime({ offset: true }).default("<now>") }).partial().passthrough();
const query = workers_kv_query.and(z.object({ dimensions: z.unknown(), filters: z.unknown(), metrics: z.unknown().default("[\"requests\"]"), sort: z.unknown() }).partial().passthrough()).optional();
const workers_kv_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const workers_kv_api_response_common = z.object({ errors: workers_kv_messages, messages: workers_kv_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const workers_kv_api_response_single = workers_kv_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const workers_kv_result = z.object({ data: z.array(z.object({ metrics: z.array(z.unknown()) }).passthrough()).nullable(), data_lag: z.number().gte(0), max: z.unknown(), min: z.unknown(), query: workers_kv_query, rows: z.number().gte(0), totals: z.unknown() }).passthrough();
const workers_kv_schemas_result = workers_kv_result.and(z.object({ data: z.unknown(), max: z.unknown(), min: z.unknown(), query: workers_kv_query, totals: z.unknown() }).partial().passthrough());
const workers_kv_api_response_common_failure = z.object({ errors: workers_kv_messages, messages: workers_kv_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const query__2 = workers_kv_query.and(z.object({ dimensions: z.unknown(), filters: z.unknown(), metrics: z.unknown().default("[\"storedBytes\"]"), sort: z.unknown() }).partial().passthrough()).optional();
const workers_kv_components_schemas_result = workers_kv_result.and(z.object({ data: z.unknown(), max: z.unknown(), min: z.unknown(), query: workers_kv_query, totals: z.unknown() }).partial().passthrough());
const workers_kv_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const workers_kv_api_response_collection = workers_kv_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: workers_kv_result_info }).partial().passthrough());
const workers_kv_namespace_identifier = z.string();
const workers_kv_namespace_title = z.string();
const workers_kv_namespace = z.object({ id: workers_kv_namespace_identifier.max(32), supports_url_encoding: z.boolean().optional(), title: workers_kv_namespace_title }).passthrough();
const workers_kv_create_rename_namespace_body = z.object({ title: workers_kv_namespace_title }).passthrough();
const workers_kv_key_name_bulk = z.string();
const workers_kv_bulk_delete = z.array(workers_kv_key_name_bulk);
const workers_kv_expiration = z.number();
const workers_kv_expiration_ttl = z.number();
const workers_kv_list_metadata = z.object({}).partial().passthrough();
const workers_kv_bulk_write = z.array(z.object({ base64: z.boolean(), expiration: workers_kv_expiration, expiration_ttl: workers_kv_expiration_ttl, key: workers_kv_key_name_bulk.max(512), metadata: workers_kv_list_metadata, value: z.string().max(26214400) }).partial().passthrough());
const workers_kv_key_name = z.string();
const workers_kv_key = z.object({ expiration: z.number().optional(), metadata: workers_kv_list_metadata.optional(), name: workers_kv_key_name.max(512) }).passthrough();
const workers_kv_cursor = z.string();
const workers_kv_value = z.string();
const workers_kv_metadata = z.string();
const workers_kv_namespace_write_key_value_pair_with_metadata_Body = z.object({ metadata: workers_kv_metadata, value: workers_kv_value }).passthrough();
const stream_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const stream_api_response_common = z.object({ errors: stream_messages, messages: stream_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const stream_allowedOrigins = z.array(z.string());
const stream_created = z.string();
const stream_creator = z.string();
const stream_duration = z.number();
const stream_input = z.object({ height: z.number().int(), width: z.number().int() }).partial().passthrough();
const stream_liveInput = z.string();
const stream_maxDurationSeconds = z.number();
const stream_media_metadata = z.object({}).partial().passthrough();
const stream_modified = z.string();
const stream_playback = z.object({ dash: z.string(), hls: z.string() }).partial().passthrough();
const stream_preview = z.string();
const stream_readyToStream = z.boolean();
const stream_readyToStreamAt = z.string();
const stream_requireSignedURLs = z.boolean();
const stream_scheduledDeletion = z.string();
const stream_size = z.number();
const stream_errorReasonCode = z.string();
const stream_errorReasonText = z.string();
const stream_pctComplete = z.string();
const stream_media_state = z.enum(["pendingupload", "downloading", "queued", "inprogress", "ready", "error"]);
const stream_media_status = z.object({ errorReasonCode: stream_errorReasonCode, errorReasonText: stream_errorReasonText, pctComplete: stream_pctComplete, state: stream_media_state }).partial().passthrough();
const stream_thumbnail_url = z.string();
const stream_thumbnailTimestampPct = z.number();
const stream_identifier = z.string();
const stream_oneTimeUploadExpiry = z.string();
const stream_uploaded = z.string();
const stream_watermark_created = z.string();
const stream_downloadedFrom = z.string();
const stream_height = z.number();
const stream_name = z.string();
const stream_opacity = z.number();
const stream_padding = z.number();
const stream_position = z.string();
const stream_scale = z.number();
const stream_watermark_size = z.number();
const stream_watermark_identifier = z.string();
const stream_width = z.number();
const stream_watermarks = z.object({ created: stream_watermark_created.datetime({ offset: true }), downloadedFrom: stream_downloadedFrom, height: stream_height.int(), name: stream_name, opacity: stream_opacity.gte(0).lte(1).default(1), padding: stream_padding.gte(0).lte(1).default(0.05), position: stream_position.default("upperRight"), scale: stream_scale.gte(0).lte(1).default(0.15), size: stream_watermark_size, uid: stream_watermark_identifier.max(32), width: stream_width.int() }).partial().passthrough();
const stream_videos = z.object({ allowedOrigins: stream_allowedOrigins, created: stream_created.datetime({ offset: true }), creator: stream_creator.max(64), duration: stream_duration, input: stream_input, liveInput: stream_liveInput.max(32), maxDurationSeconds: stream_maxDurationSeconds.int().gte(1).lte(21600), meta: stream_media_metadata, modified: stream_modified.datetime({ offset: true }), playback: stream_playback, preview: stream_preview.url(), readyToStream: stream_readyToStream, readyToStreamAt: stream_readyToStreamAt.datetime({ offset: true }), requireSignedURLs: stream_requireSignedURLs, scheduledDeletion: stream_scheduledDeletion.datetime({ offset: true }), size: stream_size, status: stream_media_status, thumbnail: stream_thumbnail_url.url(), thumbnailTimestampPct: stream_thumbnailTimestampPct.gte(0).lte(1), uid: stream_identifier.max(32), uploadExpiry: stream_oneTimeUploadExpiry.datetime({ offset: true }), uploaded: stream_uploaded.datetime({ offset: true }), watermark: stream_watermarks }).partial().passthrough();
const stream_video_response_collection = stream_api_response_common.and(z.object({ result: z.array(stream_videos) }).partial().passthrough()).and(z.object({ range: z.number().int(), total: z.number().int() }).partial().passthrough());
const stream_api_response_common_failure = z.object({ errors: stream_messages, messages: stream_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const stream_clipped_from_video_uid = z.string();
const stream_end_time_seconds = z.number();
const stream_start_time_seconds = z.number();
const stream_watermarkAtUpload = z.object({ uid: z.string().max(32) }).partial().passthrough();
const stream_videoClipStandard = z.object({ allowedOrigins: stream_allowedOrigins.optional(), clippedFromVideoUID: stream_clipped_from_video_uid.max(32), creator: stream_creator.max(64).optional(), endTimeSeconds: stream_end_time_seconds.int(), maxDurationSeconds: stream_maxDurationSeconds.int().gte(1).lte(21600).optional(), requireSignedURLs: stream_requireSignedURLs.optional(), startTimeSeconds: stream_start_time_seconds.int(), thumbnailTimestampPct: stream_thumbnailTimestampPct.gte(0).lte(1).optional(), watermark: stream_watermarkAtUpload.optional() }).passthrough();
const stream_clipping_created = z.string();
const stream_live_input_modified = z.string();
const stream_clipping = z.object({ allowedOrigins: stream_allowedOrigins, clippedFromVideoUID: stream_clipped_from_video_uid.max(32), created: stream_clipping_created.datetime({ offset: true }), creator: stream_creator.max(64), endTimeSeconds: stream_end_time_seconds.int(), maxDurationSeconds: stream_maxDurationSeconds.int().gte(1).lte(21600), meta: stream_media_metadata, modified: stream_live_input_modified.datetime({ offset: true }), playback: stream_playback, preview: stream_preview.url(), requireSignedURLs: stream_requireSignedURLs, startTimeSeconds: stream_start_time_seconds.int(), status: stream_media_state, thumbnailTimestampPct: stream_thumbnailTimestampPct.gte(0).lte(1), watermark: stream_watermarkAtUpload }).partial().passthrough();
const stream_clipResponseSingle = stream_api_response_common.and(z.object({ result: stream_clipping }).partial().passthrough());
const stream_watermark_at_upload = z.object({ uid: z.string().max(32) }).partial().passthrough();
const stream_video_copy_request = z.object({ allowedOrigins: stream_allowedOrigins.optional(), creator: stream_creator.max(64).optional(), meta: stream_media_metadata.optional(), requireSignedURLs: stream_requireSignedURLs.optional(), scheduledDeletion: stream_scheduledDeletion.datetime({ offset: true }).optional(), thumbnailTimestampPct: stream_thumbnailTimestampPct.gte(0).lte(1).optional(), url: z.string().url(), watermark: stream_watermark_at_upload.optional() }).passthrough();
const stream_api_response_single = stream_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const stream_video_response_single = stream_api_response_single.and(z.object({ result: stream_videos }).partial().passthrough());
const stream_direct_upload_request = z.object({ allowedOrigins: stream_allowedOrigins.optional(), creator: stream_creator.max(64).optional(), expiry: z.string().datetime({ offset: true }).optional().default("Now + 30 minutes"), maxDurationSeconds: stream_maxDurationSeconds.int().gte(1).lte(21600), meta: stream_media_metadata.optional(), requireSignedURLs: stream_requireSignedURLs.optional(), scheduledDeletion: stream_scheduledDeletion.datetime({ offset: true }).optional(), thumbnailTimestampPct: stream_thumbnailTimestampPct.gte(0).lte(1).optional(), watermark: stream_watermark_at_upload.optional() }).passthrough();
const stream_direct_upload_response = stream_api_response_single.and(z.object({ result: z.object({ scheduledDeletion: stream_scheduledDeletion.datetime({ offset: true }), uid: stream_identifier.max(32), uploadURL: z.string(), watermark: stream_watermarks }).partial().passthrough() }).partial().passthrough());
const stream_signing_key_created = z.string();
const stream_schemas_identifier = z.string();
const stream_key_response_collection = stream_api_response_common.and(z.object({ result: z.array(z.object({ created: stream_signing_key_created.datetime({ offset: true }), id: stream_schemas_identifier.max(32) }).partial().passthrough()) }).partial().passthrough());
const stream_jwk = z.string();
const stream_pem = z.string();
const stream_keys = z.object({ created: stream_signing_key_created.datetime({ offset: true }), id: stream_schemas_identifier.max(32), jwk: stream_jwk, pem: stream_pem }).partial().passthrough();
const stream_key_generation_response = stream_api_response_common.and(z.object({ result: stream_keys }).partial().passthrough());
const stream_deleted_response = stream_api_response_single.and(z.object({ result: z.string() }).partial().passthrough());
const stream_live_input_created = z.string();
const stream_live_input_recording_deletion = z.number();
const stream_live_input_metadata = z.object({}).partial().passthrough();
const stream_live_input_identifier = z.string();
const stream_live_input_object_without_url = z.object({ created: stream_live_input_created.datetime({ offset: true }), deleteRecordingAfterDays: stream_live_input_recording_deletion.gte(30), meta: stream_live_input_metadata, modified: stream_live_input_modified.datetime({ offset: true }), uid: stream_live_input_identifier.max(32) }).partial().passthrough();
const stream_live_input_response_collection = stream_api_response_common.and(z.object({ result: z.object({ liveInputs: z.array(stream_live_input_object_without_url), range: z.number().int(), total: z.number().int() }).partial().passthrough() }).partial().passthrough());
const stream_live_input_default_creator = z.string();
const stream_live_input_recording_allowedOrigins = z.array(z.string());
const stream_live_input_recording_mode = z.enum(["off", "automatic"]);
const stream_live_input_recording_requireSignedURLs = z.boolean();
const stream_live_input_recording_timeoutSeconds = z.number();
const stream_live_input_recording_settings = z.object({ allowedOrigins: stream_live_input_recording_allowedOrigins, mode: stream_live_input_recording_mode.default("off"), requireSignedURLs: stream_live_input_recording_requireSignedURLs, timeoutSeconds: stream_live_input_recording_timeoutSeconds.int() }).partial().passthrough();
const stream_create_input_request = z.object({ defaultCreator: stream_live_input_default_creator, deleteRecordingAfterDays: stream_live_input_recording_deletion.gte(30), meta: stream_live_input_metadata, recording: stream_live_input_recording_settings }).partial().passthrough();
const stream_input_rtmps_stream_key = z.string();
const stream_input_rtmps_url = z.string();
const stream_input_rtmps = z.object({ streamKey: stream_input_rtmps_stream_key, url: stream_input_rtmps_url }).partial().passthrough();
const stream_playback_rtmps_stream_key = z.string();
const stream_playback_rtmps_url = z.string();
const stream_playback_rtmps = z.object({ streamKey: stream_playback_rtmps_stream_key, url: stream_playback_rtmps_url }).partial().passthrough();
const stream_input_srt_stream_passphrase = z.string();
const stream_input_srt_stream_id = z.string();
const stream_input_srt_url = z.string();
const stream_input_srt = z.object({ passphrase: stream_input_srt_stream_passphrase, streamId: stream_input_srt_stream_id, url: stream_input_srt_url }).partial().passthrough();
const stream_playback_srt_stream_passphrase = z.string();
const stream_playback_srt_stream_id = z.string();
const stream_playback_srt_url = z.string();
const stream_playback_srt = z.object({ passphrase: stream_playback_srt_stream_passphrase, streamId: stream_playback_srt_stream_id, url: stream_playback_srt_url }).partial().passthrough();
const stream_live_input_status = z.enum([null, "connected", "reconnected", "reconnecting", "client_disconnect", "ttl_exceeded", "failed_to_connect", "failed_to_reconnect", "new_configuration_accepted"]);
const stream_input_webrtc_url = z.string();
const stream_input_webrtc = z.object({ url: stream_input_webrtc_url }).partial().passthrough();
const stream_playback_webrtc_url = z.string();
const stream_playback_webrtc = z.object({ url: stream_playback_webrtc_url }).partial().passthrough();
const stream_live_input = z.object({ created: stream_live_input_created.datetime({ offset: true }), deleteRecordingAfterDays: stream_live_input_recording_deletion.gte(30), meta: stream_live_input_metadata, modified: stream_live_input_modified.datetime({ offset: true }), recording: stream_live_input_recording_settings, rtmps: stream_input_rtmps, rtmpsPlayback: stream_playback_rtmps, srt: stream_input_srt, srtPlayback: stream_playback_srt, status: stream_live_input_status.nullable(), uid: stream_live_input_identifier.max(32), webRTC: stream_input_webrtc, webRTCPlayback: stream_playback_webrtc }).partial().passthrough();
const stream_live_input_response_single = stream_api_response_single.and(z.object({ result: stream_live_input }).partial().passthrough());
const stream_update_input_request = z.object({ defaultCreator: stream_live_input_default_creator, deleteRecordingAfterDays: stream_live_input_recording_deletion.gte(30), meta: stream_live_input_metadata, recording: stream_live_input_recording_settings }).partial().passthrough();
const stream_output_enabled = z.boolean();
const stream_output_streamKey = z.string();
const stream_output_identifier = z.string();
const stream_output_url = z.string();
const stream_output = z.object({ enabled: stream_output_enabled.default(true), streamKey: stream_output_streamKey, uid: stream_output_identifier.max(32), url: stream_output_url }).partial().passthrough();
const stream_output_response_collection = stream_api_response_common.and(z.object({ result: z.array(stream_output) }).partial().passthrough());
const stream_create_output_request = z.object({ enabled: stream_output_enabled.optional().default(true), streamKey: stream_output_streamKey, url: stream_output_url }).passthrough();
const stream_output_response_single = stream_api_response_single.and(z.object({ result: stream_output }).partial().passthrough());
const stream_update_output_request = z.object({ enabled: stream_output_enabled.default(true) }).passthrough();
const stream_storage_use_response = stream_api_response_single.and(z.object({ result: z.object({ creator: stream_creator.max(64), totalStorageMinutes: z.number().int(), totalStorageMinutesLimit: z.number().int(), videoCount: z.number().int() }).partial().passthrough() }).partial().passthrough());
const stream_watermark_response_collection = stream_api_response_common.and(z.object({ result: z.array(stream_watermarks) }).partial().passthrough());
const stream_watermark_basic_upload = z.object({ file: z.string(), name: stream_name.optional(), opacity: stream_opacity.gte(0).lte(1).optional().default(1), padding: stream_padding.gte(0).lte(1).optional().default(0.05), position: stream_position.optional().default("upperRight"), scale: stream_scale.gte(0).lte(1).optional().default(0.15) }).passthrough();
const stream_watermark_response_single = stream_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const stream_webhook_response_single = stream_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const stream_notificationUrl = z.string();
const stream_webhook_request = z.object({ notificationUrl: stream_notificationUrl.url() }).passthrough();
const stream_video_update = z.object({ allowedOrigins: stream_allowedOrigins, creator: stream_creator.max(64), maxDurationSeconds: stream_maxDurationSeconds.int().gte(1).lte(21600), meta: stream_media_metadata, requireSignedURLs: stream_requireSignedURLs, scheduledDeletion: stream_scheduledDeletion.datetime({ offset: true }), thumbnailTimestampPct: stream_thumbnailTimestampPct.gte(0).lte(1), uploadExpiry: stream_oneTimeUploadExpiry.datetime({ offset: true }) }).partial().passthrough();
const stream_audio_default = z.boolean();
const stream_audio_label = z.string();
const stream_audio_state = z.enum(["queued", "ready", "error"]);
const stream_additionalAudio = z.object({ default: stream_audio_default, label: stream_audio_label, status: stream_audio_state, uid: stream_identifier.max(32) }).partial().passthrough();
const stream_listAudioTrackResponse = stream_api_response_common.and(z.object({ result: z.array(stream_additionalAudio) }).partial().passthrough());
const stream_copyAudioTrack = z.object({ label: stream_audio_label, url: z.string().url().optional() }).passthrough();
const stream_addAudioTrackResponse = stream_api_response_common.and(z.object({ result: stream_additionalAudio }).partial().passthrough());
const stream_editAudioTrack = z.object({ default: stream_audio_default, label: stream_audio_label }).partial().passthrough();
const stream_label = z.string();
const stream_language = z.string();
const stream_captions = z.object({ label: stream_label, language: stream_language }).partial().passthrough();
const stream_language_response_collection = stream_api_response_common.and(z.object({ result: z.array(stream_captions) }).partial().passthrough());
const stream_caption_basic_upload = z.object({ file: z.string() }).passthrough();
const stream_language_response_single = stream_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const stream_downloads_response = stream_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const stream_accessRules = z.object({ action: z.enum(["allow", "block"]), country: z.array(z.string()), ip: z.array(z.string()), type: z.enum(["any", "ip.src", "ip.geoip.country"]) }).partial().passthrough();
const stream_signed_token_request = z.object({ accessRules: z.array(stream_accessRules), downloadable: z.boolean(), exp: z.number().int(), id: z.string(), nbf: z.number().int(), pem: z.string() }).partial().passthrough();
const stream_signed_token_response = stream_api_response_single.and(z.object({ result: z.object({ token: z.string() }).partial().passthrough() }).partial().passthrough());
const tunnel_comment = z.string();
const tunnel_route_id = z.string();
const tunnel_ip_network = z.string();
const tunnel_route_tunnel_id = z.unknown();
const tunnel_route_tunnel_name = z.unknown();
const tunnel_route_virtual_network_id = z.unknown();
const tunnel_vnet_name = z.string();
const tunnel_teamnet = z.object({ comment: tunnel_comment, created_at: z.unknown(), deleted_at: z.string().datetime({ offset: true }).nullable(), id: tunnel_route_id.max(36), network: tunnel_ip_network, tun_type: tunnel_tunnel_type, tunnel_id: tunnel_route_tunnel_id, tunnel_name: tunnel_route_tunnel_name, virtual_network_id: tunnel_route_virtual_network_id, virtual_network_name: tunnel_vnet_name }).partial().passthrough();
const tunnel_teamnet_response_collection = tunnel_api_response_collection.and(z.object({ result: z.array(tunnel_teamnet) }).partial().passthrough());
const tunnel_route_create_a_tunnel_route_Body = z.object({ comment: tunnel_comment.optional(), ip_network: tunnel_ip_network, tunnel_id: tunnel_tunnel_id.max(36), virtual_network_id: tunnel_route_virtual_network_id.optional() }).passthrough();
const tunnel_route = z.object({ comment: tunnel_comment, created_at: z.unknown(), deleted_at: z.string().datetime({ offset: true }).nullable(), id: tunnel_route_id.max(36), network: tunnel_ip_network, tunnel_id: tunnel_route_tunnel_id, virtual_network_id: tunnel_route_virtual_network_id }).partial().passthrough();
const tunnel_route_response_single = tunnel_api_response_common.and(z.object({ result: tunnel_route }).partial().passthrough());
const tunnel_teamnet_response_single = tunnel_api_response_common.and(z.object({ result: tunnel_teamnet }).partial().passthrough());
const tunnel_route_update_a_tunnel_route_Body = z.object({ comment: tunnel_comment, network: tunnel_ip_network, tun_type: tunnel_tunnel_type, tunnel_id: tunnel_route_tunnel_id, virtual_network_id: tunnel_route_virtual_network_id }).partial().passthrough();
const tunnel_schemas_comment = z.string();
const tunnel_vnet_id = z.string();
const tunnel_is_default_network = z.boolean();
const tunnel_virtual_network = z.object({ comment: tunnel_schemas_comment, created_at: z.unknown(), deleted_at: z.unknown().optional(), id: tunnel_vnet_id.max(36), is_default_network: tunnel_is_default_network, name: tunnel_vnet_name }).passthrough();
const tunnel_vnet_response_collection = tunnel_api_response_collection.and(z.object({ result: z.array(tunnel_virtual_network) }).partial().passthrough());
const tunnel_virtual_network_create_a_virtual_network_Body = z.object({ comment: tunnel_schemas_comment.optional(), is_default: tunnel_is_default_network.optional(), name: tunnel_vnet_name }).passthrough();
const tunnel_vnet_response_single = tunnel_api_response_common.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const tunnel_virtual_network_update_a_virtual_network_Body = z.object({ comment: tunnel_schemas_comment, is_default_network: tunnel_is_default_network, name: tunnel_vnet_name }).partial().passthrough();
const cloudflare_tunnel_create_a_warp_connector_tunnel_Body = z.object({ name: tunnel_tunnel_name }).passthrough();
const workers_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const workers_api_response_common = z.object({ errors: workers_messages, messages: workers_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const workers_account_settings_response = workers_api_response_common.and(z.object({ result: z.object({ default_usage_model: z.unknown(), green_compute: z.unknown() }).partial().passthrough() }).partial().passthrough());
const workers_api_response_common_failure = z.object({ errors: workers_messages, messages: workers_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const workers_deployments_list_response = workers_api_response_common.and(z.object({ result: z.object({ items: z.array(z.unknown()), latest: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const workers_deployments_single_response = workers_api_response_common.and(z.object({ result: z.object({ id: z.string(), metadata: z.object({}).partial().passthrough(), number: z.number(), resources: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const workers_identifier = z.string();
const workers_created_on = z.string();
const workers_modified_on = z.string();
const workers_uuid = z.string();
const workers_dispatch_namespace_name = z.string();
const workers_namespace_response = z.object({ created_by: workers_identifier.max(32), created_on: workers_created_on.datetime({ offset: true }), modified_by: workers_identifier.max(32), modified_on: workers_modified_on.datetime({ offset: true }), namespace_id: workers_uuid.max(36), namespace_name: workers_dispatch_namespace_name.regex(/^.+$/) }).partial().passthrough();
const workers_namespace_list_response = workers_api_response_common.and(z.object({ result: z.array(workers_namespace_response) }).partial().passthrough());
const workers_namespace_single_response = workers_api_response_common.and(z.object({ result: workers_namespace_response }).partial().passthrough());
const workers_namespace_delete_response = workers_api_response_common.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough());
const workers_etag = z.string();
const workers_logpush = z.boolean();
const workers_pipeline_hash = z.string();
const workers_placement_mode = z.string();
const workers_tail_consumers_script = z.object({ environment: z.string().optional(), namespace: z.string().optional(), service: z.string() }).passthrough();
const workers_tail_consumers = z.array(workers_tail_consumers_script);
const workers_usage_model = z.string();
const workers_script_response = z.object({ created_on: workers_created_on.datetime({ offset: true }), etag: workers_etag, id: z.string(), logpush: workers_logpush, modified_on: workers_modified_on.datetime({ offset: true }), pipeline_hash: workers_pipeline_hash, placement_mode: workers_placement_mode, tail_consumers: workers_tail_consumers, usage_model: workers_usage_model.regex(/^(bundled|unbound)$/) }).partial().passthrough();
const workers_namespace_script_response = z.object({ created_on: workers_created_on.datetime({ offset: true }), dispatch_namespace: workers_dispatch_namespace_name.regex(/^.+$/), modified_on: workers_modified_on.datetime({ offset: true }), script: workers_script_response }).partial().passthrough();
const workers_namespace_script_response_single = workers_api_response_common.and(z.object({ result: workers_namespace_script_response }).partial().passthrough());
const workers_migration_tag_conditions = z.object({ new_tag: z.string(), old_tag: z.string() }).partial().passthrough();
const workers_migration_step = z.object({ deleted_classes: z.array(z.string()), new_classes: z.array(z.string()), renamed_classes: z.array(z.object({ from: z.string(), to: z.string() }).partial().passthrough()), transferred_classes: z.array(z.object({ from: z.string(), from_script: z.string(), to: z.string() }).partial().passthrough()) }).partial().passthrough();
const workers_single_step_migrations = workers_migration_tag_conditions.and(workers_migration_step);
const workers_stepped_migrations = workers_migration_tag_conditions.and(z.object({ steps: z.array(workers_migration_step) }).partial().passthrough());
const workers_placement_config = z.object({ mode: z.literal("smart") }).partial().passthrough();
const namespace_worker_script_upload_worker_module_Body = z.union([z.object({ "<any part name>": z.array(z.instanceof(File)), metadata: z.object({ bindings: z.array(z.object({}).partial().passthrough()), body_part: z.string(), compatibility_date: z.string(), compatibility_flags: z.array(z.string()), keep_bindings: z.array(z.string()), logpush: workers_logpush, main_module: z.string(), migrations: z.union([workers_single_step_migrations, workers_stepped_migrations]), placement: workers_placement_config, tags: z.array(z.string()), tail_consumers: workers_tail_consumers, usage_model: z.enum(["bundled", "unbound"]), version_tags: z.object({}).partial().passthrough() }).partial().passthrough() }).partial().passthrough(), z.object({ message: z.string() }).partial().passthrough()]);
const workers_api_response_single = workers_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const workers_script_response_single = workers_api_response_single.and(z.object({ result: workers_script_response }).partial().passthrough());
const workers_binding_name = z.string();
const workers_namespace_identifier = z.string();
const workers_kv_namespace_binding = z.object({ name: workers_binding_name, namespace_id: workers_namespace_identifier.max(32), type: z.literal("kv_namespace") }).passthrough();
const workers_service_binding = z.object({ environment: z.string(), name: workers_binding_name, service: z.string(), type: z.literal("service") }).passthrough();
const workers_do_binding = z.object({ class_name: z.string(), environment: z.string().optional(), name: workers_binding_name, namespace_id: workers_namespace_identifier.max(32).optional(), script_name: z.string().optional(), type: z.literal("durable_object_namespace") }).passthrough();
const workers_r2_binding = z.object({ bucket_name: z.string(), name: workers_binding_name, type: z.literal("r2_bucket") }).passthrough();
const workers_queue_binding = z.object({ name: workers_binding_name, queue_name: z.string(), type: z.literal("queue") }).passthrough();
const workers_d1_binding = z.object({ binding: workers_binding_name, id: z.string(), name: z.string(), type: z.literal("d1") }).passthrough();
const workers_dispatch_namespace_binding = z.object({ name: workers_binding_name, namespace: z.string(), outbound: z.object({ params: z.array(z.string()), worker: z.object({ environment: z.string(), service: z.string() }).partial().passthrough() }).partial().passthrough().optional(), type: z.literal("dispatch_namespace") }).passthrough();
const workers_mtls_cert_binding = z.object({ certificate_id: z.string().optional(), name: workers_binding_name, type: z.literal("mtls_certificate") }).passthrough();
const workers_binding = z.union([workers_kv_namespace_binding, workers_service_binding, workers_do_binding, workers_r2_binding, workers_queue_binding, workers_d1_binding, workers_dispatch_namespace_binding, workers_mtls_cert_binding]);
const namespace_worker_put_script_content_Body = z.object({ "<any part name>": z.array(z.instanceof(File)), metadata: z.object({ body_part: z.string(), main_module: z.string() }).partial().passthrough() }).partial().passthrough();
const workers_bindings = z.array(workers_binding);
const workers_compatibility_date = z.string();
const workers_compatibility_flag = z.string();
const workers_compatibility_flags = z.array(workers_compatibility_flag);
const workers_tag = z.string();
const workers_tags = z.array(workers_tag);
const workers_script_settings_response = workers_api_response_common.and(z.object({ result: z.object({ bindings: workers_bindings, compatibility_date: workers_compatibility_date, compatibility_flags: workers_compatibility_flags, logpush: workers_logpush, migrations: z.union([workers_single_step_migrations, workers_stepped_migrations]), placement: workers_placement_config, tags: workers_tags, tail_consumers: workers_tail_consumers, usage_model: workers_usage_model.regex(/^(bundled|unbound)$/) }).partial().passthrough() }).partial().passthrough());
const workers_schemas_environment = z.string();
const workers_hostname = z.string();
const workers_domain_identifier = z.unknown();
const workers_schemas_service = z.string();
const workers_zone_identifier = z.unknown();
const workers_zone_name = z.string();
const workers_domain = z.object({ environment: workers_schemas_environment, hostname: workers_hostname, id: workers_domain_identifier, service: workers_schemas_service, zone_id: workers_zone_identifier, zone_name: workers_zone_name }).partial().passthrough();
const workers_domain_response_collection = workers_api_response_common.and(z.object({ result: z.array(workers_domain) }).partial().passthrough());
const worker_domain_attach_to_domain_Body = z.object({ environment: workers_schemas_environment, hostname: workers_hostname, service: workers_schemas_service, zone_id: workers_zone_identifier }).passthrough();
const workers_domain_response_single = workers_api_response_common.and(z.object({ result: workers_domain }).partial().passthrough());
const workers_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const workers_api_response_collection = workers_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: workers_result_info }).partial().passthrough());
const workers_namespace = z.object({ class: z.unknown(), id: z.unknown(), name: z.unknown(), script: z.unknown() }).partial().passthrough();
const workers_object = z.object({ hasStoredData: z.boolean(), id: z.string() }).partial().passthrough();
const workers_cursor = z.string();
const workers_name = z.string();
const workers_queue = z.object({ consumers: z.unknown(), consumers_total_count: z.unknown(), created_on: z.unknown(), modified_on: z.unknown(), producers: z.unknown(), producers_total_count: z.unknown(), queue_id: z.unknown(), queue_name: workers_name }).partial().passthrough();
const workers_queue_created = z.object({ created_on: z.unknown(), modified_on: z.unknown(), queue_id: z.unknown(), queue_name: workers_name }).partial().passthrough();
const workers_renamed_name = z.string();
const workers_queue_updated = z.object({ created_on: z.unknown(), modified_on: z.unknown(), queue_id: z.unknown(), queue_name: workers_renamed_name }).partial().passthrough();
const workers_batch_size = z.number();
const workers_max_retries = z.number();
const workers_max_wait_time_ms = z.number();
const workers_consumer = z.object({ created_on: z.unknown(), environment: z.unknown(), queue_name: z.unknown(), service: z.unknown(), settings: z.object({ batch_size: workers_batch_size, max_retries: workers_max_retries, max_wait_time_ms: workers_max_wait_time_ms }).partial().passthrough() }).partial().passthrough();
const workers_dlq_name = z.string();
const workers_consumer_created = z.object({ created_on: z.unknown(), dead_letter_queue: workers_dlq_name, environment: z.unknown(), queue_name: z.unknown(), script_name: z.unknown(), settings: z.object({ batch_size: workers_batch_size, max_retries: workers_max_retries, max_wait_time_ms: workers_max_wait_time_ms }).partial().passthrough() }).partial().passthrough();
const workers_consumer_updated = z.object({ created_on: z.unknown(), dead_letter_queue: z.unknown(), environment: z.unknown(), queue_name: z.unknown(), script_name: z.unknown(), settings: z.object({ batch_size: z.number(), max_retries: workers_max_retries, max_wait_time_ms: workers_max_wait_time_ms }).partial().passthrough() }).partial().passthrough();
const workers_script_response_collection = workers_api_response_common.and(z.object({ result: z.array(workers_script_response) }).partial().passthrough());
const workers_cron_trigger_response_collection = workers_api_response_common.and(z.object({ result: z.object({ schedules: z.array(z.object({ created_on: z.unknown(), cron: z.unknown(), modified_on: z.unknown() }).partial().passthrough()) }).partial().passthrough() }).partial().passthrough());
const worker_script_patch_settings_Body = z.object({ settings: workers_script_settings_response }).partial().passthrough();
const workers_tail_response = workers_api_response_common.and(z.object({ result: z.object({ expires_at: z.unknown(), id: z.unknown(), url: z.unknown() }).partial().passthrough() }).partial().passthrough());
const workers_usage_model_response = workers_api_response_common.and(z.object({ result: z.object({ usage_model: z.unknown() }).partial().passthrough() }).partial().passthrough());
const workers_subdomain_response = workers_api_response_common.and(z.object({ result: z.object({ name: z.unknown() }).partial().passthrough() }).partial().passthrough());
const tunnel_icmp_proxy_enabled = z.boolean();
const tunnel_offramp_warp_enabled = z.boolean();
const tunnel_zero_trust_connectivity_settings_response = tunnel_api_response_common.and(z.object({ result: z.object({ icmp_proxy_enabled: tunnel_icmp_proxy_enabled, offramp_warp_enabled: tunnel_offramp_warp_enabled }).partial().passthrough() }).partial().passthrough());
const zero_trust_accounts_patch_connectivity_settings_Body = z.object({ icmp_proxy_enabled: tunnel_icmp_proxy_enabled, offramp_warp_enabled: tunnel_offramp_warp_enabled }).partial().passthrough();
const access_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const access_api_response_common = z.object({ errors: access_messages, messages: access_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const access_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const access_api_response_collection = access_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: access_result_info }).partial().passthrough());
const access_schemas_aud = z.string();
const access_timestamp = z.string();
const access_uuid = z.string();
const access_basic_app_response_props = z.object({ aud: access_schemas_aud.max(64), created_at: access_timestamp.datetime({ offset: true }), id: access_uuid.max(36), updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_schemas_allow_authenticate_via_warp = z.boolean();
const access_allowed_idps = z.array(z.string());
const access_app_launcher_visible = z.boolean();
const access_schemas_auto_redirect_to_identity = z.boolean();
const access_allow_all_headers = z.boolean();
const access_allow_all_methods = z.boolean();
const access_allow_all_origins = z.boolean();
const access_allow_credentials = z.boolean();
const access_allowed_headers = z.array(z.unknown());
const access_allowed_methods = z.array(z.enum(["GET", "POST", "HEAD", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"]));
const access_allowed_origins = z.array(z.unknown());
const access_max_age = z.number();
const access_cors_headers = z.object({ allow_all_headers: access_allow_all_headers, allow_all_methods: access_allow_all_methods, allow_all_origins: access_allow_all_origins, allow_credentials: access_allow_credentials, allowed_headers: access_allowed_headers, allowed_methods: access_allowed_methods, allowed_origins: access_allowed_origins, max_age: access_max_age.gte(-1).lte(86400) }).partial().passthrough();
const access_custom_deny_message = z.string();
const access_custom_deny_url = z.string();
const access_custom_non_identity_deny_url = z.string();
const access_schemas_custom_pages = z.array(z.string());
const access_domain = z.string();
const access_enable_binding_cookie = z.boolean();
const access_http_only_cookie_attribute = z.boolean();
const access_logo_url = z.string();
const access_apps_components_schemas_name = z.string();
const access_path_cookie_attribute = z.boolean();
const access_same_site_cookie_attribute = z.string();
const access_self_hosted_domains = z.array(z.string());
const access_service_auth_401_redirect = z.boolean();
const access_schemas_session_duration = z.string();
const access_skip_interstitial = z.boolean();
const access_tags = z.array(z.string());
const access_self_hosted_props = z.object({ allow_authenticate_via_warp: access_schemas_allow_authenticate_via_warp.optional(), allowed_idps: access_allowed_idps.optional(), app_launcher_visible: access_app_launcher_visible.optional().default(true), auto_redirect_to_identity: access_schemas_auto_redirect_to_identity.optional(), cors_headers: access_cors_headers.optional(), custom_deny_message: access_custom_deny_message.optional(), custom_deny_url: access_custom_deny_url.optional(), custom_non_identity_deny_url: access_custom_non_identity_deny_url.optional(), custom_pages: access_schemas_custom_pages.optional(), domain: access_domain, enable_binding_cookie: access_enable_binding_cookie.optional(), http_only_cookie_attribute: access_http_only_cookie_attribute.optional().default(true), logo_url: access_logo_url.optional(), name: access_apps_components_schemas_name.optional(), path_cookie_attribute: access_path_cookie_attribute.optional(), same_site_cookie_attribute: access_same_site_cookie_attribute.optional(), self_hosted_domains: access_self_hosted_domains.optional(), service_auth_401_redirect: access_service_auth_401_redirect.optional(), session_duration: access_schemas_session_duration.optional().default("24h"), skip_interstitial: access_skip_interstitial.optional(), tags: access_tags.optional(), type: z.string() }).passthrough();
const access_saml_saas_app = z.object({ auth_type: z.enum(["saml", "oidc"]), consumer_service_url: z.string(), created_at: access_timestamp.datetime({ offset: true }), custom_attributes: z.object({ name: z.string(), name_format: z.enum(["urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri"]), source: z.object({ name: z.string() }).partial().passthrough() }).partial().passthrough(), default_relay_state: z.string(), idp_entity_id: z.string(), name_id_format: z.enum(["id", "email"]), name_id_transform_jsonata: z.string(), public_key: z.string(), sp_entity_id: z.string(), sso_endpoint: z.string(), updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_oidc_saas_app = z.object({ app_launcher_url: z.string(), auth_type: z.enum(["saml", "oidc"]), client_id: z.string(), client_secret: z.string(), created_at: access_timestamp.datetime({ offset: true }), grant_types: z.array(z.enum(["authorization_code", "authorization_code_with_pkce"])), group_filter_regex: z.string(), public_key: z.string(), redirect_uris: z.array(z.string()), scopes: z.array(z.enum(["openid", "groups", "email", "profile"])), updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_saas_props = z.object({ allowed_idps: access_allowed_idps, app_launcher_visible: access_app_launcher_visible.default(true), auto_redirect_to_identity: access_schemas_auto_redirect_to_identity, custom_pages: access_schemas_custom_pages, logo_url: access_logo_url, name: access_apps_components_schemas_name, saas_app: z.union([access_saml_saas_app, access_oidc_saas_app]), tags: access_tags, type: z.string() }).partial().passthrough();
const access_ssh_props = access_self_hosted_props.and(z.object({ type: z.string() }).partial().passthrough());
const access_vnc_props = access_self_hosted_props.and(z.object({ type: z.string() }).partial().passthrough());
const access_type = z.enum(["self_hosted", "saas", "ssh", "vnc", "app_launcher", "warp", "biso", "bookmark", "dash_sso"]);
const access_feature_app_props = z.object({ allowed_idps: access_allowed_idps.optional(), auto_redirect_to_identity: access_schemas_auto_redirect_to_identity.optional(), domain: access_domain.optional(), name: access_apps_components_schemas_name.optional(), session_duration: access_schemas_session_duration.optional().default("24h"), type: access_type }).passthrough();
const access_app_launcher_props = access_feature_app_props.and(z.object({ domain: z.unknown(), name: z.unknown().default("App Launcher"), type: z.string() }).partial().passthrough());
const access_warp_props = access_feature_app_props.and(z.object({ domain: z.unknown(), name: z.unknown().default("Warp Login App"), type: z.string() }).partial().passthrough());
const access_biso_props = access_feature_app_props.and(z.object({ domain: z.unknown(), name: z.unknown().default("Clientless Web Isolation"), type: z.string() }).partial().passthrough());
const access_bookmark_props = z.object({ app_launcher_visible: z.unknown().default(true), domain: z.unknown(), logo_url: access_logo_url, name: access_apps_components_schemas_name, tags: access_tags, type: z.string() }).partial().passthrough();
const access_apps = z.union([access_basic_app_response_props.and(access_self_hosted_props), access_basic_app_response_props.and(access_saas_props), access_basic_app_response_props.and(access_ssh_props), access_basic_app_response_props.and(access_vnc_props), access_basic_app_response_props.and(access_app_launcher_props), access_basic_app_response_props.and(access_warp_props), access_basic_app_response_props.and(access_biso_props), access_basic_app_response_props.and(access_bookmark_props)]);
const access_apps_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_apps) }).partial().passthrough());
const access_api_response_common_failure = z.object({ errors: access_messages, messages: access_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const access_api_response_single = access_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const access_apps_components_schemas_single_response = access_api_response_single.and(z.object({ result: access_apps }).partial().passthrough());
const access_aud = z.string();
const access_id = z.string();
const access_public_key = z.string();
const access_ca = z.object({ aud: access_aud.max(64), id: access_id.max(48), public_key: access_public_key }).partial().passthrough();
const access_ca_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_ca) }).partial().passthrough());
const access_identifier = z.string();
const app_id = z.union([access_identifier, access_uuid]);
const access_id_response = access_api_response_single.and(z.object({ result: z.object({ id: access_uuid.max(36) }).partial().passthrough() }).partial().passthrough());
const access_schemas_empty_response = z.object({ result: z.object({}).partial().passthrough().nullable(), success: z.union([z.literal(true), z.literal(false)]) }).partial().passthrough();
const access_policy_check_response = access_api_response_single.and(z.object({ result: z.object({ app_state: z.object({ app_uid: access_uuid.max(36), aud: z.string(), hostname: z.string(), name: z.string(), policies: z.array(z.unknown()), status: z.string() }).partial().passthrough(), user_identity: z.object({ account_id: z.string(), device_sessions: z.object({}).partial().passthrough(), email: z.string(), geo: z.object({ country: z.string() }).partial().passthrough(), iat: z.number().int(), id: z.string(), is_gateway: z.boolean(), is_warp: z.boolean(), name: z.string(), user_uuid: access_uuid.max(36), version: z.number().int() }).partial().passthrough() }).partial().passthrough() }).partial().passthrough());
const access_approval_group = z.object({ approvals_needed: z.number().gte(0), email_addresses: z.array(z.unknown()).optional(), email_list_uuid: z.string().optional() }).passthrough();
const access_approval_groups = z.array(access_approval_group);
const access_approval_required = z.boolean();
const access_decision = z.enum(["allow", "deny", "non_identity", "bypass"]);
const access_email_rule = z.object({ email: z.object({ email: z.string().email() }).passthrough() }).passthrough();
const access_email_list_rule = z.object({ email_list: z.object({ id: z.string() }).passthrough() }).passthrough();
const access_domain_rule = z.object({ email_domain: z.object({ domain: z.string() }).passthrough() }).passthrough();
const access_everyone_rule = z.object({ everyone: z.object({}).partial().passthrough() }).passthrough();
const access_ip_rule = z.object({ ip: z.object({ ip: z.string() }).passthrough() }).passthrough();
const access_ip_list_rule = z.object({ ip_list: z.object({ id: z.string() }).passthrough() }).passthrough();
const access_certificate_rule = z.object({ certificate: z.object({}).partial().passthrough() }).passthrough();
const access_access_group_rule = z.object({ group: z.object({ id: z.string() }).passthrough() }).passthrough();
const access_azure_group_rule = z.object({ azureAD: z.object({ connection_id: z.string(), id: z.string() }).passthrough() }).passthrough();
const access_github_organization_rule = z.object({ "github-organization": z.object({ connection_id: z.string(), name: z.string() }).passthrough() }).passthrough();
const access_gsuite_group_rule = z.object({ gsuite: z.object({ connection_id: z.string(), email: z.string() }).passthrough() }).passthrough();
const access_okta_group_rule = z.object({ okta: z.object({ connection_id: z.string(), email: z.string() }).passthrough() }).passthrough();
const access_saml_group_rule = z.object({ saml: z.object({ attribute_name: z.string(), attribute_value: z.string() }).passthrough() }).passthrough();
const access_service_token_rule = z.object({ service_token: z.object({ token_id: z.string() }).passthrough() }).passthrough();
const access_any_valid_service_token_rule = z.object({ any_valid_service_token: z.object({}).partial().passthrough() }).passthrough();
const access_external_evaluation_rule = z.object({ external_evaluation: z.object({ evaluate_url: z.string(), keys_url: z.string() }).passthrough() }).passthrough();
const access_country_rule = z.object({ geo: z.object({ country_code: z.string() }).passthrough() }).passthrough();
const access_authentication_method_rule = z.object({ auth_method: z.object({ auth_method: z.string() }).passthrough() }).passthrough();
const access_device_posture_rule = z.object({ device_posture: z.object({ integration_uid: z.string() }).passthrough() }).passthrough();
const access_rule = z.union([access_email_rule, access_email_list_rule, access_domain_rule, access_everyone_rule, access_ip_rule, access_ip_list_rule, access_certificate_rule, access_access_group_rule, access_azure_group_rule, access_github_organization_rule, access_gsuite_group_rule, access_okta_group_rule, access_saml_group_rule, access_service_token_rule, access_any_valid_service_token_rule, access_external_evaluation_rule, access_country_rule, access_authentication_method_rule, access_device_posture_rule]);
const access_schemas_exclude = z.array(access_rule);
const access_include = z.array(access_rule);
const access_isolation_required = z.boolean();
const access_policies_components_schemas_name = z.string();
const access_precedence = z.number();
const access_purpose_justification_prompt = z.string();
const access_purpose_justification_required = z.boolean();
const access_schemas_require = z.array(access_rule);
const access_components_schemas_session_duration = z.string();
const access_policies = z.object({ approval_groups: access_approval_groups, approval_required: access_approval_required, created_at: access_timestamp.datetime({ offset: true }), decision: access_decision, exclude: access_schemas_exclude, id: access_uuid.max(36), include: access_include, isolation_required: access_isolation_required, name: access_policies_components_schemas_name, precedence: access_precedence.int(), purpose_justification_prompt: access_purpose_justification_prompt, purpose_justification_required: access_purpose_justification_required, require: access_schemas_require, session_duration: access_components_schemas_session_duration.default("24h"), updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_policies_components_schemas_single_response = access_api_response_single.and(z.object({ result: access_policies }).partial().passthrough());
const access_schemas_id_response = access_api_response_single.and(z.object({ result: z.object({ id: access_id.max(48) }).partial().passthrough() }).partial().passthrough());
const access_ca_components_schemas_single_response = access_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const access_policies_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_policies) }).partial().passthrough());
const access_associated_hostnames = z.array(z.string());
const access_fingerprint = z.string();
const access_certificates_components_schemas_name = z.string();
const access_certificates = z.object({ associated_hostnames: access_associated_hostnames, created_at: access_timestamp.datetime({ offset: true }), expires_on: access_timestamp.datetime({ offset: true }), fingerprint: access_fingerprint, id: z.unknown(), name: access_certificates_components_schemas_name, updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_certificates_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_certificates) }).partial().passthrough());
const access_certificates_components_schemas_single_response = access_api_response_single.and(z.object({ result: access_certificates }).partial().passthrough());
const access_settings = z.object({ china_network: z.boolean(), client_certificate_forwarding: z.boolean(), hostname: z.string() });
const access_response_collection_hostnames = access_api_response_collection.and(z.object({ result: z.array(access_settings) }).partial().passthrough());
const access_mtls_authentication_update_an_mtls_certificate_settings_Body = z.object({ settings: z.array(access_settings) }).passthrough();
const access_components_schemas_id_response = access_api_response_common.and(z.object({ result: z.object({ id: access_uuid.max(36) }).partial().passthrough() }).partial().passthrough());
const access_app_count = z.number();
const access_custom_pages_components_schemas_name = z.string();
const access_schemas_type = z.enum(["identity_denied", "forbidden"]);
const access_custom_page_without_html = z.object({ app_count: access_app_count.int().optional(), created_at: access_timestamp.datetime({ offset: true }).optional(), name: access_custom_pages_components_schemas_name, type: access_schemas_type, uid: access_uuid.max(36).optional(), updated_at: access_timestamp.datetime({ offset: true }).optional() }).passthrough();
const access_custom_pages_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_custom_page_without_html) }).partial().passthrough());
const access_custom_page = z.object({ app_count: access_app_count.int().optional(), created_at: access_timestamp.datetime({ offset: true }).optional(), custom_html: z.string(), name: access_custom_pages_components_schemas_name, type: access_schemas_type, uid: access_uuid.max(36).optional(), updated_at: access_timestamp.datetime({ offset: true }).optional() }).passthrough();
const access_single_response_without_html = access_api_response_single.and(z.object({ result: access_custom_page_without_html }).partial().passthrough());
const access_custom_pages_components_schemas_single_response = access_api_response_single.and(z.object({ result: access_custom_page }).partial().passthrough());
const access_exclude = z.array(access_rule);
const access_require = z.array(access_rule);
const access_components_schemas_name = z.string();
const access_groups = z.object({ created_at: access_timestamp.datetime({ offset: true }), exclude: access_exclude, id: access_uuid.max(36), include: access_include, is_default: access_require, name: access_components_schemas_name, require: access_require, updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_groups) }).partial().passthrough());
const access_is_default = z.boolean();
const access_components_schemas_single_response = access_api_response_single.and(z.object({ result: access_groups }).partial().passthrough());
const access_schemas_name = z.string();
const access_identity_provider = z.object({ config: z.object({}).partial().passthrough(), id: access_uuid.max(36).optional(), name: access_schemas_name, scim_config: z.object({ enabled: z.boolean(), group_member_deprovision: z.boolean(), seat_deprovision: z.boolean(), secret: z.string(), user_deprovision: z.boolean() }).partial().passthrough().optional(), type: z.enum(["onetimepin", "azureAD", "saml", "centrify", "facebook", "github", "google-apps", "google", "linkedin", "oidc", "okta", "onelogin", "pingone", "yandex"]) }).passthrough();
const access_generic_oauth_config = z.object({ client_id: z.string(), client_secret: z.string() }).partial().passthrough();
const access_custom_claims_support = z.object({ claims: z.array(z.string()), email_claim_name: z.string() }).partial().passthrough();
const access_azureAD = access_identity_provider.and(z.object({ config: access_generic_oauth_config.and(access_custom_claims_support).and(z.object({ conditional_access_enabled: z.boolean(), directory_id: z.string(), support_groups: z.boolean() }).partial().passthrough()) }).partial().passthrough());
const access_centrify = access_identity_provider.and(z.object({ config: access_generic_oauth_config.and(access_custom_claims_support).and(z.object({ centrify_account: z.string(), centrify_app_id: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_facebook = access_identity_provider.and(z.object({ config: access_generic_oauth_config }).partial().passthrough());
const access_github = access_identity_provider.and(z.object({ config: access_generic_oauth_config }).partial().passthrough());
const access_google = access_identity_provider.and(z.object({ config: access_generic_oauth_config.and(access_custom_claims_support) }).partial().passthrough());
const access_google_apps = access_identity_provider.and(z.object({ config: access_generic_oauth_config.and(access_custom_claims_support).and(z.object({ apps_domain: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_linkedin = access_identity_provider.and(z.object({ config: access_generic_oauth_config }).partial().passthrough());
const access_oidc = access_identity_provider.and(z.object({ config: access_generic_oauth_config.and(access_custom_claims_support).and(z.object({ auth_url: z.string(), certs_url: z.string(), scopes: z.array(z.string()), token_url: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_okta = access_identity_provider.and(z.object({ config: access_generic_oauth_config.and(access_custom_claims_support).and(z.object({ authorization_server_id: z.string(), okta_account: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_onelogin = access_identity_provider.and(z.object({ config: access_generic_oauth_config.and(access_custom_claims_support).and(z.object({ onelogin_account: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_pingone = access_identity_provider.and(z.object({ config: access_generic_oauth_config.and(access_custom_claims_support).and(z.object({ ping_env_id: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_saml = access_identity_provider.and(z.object({ config: z.object({ attributes: z.array(z.string()), email_attribute_name: z.string(), header_attributes: z.array(z.object({ attribute_name: z.string(), header_name: z.string() }).partial().passthrough()), idp_public_certs: z.array(z.string()), issuer_url: z.string(), sign_request: z.boolean(), sso_target_url: z.string() }).partial().passthrough() }).partial().passthrough());
const access_yandex = access_identity_provider.and(z.object({ config: access_generic_oauth_config }).partial().passthrough());
const access_response_collection = access_api_response_collection.and(z.object({ result: z.array(z.union([access_azureAD, access_centrify, access_facebook, access_github, access_google, access_google_apps, access_linkedin, access_oidc, access_okta, access_onelogin, access_pingone, access_saml, access_yandex])) }).partial().passthrough());
const access_onetimepin = access_identity_provider.and(z.object({ config: z.object({}).partial().passthrough(), type: z.unknown() }).partial().passthrough());
const access_identity_providers = z.union([access_azureAD, access_centrify, access_facebook, access_github, access_google, access_google_apps, access_linkedin, access_oidc, access_okta, access_onelogin, access_pingone, access_saml, access_yandex, access_onetimepin]);
const access_schemas_single_response = access_api_response_single.and(z.object({ result: access_identity_providers }).partial().passthrough());
const access_days_until_next_rotation = z.number();
const access_key_rotation_interval_days = z.number();
const access_last_key_rotation_at = z.string();
const access_key_config = z.object({ days_until_next_rotation: access_days_until_next_rotation, key_rotation_interval_days: access_key_rotation_interval_days.gte(21).lte(365), last_key_rotation_at: access_last_key_rotation_at.datetime({ offset: true }) }).partial().passthrough();
const access_keys_components_schemas_single_response = access_api_response_single.and(access_key_config);
const access_action = z.string();
const access_allowed = z.boolean();
const access_app_domain = z.string();
const access_app_uid = z.unknown();
const access_connection = z.string();
const access_ip = z.string();
const access_ray_id = z.string();
const access_email = z.string();
const access_access_requests = z.object({ action: access_action, allowed: access_allowed, app_domain: access_app_domain, app_uid: access_app_uid, connection: access_connection, created_at: access_timestamp.datetime({ offset: true }), ip_address: access_ip, ray_id: access_ray_id.max(16), user_email: access_email.email() }).partial().passthrough();
const access_access_requests_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_access_requests) }).partial().passthrough());
const access_allow_authenticate_via_warp = z.boolean();
const access_auth_domain = z.string();
const access_auto_redirect_to_identity = z.boolean();
const access_custom_pages = z.object({ forbidden: z.string(), identity_denied: z.string() }).partial().passthrough();
const access_is_ui_read_only = z.boolean();
const access_login_design = z.object({ background_color: z.string(), footer_text: z.string(), header_text: z.string(), logo_path: z.string(), text_color: z.string() }).partial().passthrough();
const access_name = z.string();
const access_session_duration = z.string();
const access_ui_read_only_toggle_reason = z.string();
const access_user_seat_expiration_inactive_time = z.string();
const access_warp_auth_session_duration = z.string();
const access_organizations = z.object({ allow_authenticate_via_warp: access_allow_authenticate_via_warp, auth_domain: access_auth_domain, auto_redirect_to_identity: access_auto_redirect_to_identity, created_at: access_timestamp.datetime({ offset: true }), custom_pages: access_custom_pages, is_ui_read_only: access_is_ui_read_only, login_design: access_login_design, name: access_name, session_duration: access_session_duration, ui_read_only_toggle_reason: access_ui_read_only_toggle_reason, updated_at: access_timestamp.datetime({ offset: true }), user_seat_expiration_inactive_time: access_user_seat_expiration_inactive_time, warp_auth_session_duration: access_warp_auth_session_duration }).partial().passthrough();
const access_single_response = access_api_response_single.and(z.object({ result: access_organizations }).partial().passthrough());
const access_empty_response = z.object({ result: z.union([z.literal(true), z.literal(false)]), success: z.union([z.literal(true), z.literal(false)]) }).partial().passthrough();
const access_access_seat = z.boolean();
const access_gateway_seat = z.boolean();
const access_seat = z.object({ access_seat: access_access_seat, gateway_seat: access_gateway_seat, seat_uid: access_identifier.max(32) }).passthrough();
const access_seats_definition = z.array(access_seat);
const access_seats = z.object({ access_seat: access_access_seat, created_at: access_timestamp.datetime({ offset: true }), gateway_seat: access_gateway_seat, seat_uid: access_identifier.max(32), updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_seats_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_seats) }).partial().passthrough());
const access_client_id = z.string();
const access_duration = z.string();
const access_service_tokens_components_schemas_name = z.string();
const access_service_tokens = z.object({ client_id: access_client_id, created_at: access_timestamp.datetime({ offset: true }), duration: access_duration, id: z.unknown(), name: access_service_tokens_components_schemas_name, updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_service_tokens) }).partial().passthrough());
const access_client_secret = z.string();
const access_create_response = access_api_response_single.and(z.object({ result: z.object({ client_id: access_client_id, client_secret: access_client_secret, created_at: access_timestamp.datetime({ offset: true }), duration: access_duration, id: z.unknown(), name: access_service_tokens_components_schemas_name, updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough() }).partial().passthrough());
const access_service_tokens_components_schemas_single_response = access_api_response_single.and(z.object({ result: access_service_tokens }).partial().passthrough());
const access_tags_components_schemas_name = z.string();
const access_tag = z.object({ app_count: z.number().int().optional(), created_at: access_timestamp.datetime({ offset: true }).optional(), name: access_tags_components_schemas_name, updated_at: access_timestamp.datetime({ offset: true }).optional() }).passthrough();
const access_tags_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_tag) }).partial().passthrough());
const access_tag_without_app_count = z.object({ created_at: access_timestamp.datetime({ offset: true }).optional(), name: access_tags_components_schemas_name, updated_at: access_timestamp.datetime({ offset: true }).optional() }).passthrough();
const access_tags_components_schemas_single_response = access_api_response_single.and(z.object({ result: access_tag }).partial().passthrough());
const access_name_response = access_api_response_single.and(z.object({ result: z.object({ name: access_tags_components_schemas_name }).partial().passthrough() }).partial().passthrough());
const access_schemas_access_seat = z.boolean();
const access_active_device_count = z.number();
const access_schemas_email = z.string();
const access_schemas_gateway_seat = z.boolean();
const access_last_successful_login = z.string();
const access_users_components_schemas_name = z.string();
const access_seat_uid = z.unknown();
const access_uid = z.unknown();
const access_users = z.object({ access_seat: access_schemas_access_seat, active_device_count: access_active_device_count, created_at: access_timestamp.datetime({ offset: true }), email: access_schemas_email.email(), gateway_seat: access_schemas_gateway_seat, id: access_uuid.max(36), last_successful_login: access_last_successful_login.datetime({ offset: true }), name: access_users_components_schemas_name, seat_uid: access_seat_uid, uid: access_uid, updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_users_components_schemas_response_collection = access_api_response_collection.and(z.object({ result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown() }).partial().passthrough() }).partial().passthrough()).and(z.object({ result: z.array(access_users) }).partial().passthrough());
const access_active_sessions_response = access_api_response_collection.and(z.object({ result: z.array(z.object({ expiration: z.number().int(), metadata: z.object({ apps: z.record(z.object({ hostname: z.string(), name: z.string(), type: z.string(), uid: z.string() }).partial().passthrough()), expires: z.number().int(), iat: z.number().int(), nonce: z.string(), ttl: z.number().int() }).partial().passthrough(), name: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_device_posture_check = z.object({ exists: z.boolean(), path: z.string() }).partial().passthrough();
const access_schemas_device_posture_rule = z.object({ check: access_device_posture_check, data: z.object({}).partial().passthrough(), description: z.string(), error: z.string(), id: z.string(), rule_name: z.string(), success: z.boolean(), timestamp: z.string(), type: z.string() }).partial().passthrough();
const access_device_session = z.object({ last_authenticated: z.number() }).partial().passthrough();
const access_string_key_map_device_session = z.record(access_device_session);
const access_geo = z.object({ country: z.string() }).partial().passthrough();
const access_identity = z.object({ account_id: z.string(), auth_status: z.string(), common_name: z.string(), devicePosture: z.record(access_schemas_device_posture_rule), device_id: z.string(), device_sessions: access_string_key_map_device_session, email: z.string(), geo: access_geo, iat: z.number(), idp: z.object({ id: z.string(), type: z.string() }).partial().passthrough(), ip: z.string(), is_gateway: z.boolean(), is_warp: z.boolean(), mtls_auth: z.object({ auth_status: z.string(), cert_issuer_dn: z.string(), cert_issuer_ski: z.string(), cert_presented: z.boolean(), cert_serial: z.string() }).partial().passthrough(), service_token_id: z.string(), service_token_status: z.boolean(), user_uuid: z.string(), version: z.number() }).partial().passthrough();
const access_active_session_response = access_api_response_single.and(z.object({ result: access_identity.and(z.object({ isActive: z.boolean() }).partial().passthrough()) }).partial().passthrough());
const access_failed_login_response = access_api_response_collection.and(z.object({ result: z.array(z.object({ expiration: z.number().int(), metadata: z.object({}).partial().passthrough() }).partial().passthrough()) }).partial().passthrough());
const access_last_seen_identity_response = access_api_response_single.and(z.object({ result: access_identity }).partial().passthrough());
const tls_certificates_and_hostnames_components_schemas_certificate = z.string();
const tls_certificates_and_hostnames_csr = z.string();
const tls_certificates_and_hostnames_schemas_expires_on = z.string();
const tls_certificates_and_hostnames_hostnames = z.array(z.unknown());
const tls_certificates_and_hostnames_request_type = z.enum(["origin-rsa", "origin-ecc", "keyless-certificate"]);
const tls_certificates_and_hostnames_requested_validity = z.union([z.literal(7), z.literal(30), z.literal(90), z.literal(365), z.literal(730), z.literal(1095), z.literal(5475)]);
const tls_certificates_and_hostnames_certificates = z.object({ certificate: tls_certificates_and_hostnames_components_schemas_certificate.optional(), csr: tls_certificates_and_hostnames_csr, expires_on: tls_certificates_and_hostnames_schemas_expires_on.datetime({ offset: true }).optional(), hostnames: tls_certificates_and_hostnames_hostnames, id: tls_certificates_and_hostnames_identifier.max(32).optional(), request_type: tls_certificates_and_hostnames_request_type, requested_validity: tls_certificates_and_hostnames_requested_validity.default(5475) }).passthrough();
const tls_certificates_and_hostnames_schemas_certificate_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(tls_certificates_and_hostnames_certificates) }).partial().passthrough());
const origin_ca_create_certificate_Body = z.object({ csr: tls_certificates_and_hostnames_csr, hostnames: tls_certificates_and_hostnames_hostnames, request_type: tls_certificates_and_hostnames_request_type, requested_validity: tls_certificates_and_hostnames_requested_validity.default(5475) }).partial().passthrough();
const tls_certificates_and_hostnames_schemas_certificate_response_single = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_certificate_response_single_id = tls_certificates_and_hostnames_schemas_certificate_response_single.and(z.object({ result: z.object({ id: tls_certificates_and_hostnames_identifier.max(32) }).partial().passthrough() }).partial().passthrough());
const addressing_etag = z.string();
const addressing_ipv4_cidrs = z.array(z.string());
const addressing_ipv6_cidrs = z.array(z.string());
const addressing_ips = z.object({ etag: addressing_etag, ipv4_cidrs: addressing_ipv4_cidrs, ipv6_cidrs: addressing_ipv6_cidrs }).partial().passthrough();
const addressing_jdcloud_cidrs = z.array(z.string());
const addressing_ips_jdcloud = z.object({ etag: addressing_etag, ipv4_cidrs: addressing_ipv4_cidrs, ipv6_cidrs: addressing_ipv6_cidrs, jdcloud_cidrs: addressing_jdcloud_cidrs }).partial().passthrough();
const iam_schemas_account = iam_account;
const iam_api_access_enabled = z.boolean();
const iam_roles = z.array(z.string());
const iam_schemas_status = z.enum(["accepted", "pending", "rejected"]);
const iam_membership = z.object({ account: iam_schemas_account, api_access_enabled: iam_api_access_enabled.nullable(), code: iam_code.max(64), id: iam_membership_components_schemas_identifier.max(32), permissions: iam_permissions, roles: iam_roles, status: iam_schemas_status }).partial().passthrough();
const iam_collection_membership_response = iam_api_response_collection.and(z.object({ result: z.array(iam_membership) }).partial().passthrough());
const iam_single_membership_response = iam_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const iam_single_user_response = iam_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const iam_country = z.string();
const iam_telephone = z.string();
const iam_zipcode = z.string();
const legacy_jhs_rule_collection_response = legacy_jhs_api_response_collection.and(z.object({ result: z.array(legacy_jhs_rule) }).partial().passthrough());
const legacy_jhs_rule_single_response = legacy_jhs_api_response_single.and(z.object({ result: legacy_jhs_rule }).partial().passthrough());
const legacy_jhs_rule_single_id_response = legacy_jhs_api_response_single.and(z.object({ result: z.object({ id: legacy_jhs_rule_components_schemas_identifier.max(32) }).partial().passthrough() }).partial().passthrough());
const iam_schemas_expires_on = z.string();
const iam_invite_components_schemas_identifier = z.string();
const iam_invited_by = z.string();
const iam_invited_member_email = z.string();
const iam_invited_on = z.string();
const iam_base = z.object({ expires_on: iam_schemas_expires_on.datetime({ offset: true }).optional(), id: iam_invite_components_schemas_identifier.max(32).optional(), invited_by: iam_invited_by.max(90).optional(), invited_member_email: iam_invited_member_email.max(90).optional(), invited_member_id: z.string().max(32).nullable(), invited_on: iam_invited_on.datetime({ offset: true }).optional(), organization_id: z.string().max(32), organization_name: z.string().max(100).optional(), roles: z.array(iam_schemas_role).optional() }).passthrough();
const iam_user_invite = iam_base.and(z.object({ status: z.unknown() }).partial().passthrough());
const iam_schemas_invite = iam_user_invite;
const iam_schemas_collection_invite_response = iam_api_response_collection.and(z.object({ result: z.array(iam_schemas_invite) }).partial().passthrough());
const iam_single_invite_response = iam_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const load_balancing_analytics = z.object({ id: z.number().int().default(1), origins: z.array(z.unknown()), pool: z.object({}).partial().passthrough(), timestamp: z.string().datetime({ offset: true }) }).partial().passthrough();
const load_balancing_components_schemas_response_collection = load_balancing_api_response_collection.and(z.object({ result: z.array(load_balancing_analytics) }).partial().passthrough());
const iam_schemas_name = z.string();
const iam_components_schemas_status = z.enum(["member", "invited"]);
const iam_organization = z.object({ id: iam_common_components_schemas_identifier.max(32), name: iam_schemas_name.max(100), permissions: iam_schemas_permissions, roles: z.array(z.string()), status: iam_components_schemas_status }).partial().passthrough();
const iam_collection_organization_response = iam_api_response_collection.and(z.object({ result: z.array(iam_organization) }).partial().passthrough());
const iam_single_organization_response = iam_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const bill_subs_api_user_subscription_response_collection = bill_subs_api_api_response_collection.and(z.object({ result: z.array(bill_subs_api_subscription) }).partial().passthrough());
const bill_subs_api_user_subscription_response_single = bill_subs_api_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const iam_cidr_list = z.array(z.string());
const iam_request_ip = z.object({ in: iam_cidr_list, not_in: iam_cidr_list }).partial().passthrough();
const iam_condition = z.object({ request_ip: iam_request_ip }).partial().passthrough();
const iam_expires_on = z.string();
const iam_name = z.string();
const iam_not_before = z.string();
const iam_effect = z.enum(["allow", "deny"]);
const iam_identifier = z.string();
const iam_permission_group = z.object({ id: z.string(), name: z.string().optional() }).passthrough();
const iam_permission_groups = z.array(iam_permission_group);
const iam_resources = z.object({}).partial().passthrough();
const iam_policy_with_permission_groups = z.object({ effect: iam_effect, id: iam_identifier, permission_groups: iam_permission_groups, resources: iam_resources }).passthrough();
const iam_access_policy = iam_policy_with_permission_groups;
const iam_policies = z.array(iam_access_policy);
const iam_create_payload = z.object({ condition: iam_condition.optional(), expires_on: iam_expires_on.datetime({ offset: true }).optional(), name: iam_name.max(120), not_before: iam_not_before.datetime({ offset: true }).optional(), policies: iam_policies }).passthrough();
const iam_value = z.string();
const iam_response_create = iam_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().and(z.object({ value: iam_value.min(40).max(80) }).partial().passthrough()) }).partial().passthrough());
const iam_schemas_response_collection = iam_api_response_collection.and(z.object({ result: z.array(z.object({}).partial().passthrough()) }).partial().passthrough());
const iam_components_schemas_identifier = z.string();
const iam_status = z.enum(["active", "disabled", "expired"]);
const iam_response_single_segment = iam_api_response_single.and(z.object({ result: z.object({ expires_on: iam_expires_on.datetime({ offset: true }).optional(), id: iam_components_schemas_identifier.max(32), not_before: iam_not_before.datetime({ offset: true }).optional(), status: iam_status }).passthrough() }).partial().passthrough());
const iam_issued_on = z.string();
const iam_modified_on = z.string();
const iam_token = z.object({ condition: iam_condition.optional(), expires_on: iam_expires_on.datetime({ offset: true }).optional(), id: iam_components_schemas_identifier.max(32), issued_on: iam_issued_on.datetime({ offset: true }).optional(), modified_on: iam_modified_on.datetime({ offset: true }).optional(), name: iam_name.max(120), not_before: iam_not_before.datetime({ offset: true }).optional(), policies: iam_policies, status: iam_status }).passthrough();
const iam_schemas_token = iam_token;
const iam_response_single_value = iam_api_response_single.and(z.object({ result: iam_value.min(40).max(80) }).partial().passthrough());
const zones_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const zones_api_response_common = z.object({ errors: zones_messages, messages: zones_messages, success: z.boolean() }).passthrough();
const zones_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const zones_identifier = z.string();
const zones_zone = z.object({ account: z.object({ id: zones_identifier.max(32), name: z.string() }).partial().passthrough(), activated_on: z.string().datetime({ offset: true }).nullable(), created_on: z.string().datetime({ offset: true }), development_mode: z.number(), id: zones_identifier.max(32), meta: z.object({ cdn_only: z.boolean(), custom_certificate_quota: z.number().int(), dns_only: z.boolean(), foundation_dns: z.boolean(), page_rule_quota: z.number().int(), phishing_detected: z.boolean(), step: z.number().int() }).partial().passthrough(), modified_on: z.string().datetime({ offset: true }), name: z.string().max(253).regex(/^([a-zA-Z0-9][\-a-zA-Z0-9]*\.)+[\-a-zA-Z0-9]{2,20}$/), original_dnshost: z.string().max(50).nullable(), original_name_servers: z.array(z.string()).nullable(), original_registrar: z.string().nullable(), owner: z.object({ id: zones_identifier.max(32), name: z.string(), type: z.string() }).partial().passthrough(), vanity_name_servers: z.array(z.string()).optional() }).passthrough();
const zones_api_response_common_failure = z.object({ errors: zones_messages, messages: zones_messages, result: z.object({}).partial().passthrough().nullable(), success: z.boolean() }).passthrough();
const zones_name = z.string();
const zones_type = z.enum(["full", "partial", "secondary"]);
const zones_post_Body = z.object({ account: z.object({ id: zones_identifier.max(32) }).partial().passthrough(), name: zones_name.max(253).regex(/^([a-zA-Z0-9][\-a-zA-Z0-9]*\.)+[\-a-zA-Z0-9]{2,20}$/), type: zones_type.optional() }).passthrough();
const access_schemas_custom_deny_url = z.string();
const access_components_schemas_domain = z.string();
const access_schemas_self_hosted_props = z.object({ allowed_idps: access_allowed_idps.optional(), app_launcher_visible: access_app_launcher_visible.optional().default(true), auto_redirect_to_identity: access_schemas_auto_redirect_to_identity.optional(), cors_headers: access_cors_headers.optional(), custom_deny_message: access_custom_deny_message.optional(), custom_deny_url: access_schemas_custom_deny_url.optional(), domain: access_components_schemas_domain, enable_binding_cookie: access_enable_binding_cookie.optional(), http_only_cookie_attribute: access_http_only_cookie_attribute.optional().default(true), logo_url: access_logo_url.optional(), name: access_apps_components_schemas_name.optional(), same_site_cookie_attribute: access_same_site_cookie_attribute.optional(), service_auth_401_redirect: access_service_auth_401_redirect.optional(), session_duration: access_schemas_session_duration.optional().default("24h"), skip_interstitial: access_skip_interstitial.optional(), type: z.string() }).passthrough();
const access_schemas_saml_saas_app = z.object({ auth_type: z.enum(["saml", "oidc"]), consumer_service_url: z.string(), created_at: access_timestamp.datetime({ offset: true }), custom_attributes: z.object({ name: z.string(), name_format: z.enum(["urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri"]), source: z.object({ name: z.string() }).partial().passthrough() }).partial().passthrough(), idp_entity_id: z.string(), name_id_format: z.enum(["id", "email"]), name_id_transform_jsonata: z.string(), public_key: z.string(), sp_entity_id: z.string(), sso_endpoint: z.string(), updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_schemas_saas_props = z.object({ allowed_idps: access_allowed_idps, app_launcher_visible: access_app_launcher_visible.default(true), auto_redirect_to_identity: access_schemas_auto_redirect_to_identity, logo_url: access_logo_url, name: access_apps_components_schemas_name, saas_app: z.union([access_schemas_saml_saas_app, access_oidc_saas_app]), type: z.string() }).partial().passthrough();
const access_schemas_ssh_props = access_schemas_self_hosted_props.and(z.object({ type: z.string() }).partial().passthrough());
const access_schemas_vnc_props = access_schemas_self_hosted_props.and(z.object({ type: z.string() }).partial().passthrough());
const access_schemas_feature_app_props = z.object({ allowed_idps: access_allowed_idps.optional(), auto_redirect_to_identity: access_schemas_auto_redirect_to_identity.optional(), domain: access_components_schemas_domain.optional(), name: access_apps_components_schemas_name.optional(), session_duration: access_schemas_session_duration.optional().default("24h"), type: access_type }).passthrough();
const access_schemas_app_launcher_props = access_schemas_feature_app_props.and(z.object({ domain: z.unknown(), name: z.unknown().default("App Launcher"), type: z.string() }).partial().passthrough());
const access_schemas_warp_props = access_schemas_feature_app_props.and(z.object({ domain: z.unknown(), name: z.unknown().default("Warp Login App"), type: z.string() }).partial().passthrough());
const access_schemas_biso_props = access_schemas_feature_app_props.and(z.object({ domain: z.unknown(), name: z.unknown().default("Clientless Web Isolation"), type: z.string() }).partial().passthrough());
const access_schemas_bookmark_props = z.object({ app_launcher_visible: z.unknown().optional().default(true), domain: z.unknown(), logo_url: access_logo_url.optional(), name: access_apps_components_schemas_name.optional(), type: z.string() }).passthrough();
const access_schemas_apps = z.union([access_basic_app_response_props.and(access_schemas_self_hosted_props), access_basic_app_response_props.and(access_schemas_saas_props), access_basic_app_response_props.and(access_schemas_ssh_props), access_basic_app_response_props.and(access_schemas_vnc_props), access_basic_app_response_props.and(access_schemas_app_launcher_props), access_basic_app_response_props.and(access_schemas_warp_props), access_basic_app_response_props.and(access_schemas_biso_props), access_basic_app_response_props.and(access_schemas_bookmark_props)]);
const access_apps_components_schemas_response_collection_2 = access_api_response_collection.and(z.object({ result: z.array(access_schemas_apps) }).partial().passthrough());
const access_apps_components_schemas_single_response_2 = access_api_response_single.and(z.object({ result: access_schemas_apps }).partial().passthrough());
const access_schemas_isolation_required = z.boolean();
const access_schemas_policies = z.object({ approval_groups: access_approval_groups, approval_required: access_approval_required, created_at: access_timestamp.datetime({ offset: true }), decision: access_decision, exclude: access_schemas_exclude, id: access_uuid.max(36), include: access_include, isolation_required: access_schemas_isolation_required, name: access_policies_components_schemas_name, precedence: access_precedence.int(), purpose_justification_prompt: access_purpose_justification_prompt, purpose_justification_required: access_purpose_justification_required, require: access_schemas_require, updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_policies_components_schemas_single_response_2 = access_api_response_single.and(z.object({ result: access_schemas_policies }).partial().passthrough());
const access_policies_components_schemas_response_collection_2 = access_api_response_collection.and(z.object({ result: z.array(access_schemas_policies) }).partial().passthrough());
const access_schemas_groups = z.object({ created_at: access_timestamp.datetime({ offset: true }), exclude: access_exclude, id: access_uuid.max(36), include: access_include, name: access_components_schemas_name, require: access_require, updated_at: access_timestamp.datetime({ offset: true }) }).partial().passthrough();
const access_groups_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(access_schemas_groups) }).partial().passthrough());
const access_groups_components_schemas_single_response = access_api_response_single.and(z.object({ result: access_schemas_groups }).partial().passthrough());
const access_schemas_identity_provider = z.object({ config: z.object({}).partial().passthrough(), id: access_uuid.max(36).optional(), name: access_schemas_name, scim_config: z.object({ enabled: z.boolean(), group_member_deprovision: z.boolean(), seat_deprovision: z.boolean(), secret: z.string(), user_deprovision: z.boolean() }).partial().passthrough().optional(), type: z.enum(["onetimepin", "azureAD", "saml", "centrify", "facebook", "github", "google-apps", "google", "linkedin", "oidc", "okta", "onelogin", "pingone", "yandex"]) }).passthrough();
const access_schemas_azureAD = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config.and(z.object({ conditional_access_enabled: z.boolean(), directory_id: z.string(), support_groups: z.boolean() }).partial().passthrough()) }).partial().passthrough());
const access_schemas_centrify = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config.and(z.object({ centrify_account: z.string(), centrify_app_id: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_schemas_facebook = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config }).partial().passthrough());
const access_schemas_github = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config }).partial().passthrough());
const access_schemas_google = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config }).partial().passthrough());
const access_schemas_google_apps = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config.and(z.object({ apps_domain: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_schemas_linkedin = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config }).partial().passthrough());
const access_schemas_oidc = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config.and(z.object({ auth_url: z.string(), certs_url: z.string(), claims: z.array(z.string()), scopes: z.array(z.string()), token_url: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_schemas_okta = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config.and(z.object({ okta_account: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_schemas_onelogin = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config.and(z.object({ onelogin_account: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_schemas_pingone = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config.and(z.object({ ping_env_id: z.string() }).partial().passthrough()) }).partial().passthrough());
const access_schemas_saml = access_schemas_identity_provider.and(z.object({ config: z.object({ attributes: z.array(z.string()), email_attribute_name: z.string(), header_attributes: z.array(z.object({ attribute_name: z.string(), header_name: z.string() }).partial().passthrough()), idp_public_certs: z.array(z.string()), issuer_url: z.string(), sign_request: z.boolean(), sso_target_url: z.string() }).partial().passthrough() }).partial().passthrough());
const access_schemas_yandex = access_schemas_identity_provider.and(z.object({ config: access_generic_oauth_config }).partial().passthrough());
const access_schemas_onetimepin = access_schemas_identity_provider.and(z.object({ config: z.object({}).partial().passthrough(), type: z.unknown() }).partial().passthrough());
const access_identity_providers_components_schemas_response_collection = access_api_response_collection.and(z.object({ result: z.array(z.union([access_schemas_azureAD, access_schemas_centrify, access_schemas_facebook, access_schemas_github, access_schemas_google, access_schemas_google_apps, access_schemas_linkedin, access_schemas_oidc, access_schemas_okta, access_schemas_onelogin, access_schemas_pingone, access_schemas_saml, access_schemas_yandex, access_schemas_onetimepin])) }).partial().passthrough());
const access_schemas_identity_providers = z.union([access_schemas_azureAD, access_schemas_centrify, access_schemas_facebook, access_schemas_github, access_schemas_google, access_schemas_google_apps, access_schemas_linkedin, access_schemas_oidc, access_schemas_okta, access_schemas_onelogin, access_schemas_pingone, access_schemas_saml, access_schemas_yandex]);
const access_identity_providers_components_schemas_single_response = access_api_response_single.and(z.object({ result: access_schemas_identity_providers }).partial().passthrough());
const access_schemas_organizations = z.object({ auth_domain: access_auth_domain, created_at: access_timestamp.datetime({ offset: true }), is_ui_read_only: access_is_ui_read_only, login_design: access_login_design, name: access_name, ui_read_only_toggle_reason: access_ui_read_only_toggle_reason, updated_at: access_timestamp.datetime({ offset: true }), user_seat_expiration_inactive_time: access_user_seat_expiration_inactive_time }).partial().passthrough();
const access_organizations_components_schemas_single_response = access_api_response_single.and(z.object({ result: access_schemas_organizations }).partial().passthrough());
const bill_subs_api_zone_subscription_response_single = bill_subs_api_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const bill_subs_api_can_subscribe = z.boolean();
const bill_subs_api_externally_managed = z.boolean();
const bill_subs_api_schemas_frequency = z.enum(["weekly", "monthly", "quarterly", "yearly"]);
const bill_subs_api_is_subscribed = z.boolean();
const bill_subs_api_legacy_discount = z.boolean();
const bill_subs_api_legacy_id = z.string();
const bill_subs_api_schemas_name = z.string();
const bill_subs_api_schemas_price = z.number();
const bill_subs_api_available_rate_plan = z.object({ can_subscribe: bill_subs_api_can_subscribe, currency: bill_subs_api_currency, externally_managed: bill_subs_api_externally_managed, frequency: bill_subs_api_schemas_frequency, id: bill_subs_api_identifier.max(32), is_subscribed: bill_subs_api_is_subscribed, legacy_discount: bill_subs_api_legacy_discount, legacy_id: bill_subs_api_legacy_id, name: bill_subs_api_schemas_name.max(80), price: bill_subs_api_schemas_price }).partial().passthrough();
const bill_subs_api_default = z.number();
const bill_subs_api_components_schemas_name = z.unknown();
const bill_subs_api_unit_price = z.number();
const bill_subs_api_schemas_component_values = z.array(bill_subs_api_component_value);
const bill_subs_api_duration = z.number();
const bill_subs_api_rate_plan_components_schemas_identifier = z.string();
const bill_subs_api_schemas_rate_plan = bill_subs_api_rate_plan;
const bill_subs_api_plan_response_collection = bill_subs_api_api_response_collection.and(z.object({ result: z.array(bill_subs_api_schemas_rate_plan) }).partial().passthrough());
const email_email_setting_created = z.string();
const email_email_setting_enabled = z.union([z.literal(true), z.literal(false)]);
const email_email_setting_identifier = z.string();
const email_email_setting_modified = z.string();
const email_email_setting_name = z.string();
const email_email_setting_skip_wizard = z.union([z.literal(true), z.literal(false)]);
const email_email_setting_status = z.enum(["ready", "unconfigured", "misconfigured", "misconfigured/locked", "unlocked"]);
const email_email_setting_tag = z.string();
const email_email_settings_properties = z.object({ created: email_email_setting_created.datetime({ offset: true }), enabled: email_email_setting_enabled.default(true), id: email_email_setting_identifier.max(32), modified: email_email_setting_modified.datetime({ offset: true }), name: email_email_setting_name, skip_wizard: email_email_setting_skip_wizard.default(true), status: email_email_setting_status, tag: email_email_setting_tag.max(32) }).partial().passthrough();
const email_settings = email_email_settings_properties;
const email_email_settings_response_single = email_api_response_single.and(z.object({ result: email_settings }).partial().passthrough());
const email_dns_record = z.object({ content: z.string(), name: z.string().max(255), priority: z.number().gte(0).lte(65535), ttl: z.union([z.number(), z.literal(1)]), type: z.enum(["A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI"]) }).partial().passthrough();
const email_dns_settings_response_collection = email_api_response_collection.and(z.object({ result: z.array(email_dns_record) }).partial().passthrough());
const email_rule_action = z.object({ type: z.enum(["drop", "forward", "worker"]), value: z.array(z.string()) }).passthrough();
const email_rule_actions = z.array(email_rule_action);
const email_rule_enabled = z.union([z.literal(true), z.literal(false)]);
const email_rule_identifier = z.string();
const email_rule_matcher = z.object({ field: z.literal("to"), type: z.literal("literal"), value: z.string().max(90) }).passthrough();
const email_rule_matchers = z.array(email_rule_matcher);
const email_rule_name = z.string();
const email_rule_priority = z.number();
const email_rule_tag = z.string();
const email_rule_properties = z.object({ actions: email_rule_actions, enabled: email_rule_enabled.default(true), id: email_rule_identifier.max(32), matchers: email_rule_matchers, name: email_rule_name.max(256), priority: email_rule_priority.gte(0), tag: email_rule_tag.max(32) }).partial().passthrough();
const email_rules = email_rule_properties;
const email_rules_response_collection = email_api_response_collection.and(z.object({ result: z.array(email_rules), result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown() }).partial().passthrough() }).partial().passthrough());
const email_create_rule_properties = z.object({ actions: email_rule_actions, enabled: email_rule_enabled.optional().default(true), matchers: email_rule_matchers, name: email_rule_name.max(256).optional(), priority: email_rule_priority.gte(0).optional() }).passthrough();
const email_rule_response_single = email_api_response_single.and(z.object({ result: email_rules }).partial().passthrough());
const email_rule_catchall_action = z.object({ type: z.enum(["drop", "forward", "worker"]), value: z.array(z.string()).optional() }).passthrough();
const email_rule_catchall_actions = z.array(email_rule_catchall_action);
const email_rule_catchall_matcher = z.object({ type: z.literal("all") }).passthrough();
const email_rule_catchall_matchers = z.array(email_rule_catchall_matcher);
const email_catch_all_rule = z.object({ actions: email_rule_catchall_actions, enabled: email_rule_enabled.default(true), id: email_rule_identifier.max(32), matchers: email_rule_catchall_matchers, name: email_rule_name.max(256), tag: email_rule_tag.max(32) }).partial().passthrough();
const email_catch_all_rule_response_single = email_api_response_single.and(z.object({ result: email_catch_all_rule }).partial().passthrough());
const email_update_catch_all_rule_properties = z.object({ actions: email_rule_catchall_actions, enabled: email_rule_enabled.optional().default(true), matchers: email_rule_catchall_matchers, name: email_rule_name.max(256).optional() }).passthrough();
const email_update_rule_properties = z.object({ actions: email_rule_actions, enabled: email_rule_enabled.optional().default(true), matchers: email_rule_matchers, name: email_rule_name.max(256).optional(), priority: email_rule_priority.gte(0).optional() }).passthrough();
const legacy_jhs_filters_components_schemas_id = z.string();
const filters_delete_filters_Body = z.object({ id: legacy_jhs_filters_components_schemas_id.min(32).max(32) }).passthrough();
const legacy_jhs_filters_components_schemas_description = z.string();
const legacy_jhs_expression = z.string();
const legacy_jhs_filters_components_schemas_paused = z.boolean();
const legacy_jhs_schemas_ref = z.string();
const legacy_jhs_filter = z.object({ description: legacy_jhs_filters_components_schemas_description.max(500), expression: legacy_jhs_expression, id: legacy_jhs_filters_components_schemas_id.min(32).max(32), paused: legacy_jhs_filters_components_schemas_paused, ref: legacy_jhs_schemas_ref.max(50) }).partial();
const legacy_jhs_filter_delete_response_collection = legacy_jhs_api_response_collection.and(z.object({ result: z.array(legacy_jhs_filter.and(z.object({}).passthrough())) }).partial().passthrough());
const legacy_jhs_schemas_filter_response_collection = legacy_jhs_api_response_collection.and(z.object({ result: z.array(legacy_jhs_filter.and(z.object({}).passthrough())) }).partial().passthrough());
const legacy_jhs_filter_delete_response_single = legacy_jhs_api_response_single.and(z.object({ result: legacy_jhs_filter.and(z.object({}).passthrough()) }).passthrough());
const legacy_jhs_schemas_filter_response_single = legacy_jhs_api_response_single.and(z.object({ result: z.union([legacy_jhs_filter.and(z.object({}).passthrough()), z.unknown()]) }).passthrough());
const legacy_jhs_schemas_ip_configuration = z.object({ target: z.unknown(), value: z.string() }).partial().passthrough();
const legacy_jhs_schemas_cidr_configuration = z.object({ target: z.unknown(), value: z.string() }).partial().passthrough();
const legacy_jhs_configurations = z.union([legacy_jhs_schemas_ip_configuration, legacy_jhs_schemas_cidr_configuration]);
const legacy_jhs_created_on = z.string();
const legacy_jhs_lockdowns_components_schemas_description = z.string();
const legacy_jhs_lockdowns_components_schemas_id = z.string();
const legacy_jhs_components_schemas_modified_on = z.string();
const legacy_jhs_schemas_paused = z.boolean();
const legacy_jhs_schemas_urls = z.array(z.string());
const legacy_jhs_zonelockdown = z.object({ configurations: legacy_jhs_configurations, created_on: legacy_jhs_created_on.datetime({ offset: true }), description: legacy_jhs_lockdowns_components_schemas_description.max(1024), id: legacy_jhs_lockdowns_components_schemas_id.max(32), modified_on: legacy_jhs_components_schemas_modified_on.datetime({ offset: true }), paused: legacy_jhs_schemas_paused, urls: legacy_jhs_schemas_urls });
const legacy_jhs_zonelockdown_response_collection = legacy_jhs_api_response_collection.and(z.object({ result: z.array(legacy_jhs_zonelockdown) }).passthrough());
const legacy_jhs_zonelockdown_response_single = legacy_jhs_api_response_single.and(z.object({ result: legacy_jhs_zonelockdown }).passthrough());
const legacy_jhs_firewall_rules_components_schemas_id = z.string();
const firewall_rules_delete_firewall_rules_Body = z.object({ id: legacy_jhs_firewall_rules_components_schemas_id.max(32) }).passthrough();
const legacy_jhs_components_schemas_action = z.enum(["block", "challenge", "js_challenge", "managed_challenge", "allow", "log", "bypass"]);
const legacy_jhs_firewall_rules_components_schemas_description = z.string();
const legacy_jhs_components_schemas_paused = z.boolean();
const legacy_jhs_firewall_rules_components_schemas_priority = z.number();
const legacy_jhs_products = z.array(z.enum(["zoneLockdown", "uaBlock", "bic", "hot", "securityLevel", "rateLimit", "waf"]));
const legacy_jhs_ref = z.string();
const legacy_jhs_filter_rule_base = z.object({ action: legacy_jhs_components_schemas_action, description: legacy_jhs_firewall_rules_components_schemas_description.max(500), id: legacy_jhs_firewall_rules_components_schemas_id.max(32), paused: legacy_jhs_components_schemas_paused, priority: legacy_jhs_firewall_rules_components_schemas_priority.gte(0).lte(2147483647), products: legacy_jhs_products, ref: legacy_jhs_ref.max(50) }).partial().passthrough();
const legacy_jhs_deleted = z.boolean();
const legacy_jhs_deleted_filter = z.object({ deleted: legacy_jhs_deleted, id: legacy_jhs_filters_components_schemas_id.min(32).max(32) });
const legacy_jhs_filter_rule_response = legacy_jhs_filter_rule_base.and(z.object({ filter: z.union([legacy_jhs_filter, legacy_jhs_deleted_filter]) }).partial().passthrough());
const legacy_jhs_filter_rules_response_collection_delete = legacy_jhs_api_response_collection.and(z.object({ result: z.array(legacy_jhs_filter_rule_response.and(z.object({}).passthrough())) }).passthrough());
const legacy_jhs_filter_rules_response_collection = legacy_jhs_api_response_collection.and(z.object({ result: z.array(legacy_jhs_filter_rule_response.and(z.object({}).passthrough())) }).passthrough());
const legacy_jhs_delete_filter_if_unused = z.boolean();
const firewall_rules_delete_a_firewall_rule_Body = z.object({ delete_filter_if_unused: legacy_jhs_delete_filter_if_unused }).partial().passthrough();
const legacy_jhs_filter_rules_single_response_delete = legacy_jhs_api_response_single.and(z.object({ result: legacy_jhs_filter_rule_response.and(z.object({}).passthrough()) }).passthrough());
const legacy_jhs_filter_rules_single_response = legacy_jhs_api_response_single.and(z.object({ result: legacy_jhs_filter_rule_response.and(z.object({}).passthrough()) }).passthrough());
const legacy_jhs_components_schemas_configuration = z.object({ target: z.string(), value: z.string() }).partial().passthrough();
const legacy_jhs_ua_rules_components_schemas_description = z.string();
const legacy_jhs_ua_rules_components_schemas_id = z.string();
const legacy_jhs_ua_rules_components_schemas_mode = z.unknown();
const legacy_jhs_firewalluablock = z.object({ configuration: legacy_jhs_components_schemas_configuration, description: legacy_jhs_ua_rules_components_schemas_description.max(1024), id: legacy_jhs_ua_rules_components_schemas_id.max(32), mode: legacy_jhs_ua_rules_components_schemas_mode, paused: legacy_jhs_schemas_paused }).partial().passthrough();
const legacy_jhs_ua_rules = legacy_jhs_firewalluablock;
const legacy_jhs_firewalluablock_response_collection = legacy_jhs_api_response_collection.and(z.object({ result: z.array(legacy_jhs_ua_rules) }).partial().passthrough());
const legacy_jhs_firewalluablock_response_single = legacy_jhs_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const legacy_jhs_overrides_components_schemas_description = z.string();
const legacy_jhs_groups = z.object({}).partial().passthrough();
const legacy_jhs_overrides_components_schemas_id = z.string();
const legacy_jhs_paused = z.boolean();
const legacy_jhs_components_schemas_priority = z.number();
const legacy_jhs_waf_rewrite_action = z.unknown();
const legacy_jhs_rewrite_action = z.object({ block: legacy_jhs_waf_rewrite_action, challenge: z.unknown(), default: z.unknown(), disable: legacy_jhs_waf_rewrite_action, simulate: z.unknown() }).partial().passthrough();
const legacy_jhs_waf_action = z.unknown();
const legacy_jhs_rules = z.record(legacy_jhs_waf_action);
const legacy_jhs_urls = z.array(z.string());
const legacy_jhs_override = z.object({ description: legacy_jhs_overrides_components_schemas_description.max(1024).nullable(), groups: legacy_jhs_groups, id: legacy_jhs_overrides_components_schemas_id.max(32), paused: legacy_jhs_paused, priority: legacy_jhs_components_schemas_priority.gte(-1000000000).lte(1000000000), rewrite_action: legacy_jhs_rewrite_action, rules: legacy_jhs_rules, urls: legacy_jhs_urls }).partial().passthrough();
const legacy_jhs_override_response_collection = legacy_jhs_api_response_collection.and(z.object({ result: z.array(legacy_jhs_override.and(z.object({}).passthrough())) }).passthrough());
const legacy_jhs_override_response_single = legacy_jhs_api_response_single.and(z.object({ result: legacy_jhs_override }).passthrough());
const legacy_jhs_package_components_schemas_description = z.string();
const legacy_jhs_detection_mode = z.enum(["anomaly", "traditional"]);
const legacy_jhs_package_components_schemas_identifier = z.string();
const legacy_jhs_package_components_schemas_name = z.string();
const legacy_jhs_package_components_schemas_status = z.literal("active");
const legacy_jhs_package_definition = z.object({ description: legacy_jhs_package_components_schemas_description, detection_mode: legacy_jhs_detection_mode, id: legacy_jhs_package_components_schemas_identifier.max(32), name: legacy_jhs_package_components_schemas_name, status: legacy_jhs_package_components_schemas_status.optional().default("active"), zone_id: legacy_jhs_common_components_schemas_identifier.max(32) }).passthrough();
const legacy_jhs_action_mode = z.enum(["simulate", "block", "challenge"]);
const legacy_jhs_anomaly_description = z.string();
const legacy_jhs_anomaly_detection_mode = z.string();
const legacy_jhs_anomaly_name = z.string();
const legacy_jhs_sensitivity = z.enum(["high", "medium", "low", "off"]);
const legacy_jhs_anomaly_package = legacy_jhs_package_definition.and(z.object({ action_mode: legacy_jhs_action_mode.default("challenge"), description: legacy_jhs_anomaly_description, detection_mode: legacy_jhs_anomaly_detection_mode, name: legacy_jhs_anomaly_name, sensitivity: legacy_jhs_sensitivity.default("high") }).partial().passthrough());
const legacy_jhs_package = z.union([legacy_jhs_package_definition, legacy_jhs_anomaly_package]);
const legacy_jhs_package_response_collection = z.union([legacy_jhs_api_response_collection, z.object({ result: z.array(legacy_jhs_package) }).partial().passthrough()]);
const legacy_jhs_package_response_single = z.union([legacy_jhs_api_response_single, z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough()]);
const waf_packages_update_a_waf_package_Body = z.object({ action_mode: legacy_jhs_action_mode.default("challenge"), sensitivity: legacy_jhs_sensitivity.default("high") }).partial().passthrough();
const healthchecks_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const healthchecks_api_response_common = z.object({ errors: healthchecks_messages, messages: healthchecks_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const healthchecks_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const healthchecks_api_response_collection = healthchecks_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: healthchecks_result_info }).partial().passthrough());
const healthchecks_address = z.string();
const healthchecks_check_regions = z.array(z.enum(["WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "IN", "SEAS", "NEAS", "ALL_REGIONS"]));
const healthchecks_consecutive_fails = z.number();
const healthchecks_consecutive_successes = z.number();
const healthchecks_timestamp = z.string();
const healthchecks_description = z.string();
const healthchecks_failure_reason = z.string();
const healthchecks_http_config = z.object({ allow_insecure: z.boolean(), expected_body: z.string(), expected_codes: z.array(z.string()).nullable().default("200"), follow_redirects: z.boolean(), header: z.object({}).partial().passthrough().nullable(), method: z.enum(["GET", "HEAD"]).default("GET"), path: z.string().default("/"), port: z.number().int().default(80) }).partial().passthrough();
const healthchecks_identifier = z.string();
const healthchecks_interval = z.number();
const healthchecks_name = z.string();
const healthchecks_retries = z.number();
const healthchecks_status = z.enum(["unknown", "healthy", "unhealthy", "suspended"]);
const healthchecks_suspended = z.boolean();
const healthchecks_tcp_config = z.object({ method: z.literal("connection_established").default("connection_established"), port: z.number().int().default(80) }).partial().passthrough();
const healthchecks_timeout = z.number();
const healthchecks_type = z.string();
const healthchecks_healthchecks = z.object({ address: healthchecks_address, check_regions: healthchecks_check_regions.nullable(), consecutive_fails: healthchecks_consecutive_fails.int().default(1), consecutive_successes: healthchecks_consecutive_successes.int().default(1), created_on: healthchecks_timestamp.datetime({ offset: true }), description: healthchecks_description, failure_reason: healthchecks_failure_reason, http_config: healthchecks_http_config.nullable(), id: healthchecks_identifier.max(32), interval: healthchecks_interval.int().default(60), modified_on: healthchecks_timestamp.datetime({ offset: true }), name: healthchecks_name, retries: healthchecks_retries.int().default(2), status: healthchecks_status, suspended: healthchecks_suspended, tcp_config: healthchecks_tcp_config.nullable(), timeout: healthchecks_timeout.int().default(5), type: healthchecks_type.default("HTTP") }).partial().passthrough();
const healthchecks_response_collection = healthchecks_api_response_collection.and(z.object({ result: z.array(healthchecks_healthchecks) }).partial().passthrough());
const healthchecks_api_response_common_failure = z.object({ errors: healthchecks_messages, messages: healthchecks_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const healthchecks_query_healthcheck = z.object({ address: healthchecks_address, check_regions: healthchecks_check_regions.nullish(), consecutive_fails: healthchecks_consecutive_fails.int().optional().default(1), consecutive_successes: healthchecks_consecutive_successes.int().optional().default(1), description: healthchecks_description.optional(), http_config: healthchecks_http_config.nullish(), interval: healthchecks_interval.int().optional().default(60), name: healthchecks_name, retries: healthchecks_retries.int().optional().default(2), suspended: healthchecks_suspended.optional(), tcp_config: healthchecks_tcp_config.nullish(), timeout: healthchecks_timeout.int().optional().default(5), type: healthchecks_type.optional().default("HTTP") }).passthrough();
const healthchecks_api_response_single = healthchecks_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const healthchecks_single_response = healthchecks_api_response_single.and(z.object({ result: healthchecks_healthchecks }).partial().passthrough());
const healthchecks_id_response = healthchecks_api_response_single.and(z.object({ result: z.object({ id: healthchecks_identifier.max(32) }).partial().passthrough() }).partial().passthrough());
const data_zone_analytics_api_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const data_zone_analytics_api_api_response_common = z.object({ errors: data_zone_analytics_api_messages, messages: data_zone_analytics_api_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const data_zone_analytics_api_api_response_single = data_zone_analytics_api_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const data_zone_analytics_api_flag_response = data_zone_analytics_api_api_response_single.and(z.object({ result: z.object({ flag: z.boolean() }).partial().passthrough() }).partial().passthrough());
const data_zone_analytics_api_api_response_common_failure = z.object({ errors: data_zone_analytics_api_messages, messages: data_zone_analytics_api_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const data_zone_analytics_api_flag = z.boolean();
const logs_received_update_log_retention_flag_Body = z.object({ flag: data_zone_analytics_api_flag }).passthrough();
const data_zone_analytics_api_logs = z.union([z.string(), z.object({}).partial().passthrough()]);
const end = z.union([z.string(), z.number()]);
const start = z.union([z.string(), z.number()]).optional();
const data_zone_analytics_api_fields_response = z.object({ key: z.string() }).partial().passthrough();
const legacy_jhs_mode = z.enum(["simulate", "ban", "challenge", "js_challenge", "managed_challenge"]);
const legacy_jhs_body = z.string();
const legacy_jhs_content_type = z.string();
const legacy_jhs_custom_response = z.object({ body: legacy_jhs_body.max(10240), content_type: legacy_jhs_content_type.max(50) }).partial().passthrough();
const legacy_jhs_timeout = z.number();
const legacy_jhs_schemas_action = z.object({ mode: legacy_jhs_mode, response: legacy_jhs_custom_response, timeout: legacy_jhs_timeout.gte(1).lte(86400) }).partial().passthrough();
const legacy_jhs_bypass = z.array(z.object({ name: z.literal("url"), value: z.string() }).partial().passthrough());
const legacy_jhs_components_schemas_description = z.string();
const legacy_jhs_disabled = z.boolean();
const legacy_jhs_rate_limits_components_schemas_id = z.string();
const legacy_jhs_header_name = z.string();
const legacy_jhs_header_op = z.enum(["eq", "ne"]);
const legacy_jhs_header_value = z.string();
const legacy_jhs_methods = z.array(z.enum(["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "_ALL_"]));
const legacy_jhs_schemes = z.array(z.string());
const legacy_jhs_schemas_url = z.string();
const legacy_jhs_origin_traffic = z.boolean();
const legacy_jhs_match = z.object({ headers: z.array(z.object({ name: legacy_jhs_header_name, op: legacy_jhs_header_op, value: legacy_jhs_header_value }).partial().passthrough()), request: z.object({ methods: legacy_jhs_methods, schemes: legacy_jhs_schemes, url: legacy_jhs_schemas_url.max(1024) }).partial().passthrough(), response: z.object({ origin_traffic: legacy_jhs_origin_traffic }).partial().passthrough() }).partial().passthrough();
const legacy_jhs_period = z.number();
const legacy_jhs_threshold = z.number();
const legacy_jhs_ratelimit = z.object({ action: legacy_jhs_schemas_action, bypass: legacy_jhs_bypass, description: legacy_jhs_components_schemas_description.max(1024), disabled: legacy_jhs_disabled, id: legacy_jhs_rate_limits_components_schemas_id.max(32), match: legacy_jhs_match, period: legacy_jhs_period.gte(10).lte(86400), threshold: legacy_jhs_threshold.gte(1) }).partial().passthrough();
const legacy_jhs_rate_limits = legacy_jhs_ratelimit;
const legacy_jhs_ratelimit_response_collection = legacy_jhs_api_response_collection.and(z.object({ result: z.array(legacy_jhs_rate_limits) }).partial().passthrough());
const legacy_jhs_ratelimit_response_single = legacy_jhs_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const snippets_api_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const snippets_api_api_response_common = z.object({ errors: snippets_api_messages, messages: snippets_api_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const snippets_api_snippet_name = z.string();
const snippets_api_snippet = z.object({ created_on: z.string(), modified_on: z.string(), snippet_name: snippets_api_snippet_name.regex(/^[A-Za-z0-9_]+$/) }).partial().passthrough();
const snippets_api_api_response_common_failure = z.object({ errors: snippets_api_messages, messages: snippets_api_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const snippets_api_rules = z.array(z.object({ description: z.string(), enabled: z.boolean(), expression: z.string(), snippet_name: snippets_api_snippet_name.regex(/^[A-Za-z0-9_]+$/) }).partial().passthrough());
const zone_snippets_snippet_rules_put_Body = z.object({ rules: snippets_api_rules }).partial().passthrough();
const zone_snippets_snippet_put_Body = z.object({ files: z.string(), metadata: z.object({ main_module: z.string() }).partial().passthrough() }).partial().passthrough();
const legacy_jhs_id = z.string();
const legacy_jhs_timestamp = z.string();
const legacy_jhs_ssl_recommender_components_schemas_value = z.enum(["flexible", "full", "strict"]);
const waitingroom_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const waitingroom_schemas_api_response_common = z.object({ errors: waitingroom_messages, messages: waitingroom_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const waitingroom_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const waitingroom_api_response_collection = waitingroom_schemas_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: waitingroom_result_info }).partial().passthrough());
const waitingroom_additional_routes = z.array(z.object({ host: z.string(), path: z.string().default("/") }).partial().passthrough());
const waitingroom_cookie_attributes = z.object({ samesite: z.enum(["auto", "lax", "none", "strict"]).default("auto"), secure: z.enum(["auto", "always", "never"]).default("auto") }).partial().passthrough();
const waitingroom_cookie_suffix = z.string();
const waitingroom_timestamp = z.string();
const waitingroom_custom_page_html = z.string();
const waitingroom_default_template_language = z.enum(["en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR"]);
const waitingroom_description = z.string();
const waitingroom_disable_session_renewal = z.boolean();
const waitingroom_host = z.string();
const waitingroom_waiting_room_id = z.unknown();
const waitingroom_json_response_enabled = z.boolean();
const waitingroom_name = z.string();
const waitingroom_new_users_per_minute = z.number();
const waitingroom_next_event_prequeue_start_time = z.string();
const waitingroom_next_event_start_time = z.string();
const waitingroom_path = z.string();
const waitingroom_queue_all = z.boolean();
const waitingroom_queueing_method = z.enum(["fifo", "random", "passthrough", "reject"]);
const waitingroom_queueing_status_code = z.union([z.literal(200), z.literal(202), z.literal(429)]);
const waitingroom_session_duration = z.number();
const waitingroom_suspended = z.boolean();
const waitingroom_total_active_users = z.number();
const waitingroom_waitingroom = z.object({ additional_routes: waitingroom_additional_routes, cookie_attributes: waitingroom_cookie_attributes, cookie_suffix: waitingroom_cookie_suffix, created_on: waitingroom_timestamp.datetime({ offset: true }), custom_page_html: waitingroom_custom_page_html, default_template_language: waitingroom_default_template_language.default("en-US"), description: waitingroom_description, disable_session_renewal: waitingroom_disable_session_renewal, host: waitingroom_host, id: waitingroom_waiting_room_id, json_response_enabled: waitingroom_json_response_enabled, modified_on: waitingroom_timestamp.datetime({ offset: true }), name: waitingroom_name, new_users_per_minute: waitingroom_new_users_per_minute.int().gte(200).lte(2147483647), next_event_prequeue_start_time: waitingroom_next_event_prequeue_start_time.nullable(), next_event_start_time: waitingroom_next_event_start_time.nullable(), path: waitingroom_path.default("/"), queue_all: waitingroom_queue_all, queueing_method: waitingroom_queueing_method.default("fifo"), queueing_status_code: waitingroom_queueing_status_code.default(200), session_duration: waitingroom_session_duration.int().gte(1).lte(30).default(5), suspended: waitingroom_suspended, total_active_users: waitingroom_total_active_users.int().gte(200).lte(2147483647) }).partial().passthrough();
const waitingroom_response_collection = waitingroom_api_response_collection.and(z.object({ result: z.array(waitingroom_waitingroom) }).partial().passthrough());
const waitingroom_api_response_common_failure = z.object({ errors: waitingroom_messages, messages: waitingroom_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const waitingroom_query_waitingroom = z.object({ additional_routes: waitingroom_additional_routes.optional(), cookie_attributes: waitingroom_cookie_attributes.optional(), cookie_suffix: waitingroom_cookie_suffix.optional(), custom_page_html: waitingroom_custom_page_html.optional(), default_template_language: waitingroom_default_template_language.optional().default("en-US"), description: waitingroom_description.optional(), disable_session_renewal: waitingroom_disable_session_renewal.optional(), host: waitingroom_host, json_response_enabled: waitingroom_json_response_enabled.optional(), name: waitingroom_name, new_users_per_minute: waitingroom_new_users_per_minute.int().gte(200).lte(2147483647), path: waitingroom_path.optional().default("/"), queue_all: waitingroom_queue_all.optional(), queueing_method: waitingroom_queueing_method.optional().default("fifo"), queueing_status_code: waitingroom_queueing_status_code.optional().default(200), session_duration: waitingroom_session_duration.int().gte(1).lte(30).optional().default(5), suspended: waitingroom_suspended.optional(), total_active_users: waitingroom_total_active_users.int().gte(200).lte(2147483647) }).passthrough();
const waitingroom_api_response_common = z.object({}).passthrough();
const waitingroom_api_response_single = waitingroom_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const waitingroom_single_response = waitingroom_api_response_single.and(z.object({ result: waitingroom_waitingroom }).partial().passthrough());
const waitingroom_query_preview = z.object({ custom_html: waitingroom_custom_page_html }).passthrough();
const waitingroom_preview_url = z.string();
const waitingroom_preview_response = waitingroom_api_response_single.and(z.object({ result: z.object({ preview_url: waitingroom_preview_url }).partial().passthrough() }).partial().passthrough());
const waitingroom_search_engine_crawler_bypass = z.boolean();
const waitingroom_zone_settings_response = waitingroom_api_response_single.and(z.object({ result: z.object({ search_engine_crawler_bypass: waitingroom_search_engine_crawler_bypass }).passthrough() }).passthrough());
const waitingroom_zone_settings = z.object({ search_engine_crawler_bypass: waitingroom_search_engine_crawler_bypass }).partial().passthrough();
const waitingroom_waiting_room_id_response = waitingroom_api_response_single.and(z.object({ result: z.object({ id: waitingroom_waiting_room_id }).partial().passthrough() }).partial().passthrough());
const waitingroom_event_custom_page_html = z.string();
const waitingroom_event_description = z.string();
const waitingroom_event_disable_session_renewal = z.boolean();
const waitingroom_event_end_time = z.string();
const waitingroom_event_start_time = z.string();
const waitingroom_event_id = z.unknown();
const waitingroom_event_name = z.string();
const waitingroom_event_new_users_per_minute = z.number();
const waitingroom_event_prequeue_start_time = z.string();
const waitingroom_event_queueing_method = z.string();
const waitingroom_event_session_duration = z.number();
const waitingroom_event_shuffle_at_event_start = z.boolean();
const waitingroom_event_suspended = z.boolean();
const waitingroom_event_total_active_users = z.number();
const waitingroom_event_result = z.object({ created_on: waitingroom_timestamp.datetime({ offset: true }), custom_page_html: waitingroom_event_custom_page_html.nullable(), description: waitingroom_event_description, disable_session_renewal: waitingroom_event_disable_session_renewal.nullable(), event_end_time: waitingroom_event_end_time, event_start_time: waitingroom_event_start_time, id: waitingroom_event_id, modified_on: waitingroom_timestamp.datetime({ offset: true }), name: waitingroom_event_name, new_users_per_minute: waitingroom_event_new_users_per_minute.int().gte(200).lte(2147483647).nullable(), prequeue_start_time: waitingroom_event_prequeue_start_time.nullable(), queueing_method: waitingroom_event_queueing_method.nullable(), session_duration: waitingroom_event_session_duration.int().gte(1).lte(30).nullable(), shuffle_at_event_start: waitingroom_event_shuffle_at_event_start, suspended: waitingroom_event_suspended, total_active_users: waitingroom_event_total_active_users.int().gte(200).lte(2147483647).nullable() }).partial().passthrough();
const waitingroom_event_response_collection = waitingroom_api_response_collection.and(z.object({ result: z.array(waitingroom_event_result) }).partial().passthrough());
const waitingroom_query_event = z.object({ custom_page_html: waitingroom_event_custom_page_html.nullish(), description: waitingroom_event_description.optional(), disable_session_renewal: waitingroom_event_disable_session_renewal.nullish(), event_end_time: waitingroom_event_end_time, event_start_time: waitingroom_event_start_time, name: waitingroom_event_name, new_users_per_minute: waitingroom_event_new_users_per_minute.int().gte(200).lte(2147483647).nullish(), prequeue_start_time: waitingroom_event_prequeue_start_time.nullish(), queueing_method: waitingroom_event_queueing_method.nullish(), session_duration: waitingroom_event_session_duration.int().gte(1).lte(30).nullish(), shuffle_at_event_start: waitingroom_event_shuffle_at_event_start.optional(), suspended: waitingroom_event_suspended.optional(), total_active_users: waitingroom_event_total_active_users.int().gte(200).lte(2147483647).nullish() }).passthrough();
const waitingroom_event_response = waitingroom_api_response_single.and(z.object({ result: waitingroom_event_result }).partial().passthrough());
const waitingroom_event_id_response = waitingroom_api_response_single.and(z.object({ result: z.object({ id: waitingroom_event_id }).partial().passthrough() }).partial().passthrough());
const waitingroom_event_details_custom_page_html = z.string();
const waitingroom_event_details_disable_session_renewal = z.boolean();
const waitingroom_event_details_new_users_per_minute = z.number();
const waitingroom_event_details_queueing_method = z.string();
const waitingroom_event_details_session_duration = z.number();
const waitingroom_event_details_total_active_users = z.number();
const waitingroom_event_details_result = z.object({ created_on: waitingroom_timestamp.datetime({ offset: true }), custom_page_html: waitingroom_event_details_custom_page_html, description: waitingroom_event_description, disable_session_renewal: waitingroom_event_details_disable_session_renewal, event_end_time: waitingroom_event_end_time, event_start_time: waitingroom_event_start_time, id: waitingroom_event_id, modified_on: waitingroom_timestamp.datetime({ offset: true }), name: waitingroom_event_name, new_users_per_minute: waitingroom_event_details_new_users_per_minute.int(), prequeue_start_time: waitingroom_event_prequeue_start_time.nullable(), queueing_method: waitingroom_event_details_queueing_method, session_duration: waitingroom_event_details_session_duration.int(), shuffle_at_event_start: waitingroom_event_shuffle_at_event_start, suspended: waitingroom_event_suspended, total_active_users: waitingroom_event_details_total_active_users.int() }).partial().passthrough();
const waitingroom_event_details_response = waitingroom_api_response_single.and(z.object({ result: waitingroom_event_details_result }).partial().passthrough());
const waitingroom_rule_action = z.literal("bypass_waiting_room");
const waitingroom_rule_description = z.string();
const waitingroom_rule_enabled = z.boolean();
const waitingroom_rule_expression = z.string();
const waitingroom_rule_id = z.string();
const waitingroom_rule_version = z.string();
const waitingroom_rule_result = z.object({ action: waitingroom_rule_action, description: waitingroom_rule_description, enabled: waitingroom_rule_enabled.default(true), expression: waitingroom_rule_expression, id: waitingroom_rule_id, last_updated: waitingroom_timestamp.datetime({ offset: true }), version: waitingroom_rule_version }).partial().passthrough();
const waitingroom_rules_response_collection = waitingroom_api_response_collection.and(z.object({ result: z.array(waitingroom_rule_result) }).partial().passthrough());
const waitingroom_create_rule = z.object({ action: waitingroom_rule_action, description: waitingroom_rule_description.optional(), enabled: waitingroom_rule_enabled.optional().default(true), expression: waitingroom_rule_expression }).passthrough();
const waitingroom_update_rules = z.array(waitingroom_create_rule);
const waitingroom_rule_position = z.union([z.object({ index: z.number().int() }).partial().passthrough(), z.object({ before: z.string() }).partial().passthrough(), z.object({ after: z.string() }).partial().passthrough()]);
const waitingroom_patch_rule = z.object({ action: waitingroom_rule_action, description: waitingroom_rule_description.optional(), enabled: waitingroom_rule_enabled.optional().default(true), expression: waitingroom_rule_expression, position: waitingroom_rule_position.optional() }).passthrough();
const waitingroom_estimated_queued_users = z.number();
const waitingroom_estimated_total_active_users = z.number();
const waitingroom_status_event_id = z.string();
const waitingroom_max_estimated_time_minutes = z.number();
const waitingroom_status = z.enum(["event_prequeueing", "not_queueing", "queueing"]);
const waitingroom_status_response = waitingroom_api_response_single.and(z.object({ result: z.object({ estimated_queued_users: waitingroom_estimated_queued_users.int(), estimated_total_active_users: waitingroom_estimated_total_active_users.int(), event_id: waitingroom_status_event_id, max_estimated_time_minutes: waitingroom_max_estimated_time_minutes.int(), status: waitingroom_status }).partial().passthrough() }).partial().passthrough());
const dweb_config_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const dweb_config_api_response_common = z.object({ errors: dweb_config_messages, messages: dweb_config_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const dweb_config_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const dweb_config_api_response_collection = dweb_config_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: dweb_config_result_info }).partial().passthrough());
const dweb_config_timestamp = z.string();
const dweb_config_description = z.string();
const dweb_config_dnslink = z.string();
const dweb_config_identifier = z.string();
const dweb_config_name = z.string();
const dweb_config_status = z.enum(["active", "pending", "deleting", "error"]);
const dweb_config_target = z.enum(["ethereum", "ipfs", "ipfs_universal_path"]);
const dweb_config_web3_hostname = z.object({ created_on: dweb_config_timestamp.datetime({ offset: true }), description: dweb_config_description.max(500), dnslink: dweb_config_dnslink, id: dweb_config_identifier.max(32), modified_on: dweb_config_timestamp.datetime({ offset: true }), name: dweb_config_name.max(255), status: dweb_config_status, target: dweb_config_target }).partial().passthrough();
const dweb_config_collection_response = dweb_config_api_response_collection.and(z.object({ result: z.array(dweb_config_web3_hostname) }).partial().passthrough());
const dweb_config_api_response_common_failure = z.object({ errors: dweb_config_messages, messages: dweb_config_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const dweb_config_create_request = z.object({ description: dweb_config_description.max(500).optional(), dnslink: dweb_config_dnslink.optional(), name: dweb_config_name.max(255), target: dweb_config_target }).passthrough();
const dweb_config_api_response_single = dweb_config_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const dweb_config_single_response = dweb_config_api_response_single.and(z.object({ result: dweb_config_web3_hostname }).partial().passthrough());
const dweb_config_api_response_single_id = dweb_config_api_response_common.and(z.object({ result: z.object({ id: dweb_config_identifier.max(32) }).passthrough().nullable() }).partial().passthrough());
const dweb_config_modify_request = z.object({ description: dweb_config_description.max(500), dnslink: dweb_config_dnslink }).partial().passthrough();
const dweb_config_content_list_action = z.literal("block");
const dweb_config_content_list_details = z.object({ action: dweb_config_content_list_action }).partial().passthrough();
const dweb_config_content_list_details_response = dweb_config_api_response_single.and(z.object({ result: dweb_config_content_list_details }).partial().passthrough());
const dweb_config_content_list_entry_content = z.string();
const dweb_config_content_list_entry_description = z.string();
const dweb_config_content_list_entry_type = z.enum(["cid", "content_path"]);
const dweb_config_content_list_entry = z.object({ content: dweb_config_content_list_entry_content.max(500), created_on: dweb_config_timestamp.datetime({ offset: true }), description: dweb_config_content_list_entry_description.max(500), id: dweb_config_identifier.max(32), modified_on: dweb_config_timestamp.datetime({ offset: true }), type: dweb_config_content_list_entry_type }).partial().passthrough();
const dweb_config_content_list_entries = z.array(dweb_config_content_list_entry);
const dweb_config_content_list_update_request = z.object({ action: dweb_config_content_list_action, entries: dweb_config_content_list_entries }).passthrough();
const dweb_config_content_list_entry_collection_response = dweb_config_api_response_collection.and(z.object({ result: z.object({ entries: dweb_config_content_list_entries }).partial().passthrough() }).partial().passthrough());
const dweb_config_content_list_entry_create_request = z.object({ content: dweb_config_content_list_entry_content.max(500), description: dweb_config_content_list_entry_description.max(500).optional(), type: dweb_config_content_list_entry_type }).passthrough();
const dweb_config_content_list_entry_single_response = dweb_config_api_response_single.and(z.object({ result: dweb_config_content_list_entry }).partial().passthrough());
const zones_api_response_single_id = zones_api_response_common.and(z.object({ result: z.object({ id: zones_identifier.max(32) }).passthrough().nullable() }).partial().passthrough());
const zones_paused = z.boolean();
const zones_vanity_name_servers = z.array(z.string());
const zones_0_patch_Body = z.object({ paused: zones_paused, plan: z.object({ id: zones_identifier.max(32) }).partial().passthrough(), type: z.enum(["full", "partial", "secondary"]), vanity_name_servers: zones_vanity_name_servers }).partial().passthrough();
const tls_certificates_and_hostnames_components_schemas_certificate_authority = z.enum(["google", "lets_encrypt"]);
const tls_certificates_and_hostnames_components_schemas_enabled = z.boolean();
const tls_certificates_and_hostnames_schemas_validity_days = z.literal(90);
const tls_certificates_and_hostnames_total_tls_settings_response = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({ certificate_authority: tls_certificates_and_hostnames_components_schemas_certificate_authority, enabled: tls_certificates_and_hostnames_components_schemas_enabled, validity_days: tls_certificates_and_hostnames_schemas_validity_days }).partial().passthrough() }).partial().passthrough());
const zone_activation_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const zone_activation_api_response_common = z.object({ errors: zone_activation_messages, messages: zone_activation_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const zone_activation_api_response_single = zone_activation_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const zone_activation_identifier = z.string();
const zone_activation_api_response_common_failure = z.object({ errors: zone_activation_messages, messages: zone_activation_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const argo_analytics_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const argo_analytics_api_response_common = z.object({ errors: argo_analytics_messages, messages: argo_analytics_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const argo_analytics_api_response_single = argo_analytics_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const argo_analytics_response_single = argo_analytics_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const argo_analytics_api_response_common_failure = z.object({ errors: argo_analytics_messages, messages: argo_analytics_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const api_shield_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const api_shield_api_response_common = z.object({ errors: api_shield_messages, messages: api_shield_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.boolean() }).passthrough();
const api_shield_api_response_single = api_shield_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const api_shield_name = z.string();
const api_shield_type = z.enum(["header", "cookie"]);
const api_shield_characteristics = z.array(z.object({ name: api_shield_name.max(128), type: api_shield_type }).passthrough());
const api_shield_configuration = z.object({ auth_id_characteristics: api_shield_characteristics.max(10) }).partial().passthrough();
const api_shield_single_response = api_shield_api_response_single.and(z.object({ result: api_shield_configuration }).partial().passthrough());
const api_shield_api_response_common_failure = z.object({ errors: api_shield_messages, messages: api_shield_messages, result: z.object({}).partial().passthrough().nullable(), success: z.boolean() }).passthrough();
const api_shield_default_response = api_shield_api_response_single;
const api_shield_openapi = z.object({}).partial().passthrough();
const api_shield_timestamp = z.string();
const api_shield_schema_response_discovery = api_shield_api_response_single.and(z.object({ result: z.object({ schemas: z.array(api_shield_openapi), timestamp: api_shield_timestamp.datetime({ offset: true }) }).partial().passthrough() }).partial().passthrough());
const api_shield_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const api_shield_api_response_collection = api_shield_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: api_shield_result_info }).partial().passthrough());
const api_shield_traffic_stats = z.object({ traffic_stats: z.object({ last_updated: api_shield_timestamp.datetime({ offset: true }), period_seconds: z.number().int(), requests: z.number() }).passthrough() }).partial().passthrough();
const api_shield_uuid = z.string();
const api_shield_api_discovery_origin = z.enum(["ML", "SessionIdentifier"]);
const api_shield_api_discovery_state = z.enum(["review", "saved", "ignored"]);
const api_shield_endpoint = z.string();
const api_shield_host = z.string();
const api_shield_method = z.enum(["GET", "POST", "HEAD", "OPTIONS", "PUT", "DELETE", "CONNECT", "PATCH", "TRACE"]);
const api_shield_basic_operation = z.object({ endpoint: api_shield_endpoint.max(4096).regex(/^/.* $ /), host: api_shield_host.max(255).url(), method: api_shield_method }).passthrough();
const api_shield_discovery_operation = z.object({ features: api_shield_traffic_stats.optional(), id: api_shield_uuid.max(36).uuid(), last_updated: api_shield_timestamp.datetime({ offset: true }), origin: z.array(api_shield_api_discovery_origin), state: api_shield_api_discovery_state }).passthrough().and(api_shield_basic_operation);
const api_shield_api_discovery_state_patch = z.enum(["review", "ignored"]);
const api_shield_api_discovery_patch_multiple_request_entry = z.object({ operation_id: api_shield_uuid.max(36).uuid(), state: api_shield_api_discovery_state_patch }).partial().passthrough();
const api_shield_api_discovery_patch_multiple_request = z.record(api_shield_api_discovery_patch_multiple_request_entry);
const api_shield_patch_discoveries_response = api_shield_api_response_single.and(z.object({ result: api_shield_api_discovery_patch_multiple_request }).partial().passthrough());
const api_shield_api_patch_discovered_operation_Body = z.object({ state: api_shield_api_discovery_state_patch }).partial().passthrough();
const api_shield_patch_discovery_response = api_shield_api_response_single.and(z.object({ result: z.object({ state: api_shield_api_discovery_state }).partial().passthrough() }).partial().passthrough());
const api_shield_auth_id_tokens = z.number();
const api_shield_data_points = z.number();
const api_shield_p50 = z.number();
const api_shield_p90 = z.number();
const api_shield_p99 = z.number();
const api_shield_period_seconds = z.number();
const api_shield_requests = z.number();
const api_shield_suggested_threshold = z.number();
const api_shield_operation_feature_thresholds = z.object({ thresholds: z.object({ auth_id_tokens: api_shield_auth_id_tokens.int(), data_points: api_shield_data_points.int(), last_updated: api_shield_timestamp.datetime({ offset: true }), p50: api_shield_p50.int(), p90: api_shield_p90.int(), p99: api_shield_p99.int(), period_seconds: api_shield_period_seconds.int(), requests: api_shield_requests.int(), suggested_threshold: api_shield_suggested_threshold.int() }).partial().passthrough().optional() }).passthrough();
const api_shield_parameter_schemas_definition = z.object({ parameters: z.array(z.unknown()), responses: z.object({}).partial().passthrough().nullable() }).partial().passthrough();
const api_shield_operation_feature_parameter_schemas = z.object({ parameter_schemas: z.object({ last_updated: api_shield_timestamp.datetime({ offset: true }), parameter_schemas: api_shield_parameter_schemas_definition }).partial().passthrough() }).passthrough();
const api_shield_operation_features = z.union([api_shield_operation_feature_thresholds, api_shield_operation_feature_parameter_schemas]);
const api_shield_operation = api_shield_basic_operation.and(z.object({ features: api_shield_operation_features.optional(), last_updated: api_shield_timestamp.datetime({ offset: true }), operation_id: api_shield_uuid.max(36).uuid() }).passthrough());
const api_shield_api_shield = api_shield_operation;
const api_shield_collection_response_paginated = api_shield_api_response_collection.and(z.object({ result: z.array(api_shield_api_shield) }).partial().passthrough());
const api_shield_collection_response = api_shield_api_response_collection.and(z.object({ result: z.array(api_shield_api_shield.and(z.object({ features: z.unknown() }).partial().passthrough())) }).partial().passthrough());
const api_shield_operation_mitigation_action = z.enum(["log", "block", "none", null]);
const api_shield_operation_schema_validation_settings_multiple_request_entry = z.object({ mitigation_action: api_shield_operation_mitigation_action.nullable() }).partial().passthrough();
const api_shield_operation_schema_validation_settings_multiple_request = z.record(api_shield_operation_schema_validation_settings_multiple_request_entry);
const api_shield_schemas_single_response = api_shield_api_response_single.and(z.object({ result: api_shield_api_shield }).partial().passthrough());
const api_shield_operation_schema_validation_settings = z.object({ mitigation_action: api_shield_operation_mitigation_action.nullable() }).partial().passthrough();
const api_shield_openapiwiththresholds = z.object({}).partial().passthrough();
const api_shield_schema_response_with_thresholds = api_shield_default_response.and(z.object({ result: z.object({ schemas: z.array(api_shield_openapiwiththresholds), timestamp: z.string() }).partial().passthrough() }).partial().passthrough());
const api_shield_validation_default_mitigation_action = z.enum(["none", "log", "block"]);
const api_shield_validation_override_mitigation_action = z.enum(["none", null]);
const api_shield_zone_schema_validation_settings = z.object({ validation_default_mitigation_action: api_shield_validation_default_mitigation_action, validation_override_mitigation_action: api_shield_validation_override_mitigation_action.nullable() }).partial().passthrough();
const api_shield_validation_default_mitigation_action_patch = z.enum(["none", "log", "block", null]);
const api_shield_validation_override_mitigation_action_patch = z.enum(["none", "disable_override", null]);
const api_shield_zone_schema_validation_settings_patch = z.object({ validation_default_mitigation_action: api_shield_validation_default_mitigation_action_patch.nullable(), validation_override_mitigation_action: api_shield_validation_override_mitigation_action_patch.nullable() }).partial().passthrough();
const api_shield_validation_override_mitigation_action_write = z.enum(["none", "disable_override", null]);
const api_shield_zone_schema_validation_settings_put = z.object({ validation_default_mitigation_action: api_shield_validation_default_mitigation_action, validation_override_mitigation_action: api_shield_validation_override_mitigation_action_write.nullish() }).passthrough();
const api_shield_kind = z.literal("openapi_v3");
const api_shield_validation_enabled = z.boolean();
const api_shield_public_schema = z.object({ created_at: api_shield_timestamp.datetime({ offset: true }), kind: api_shield_kind, name: z.string(), schema_id: api_shield_uuid.max(36).uuid(), source: z.string().optional(), validation_enabled: api_shield_validation_enabled.optional() }).passthrough();
const api_shield_schema_validation_post_schema_Body = z.object({ file: z.instanceof(File), kind: api_shield_kind, name: z.string().optional(), validation_enabled: z.enum(["true", "false"]).optional() }).passthrough();
const api_shield_schema_upload_log_event = z.object({ code: z.number().int(), locations: z.array(z.string()).optional(), message: z.string().optional() }).passthrough();
const api_shield_schema_upload_details_warnings_only = z.object({ warnings: z.array(api_shield_schema_upload_log_event) }).partial().passthrough();
const api_shield_schema_upload_response = z.object({ schema: api_shield_public_schema, upload_details: api_shield_schema_upload_details_warnings_only.optional() }).passthrough();
const api_shield_schema_upload_details_errors_critical = z.object({ critical: z.array(api_shield_schema_upload_log_event), errors: z.array(api_shield_schema_upload_log_event) }).partial().passthrough();
const api_shield_schema_upload_failure = z.object({ upload_details: api_shield_schema_upload_details_errors_critical }).partial().passthrough().and(api_shield_api_response_common_failure);
const api_shield_schema_validation_enable_validation_for_a_schema_Body = z.object({ validation_enabled: api_shield_validation_enabled.and(z.unknown()) }).partial().passthrough();
const argo_config_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const argo_config_api_response_common = z.object({ errors: argo_config_messages, messages: argo_config_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const argo_config_api_response_single = argo_config_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const argo_config_response_single = argo_config_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const argo_config_api_response_common_failure = z.object({ errors: argo_config_messages, messages: argo_config_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const argo_config_value = z.enum(["on", "off"]);
const argo_config_patch = z.object({ value: argo_config_value }).passthrough();
const cache_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const cache_api_response_common = z.object({ errors: cache_messages, messages: cache_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const cache_api_response_single = cache_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const cache_response_single = cache_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const cache_api_response_common_failure = z.object({ errors: cache_messages, messages: cache_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const cache_value = z.enum(["on", "off"]);
const cache_patch = z.object({ value: cache_value }).passthrough();
const bot_management_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const bot_management_api_response_common = z.object({ errors: bot_management_messages, messages: bot_management_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const bot_management_api_response_single = bot_management_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const bot_management_enable_js = z.boolean();
const bot_management_using_latest_model = z.boolean();
const bot_management_base_config = z.object({ enable_js: bot_management_enable_js, using_latest_model: bot_management_using_latest_model }).partial().passthrough();
const bot_management_fight_mode = z.boolean();
const bot_management_bot_fight_mode_config = bot_management_base_config.and(z.object({ fight_mode: bot_management_fight_mode }).partial().passthrough());
const bot_management_optimize_wordpress = z.boolean();
const bot_management_sbfm_definitely_automated = z.enum(["allow", "block", "managed_challenge"]);
const bot_management_sbfm_static_resource_protection = z.boolean();
const bot_management_sbfm_verified_bots = z.enum(["allow", "block"]);
const bot_management_sbfm_definitely_config = bot_management_base_config.and(z.object({ optimize_wordpress: bot_management_optimize_wordpress, sbfm_definitely_automated: bot_management_sbfm_definitely_automated, sbfm_static_resource_protection: bot_management_sbfm_static_resource_protection, sbfm_verified_bots: bot_management_sbfm_verified_bots }).partial().passthrough());
const bot_management_sbfm_likely_automated = z.enum(["allow", "block", "managed_challenge"]);
const bot_management_sbfm_likely_config = bot_management_sbfm_definitely_config.and(z.object({ sbfm_likely_automated: bot_management_sbfm_likely_automated }).partial().passthrough());
const bot_management_auto_update_model = z.boolean();
const bot_management_suppress_session_score = z.boolean();
const bot_management_bm_subscription_config = bot_management_base_config.and(z.object({ auto_update_model: bot_management_auto_update_model, suppress_session_score: bot_management_suppress_session_score }).partial().passthrough());
const bot_management_bot_management_response_body = bot_management_api_response_single.and(z.object({ result: z.union([bot_management_bot_fight_mode_config, bot_management_sbfm_definitely_config, bot_management_sbfm_likely_config, bot_management_bm_subscription_config]) }).partial().passthrough());
const bot_management_api_response_common_failure = z.object({ errors: bot_management_messages, messages: bot_management_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const bot_management_config_single = z.union([bot_management_bot_fight_mode_config, bot_management_sbfm_definitely_config, bot_management_sbfm_likely_config, bot_management_bm_subscription_config]);
const cache_zone_cache_settings_response_single = cache_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const cache_base = z.object({ id: z.string(), modified_on: z.string().datetime({ offset: true }).nullable() }).passthrough();
const cache_cache_reserve = cache_base.and(z.object({ id: z.unknown() }).partial().passthrough());
const cache_cache_reserve_value = z.enum(["on", "off"]);
const cache_cache_reserve_response_value = z.object({ result: cache_cache_reserve.and(z.object({ value: cache_cache_reserve_value.default("off") }).passthrough()) }).partial().passthrough();
const cache_cache_reserve_clear = cache_base.and(z.object({ id: z.unknown() }).partial().passthrough());
const cache_cache_reserve_clear_end_ts = z.string();
const cache_cache_reserve_clear_start_ts = z.string();
const cache_cache_reserve_clear_state = z.enum(["In-progress", "Completed"]);
const cache_cache_reserve_clear_response_value = z.object({ result: cache_cache_reserve_clear.and(z.object({ end_ts: cache_cache_reserve_clear_end_ts.datetime({ offset: true }).optional(), start_ts: cache_cache_reserve_clear_start_ts.datetime({ offset: true }), state: cache_cache_reserve_clear_state }).passthrough()) }).partial().passthrough();
const cache_origin_post_quantum_encryption_value = z.enum(["preferred", "supported", "off"]);
const cache_regional_tiered_cache = cache_base.and(z.object({ id: z.unknown() }).partial().passthrough());
const cache_regional_tiered_cache_response_value = z.object({ result: cache_regional_tiered_cache.and(z.object({ value: cache_regional_tiered_cache }).passthrough()) }).partial().passthrough();
const cache_regional_tiered_cache_value = z.enum(["on", "off"]);
const cache_schemas_value = z.enum(["on", "off"]);
const cache_schemas_patch = z.object({ value: cache_schemas_value }).passthrough();
const cache_variants = cache_base.and(z.object({ id: z.unknown() }).partial().passthrough());
const cache_variants_value = z.object({ avif: z.array(z.unknown()), bmp: z.array(z.unknown()), gif: z.array(z.unknown()), jp2: z.array(z.unknown()), jpeg: z.array(z.unknown()), jpg: z.array(z.unknown()), jpg2: z.array(z.unknown()), png: z.array(z.unknown()), tif: z.array(z.unknown()), tiff: z.array(z.unknown()), webp: z.array(z.unknown()) }).partial().passthrough();
const cache_variants_response_value = z.object({ result: cache_variants.and(z.object({ value: cache_variants_value }).passthrough()) }).partial().passthrough();
const tls_certificates_and_hostnames_hostname_association = z.object({ hostnames: z.array(z.string()), mtls_certificate_id: z.string().min(36).max(36) }).partial().passthrough();
const tls_certificates_and_hostnames_hostname_associations_response = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_hostname_association }).partial().passthrough());
const tls_certificates_and_hostnames_client_certificates_components_schemas_certificate = z.string();
const tls_certificates_and_hostnames_client_certificates_components_schemas_certificate_authority = z.object({ id: z.string(), name: z.string() }).partial().passthrough();
const tls_certificates_and_hostnames_common_name = z.string();
const tls_certificates_and_hostnames_country = z.string();
const tls_certificates_and_hostnames_schemas_csr = z.string();
const tls_certificates_and_hostnames_expired_on = z.string();
const tls_certificates_and_hostnames_fingerprint_sha256 = z.string();
const tls_certificates_and_hostnames_issued_on = z.string();
const tls_certificates_and_hostnames_location = z.string();
const tls_certificates_and_hostnames_organization = z.string();
const tls_certificates_and_hostnames_organizational_unit = z.string();
const tls_certificates_and_hostnames_components_schemas_serial_number = z.string();
const tls_certificates_and_hostnames_components_schemas_signature = z.string();
const tls_certificates_and_hostnames_ski = z.string();
const tls_certificates_and_hostnames_state = z.string();
const tls_certificates_and_hostnames_client_certificates_components_schemas_status = z.unknown();
const tls_certificates_and_hostnames_components_schemas_validity_days = z.number();
const tls_certificates_and_hostnames_client_certificate = z.object({ certificate: tls_certificates_and_hostnames_client_certificates_components_schemas_certificate, certificate_authority: tls_certificates_and_hostnames_client_certificates_components_schemas_certificate_authority, common_name: tls_certificates_and_hostnames_common_name, country: tls_certificates_and_hostnames_country, csr: tls_certificates_and_hostnames_schemas_csr, expires_on: tls_certificates_and_hostnames_expired_on, fingerprint_sha256: tls_certificates_and_hostnames_fingerprint_sha256, id: tls_certificates_and_hostnames_identifier.max(32), issued_on: tls_certificates_and_hostnames_issued_on, location: tls_certificates_and_hostnames_location, organization: tls_certificates_and_hostnames_organization, organizational_unit: tls_certificates_and_hostnames_organizational_unit, serial_number: tls_certificates_and_hostnames_components_schemas_serial_number, signature: tls_certificates_and_hostnames_components_schemas_signature, ski: tls_certificates_and_hostnames_ski, state: tls_certificates_and_hostnames_state, status: tls_certificates_and_hostnames_client_certificates_components_schemas_status, validity_days: tls_certificates_and_hostnames_components_schemas_validity_days.int() }).partial().passthrough();
const tls_certificates_and_hostnames_client_certificate_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(tls_certificates_and_hostnames_client_certificate) }).partial().passthrough());
const client_certificate_for_a_zone_create_client_certificate_Body = z.object({ csr: tls_certificates_and_hostnames_schemas_csr, validity_days: tls_certificates_and_hostnames_components_schemas_validity_days.int() }).passthrough();
const tls_certificates_and_hostnames_client_certificate_response_single = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_client_certificate }).partial().passthrough());
const tls_certificates_and_hostnames_bundle_method = z.enum(["ubiquitous", "optimal", "force"]);
const tls_certificates_and_hostnames_expires_on = z.string();
const tls_certificates_and_hostnames_geo_restrictions = z.object({ label: z.unknown() }).partial().passthrough();
const tls_certificates_and_hostnames_hosts = z.array(z.string());
const tls_certificates_and_hostnames_issuer = z.string();
const tls_certificates_and_hostnames_enabled = z.boolean();
const tls_certificates_and_hostnames_host = z.string();
const tls_certificates_and_hostnames_schemas_identifier = z.string();
const tls_certificates_and_hostnames_name = z.string();
const tls_certificates_and_hostnames_port = z.number();
const tls_certificates_and_hostnames_schemas_status = z.enum(["active", "deleted"]);
const tls_certificates_and_hostnames_keyless_private_ip = z.string();
const tls_certificates_and_hostnames_keyless_vnet_id = z.string();
const tls_certificates_and_hostnames_keyless_tunnel = z.object({ private_ip: tls_certificates_and_hostnames_keyless_private_ip, vnet_id: tls_certificates_and_hostnames_keyless_vnet_id }).passthrough();
const tls_certificates_and_hostnames_base = z.object({ created_on: z.string().datetime({ offset: true }), enabled: tls_certificates_and_hostnames_enabled, host: tls_certificates_and_hostnames_host.max(253).url(), id: tls_certificates_and_hostnames_schemas_identifier.max(32), modified_on: z.string().datetime({ offset: true }), name: tls_certificates_and_hostnames_name.max(180), permissions: z.array(z.unknown()), port: tls_certificates_and_hostnames_port.default(24008), status: tls_certificates_and_hostnames_schemas_status, tunnel: tls_certificates_and_hostnames_keyless_tunnel.optional() }).passthrough();
const tls_certificates_and_hostnames_keyless_certificate = tls_certificates_and_hostnames_base;
const tls_certificates_and_hostnames_modified_on = z.string();
const tls_certificates_and_hostnames_policy = z.string();
const tls_certificates_and_hostnames_priority = z.number();
const tls_certificates_and_hostnames_status = z.unknown();
const tls_certificates_and_hostnames_uploaded_on = z.string();
const tls_certificates_and_hostnames_custom_certificate = z.object({ bundle_method: tls_certificates_and_hostnames_bundle_method.default("ubiquitous"), expires_on: tls_certificates_and_hostnames_expires_on.datetime({ offset: true }), geo_restrictions: tls_certificates_and_hostnames_geo_restrictions.optional(), hosts: tls_certificates_and_hostnames_hosts, id: tls_certificates_and_hostnames_identifier.max(32), issuer: tls_certificates_and_hostnames_issuer, keyless_server: tls_certificates_and_hostnames_keyless_certificate.optional(), modified_on: tls_certificates_and_hostnames_modified_on.datetime({ offset: true }), policy: tls_certificates_and_hostnames_policy.optional(), priority: tls_certificates_and_hostnames_priority.default(20), signature: tls_certificates_and_hostnames_signature, status: tls_certificates_and_hostnames_status, uploaded_on: tls_certificates_and_hostnames_uploaded_on.datetime({ offset: true }), zone_id: tls_certificates_and_hostnames_identifier.max(32) }).passthrough();
const tls_certificates_and_hostnames_certificate_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(tls_certificates_and_hostnames_custom_certificate) }).partial().passthrough());
const tls_certificates_and_hostnames_certificate = z.string();
const tls_certificates_and_hostnames_private_key = z.string();
const tls_certificates_and_hostnames_type = z.enum(["legacy_custom", "sni_custom"]);
const custom_ssl_for_a_zone_create_ssl_configuration_Body = z.object({ bundle_method: tls_certificates_and_hostnames_bundle_method.optional().default("ubiquitous"), certificate: tls_certificates_and_hostnames_certificate, geo_restrictions: tls_certificates_and_hostnames_geo_restrictions.optional(), policy: tls_certificates_and_hostnames_policy.optional(), private_key: tls_certificates_and_hostnames_private_key, type: tls_certificates_and_hostnames_type.optional().default("legacy_custom") }).passthrough();
const tls_certificates_and_hostnames_certificate_response_single = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_certificate_response_id_only = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({ id: tls_certificates_and_hostnames_identifier.max(32) }).partial().passthrough() }).partial().passthrough());
const custom_ssl_for_a_zone_edit_ssl_configuration_Body = z.object({ bundle_method: tls_certificates_and_hostnames_bundle_method.default("ubiquitous"), certificate: tls_certificates_and_hostnames_certificate, geo_restrictions: tls_certificates_and_hostnames_geo_restrictions, policy: tls_certificates_and_hostnames_policy, private_key: tls_certificates_and_hostnames_private_key }).partial().passthrough();
const tls_certificates_and_hostnames_created_at = z.string();
const tls_certificates_and_hostnames_custom_metadata = z.object({ key: z.string() }).partial().passthrough();
const tls_certificates_and_hostnames_custom_origin_server = z.string();
const tls_certificates_and_hostnames_custom_origin_sni = z.string();
const tls_certificates_and_hostnames_hostname = z.string();
const tls_certificates_and_hostnames_ownership_verification = z.object({ name: z.string(), type: z.unknown(), value: z.string() }).partial().passthrough();
const tls_certificates_and_hostnames_ownership_verification_http = z.object({ http_body: z.string(), http_url: z.string() }).partial().passthrough();
const tls_certificates_and_hostnames_certificate_authority = z.enum(["digicert", "google", "lets_encrypt"]);
const tls_certificates_and_hostnames_sslsettings = z.object({ ciphers: z.array(z.string()), early_hints: z.unknown(), http2: z.unknown(), min_tls_version: z.unknown(), tls_1_3: z.unknown() }).partial().passthrough();
const tls_certificates_and_hostnames_validation_record = z.object({ emails: z.array(z.unknown()), http_body: z.string(), http_url: z.string(), txt_name: z.string(), txt_value: z.string() }).partial().passthrough();
const tls_certificates_and_hostnames_ssl = z.object({ bundle_method: z.enum(["ubiquitous", "optimal", "force"]).default("ubiquitous"), certificate_authority: tls_certificates_and_hostnames_certificate_authority, custom_certificate: z.string(), custom_csr_id: z.string(), custom_key: z.string(), expires_on: z.string().datetime({ offset: true }), hosts: z.array(z.unknown()), id: z.string().min(36).max(36), issuer: z.string(), method: z.unknown(), serial_number: z.string(), settings: tls_certificates_and_hostnames_sslsettings, signature: z.string(), status: z.unknown(), type: z.unknown(), uploaded_on: z.string().datetime({ offset: true }), validation_errors: z.array(z.object({ message: z.string() }).partial().passthrough()), validation_records: z.array(tls_certificates_and_hostnames_validation_record), wildcard: z.boolean() }).partial().passthrough();
const tls_certificates_and_hostnames_components_schemas_status = z.unknown();
const tls_certificates_and_hostnames_verification_errors = z.array(z.unknown());
const tls_certificates_and_hostnames_customhostname = z.object({ created_at: tls_certificates_and_hostnames_created_at.datetime({ offset: true }), custom_metadata: tls_certificates_and_hostnames_custom_metadata, custom_origin_server: tls_certificates_and_hostnames_custom_origin_server, custom_origin_sni: tls_certificates_and_hostnames_custom_origin_sni, hostname: tls_certificates_and_hostnames_hostname.max(255), id: tls_certificates_and_hostnames_identifier.max(32), ownership_verification: tls_certificates_and_hostnames_ownership_verification, ownership_verification_http: tls_certificates_and_hostnames_ownership_verification_http, ssl: tls_certificates_and_hostnames_ssl, status: tls_certificates_and_hostnames_components_schemas_status, verification_errors: tls_certificates_and_hostnames_verification_errors }).partial().passthrough();
const tls_certificates_and_hostnames_custom_hostname = tls_certificates_and_hostnames_customhostname;
const tls_certificates_and_hostnames_custom_hostname_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(tls_certificates_and_hostnames_custom_hostname) }).partial().passthrough());
const tls_certificates_and_hostnames_hostname_post = z.string();
const tls_certificates_and_hostnames_sslpost = z.object({ bundle_method: z.enum(["ubiquitous", "optimal", "force"]).default("ubiquitous"), certificate_authority: tls_certificates_and_hostnames_certificate_authority, custom_certificate: z.string(), custom_key: z.string(), method: z.unknown(), settings: tls_certificates_and_hostnames_sslsettings, type: z.unknown(), wildcard: z.boolean() }).partial().passthrough();
const custom_hostname_for_a_zone_create_custom_hostname_Body = z.object({ custom_metadata: tls_certificates_and_hostnames_custom_metadata.optional(), hostname: tls_certificates_and_hostnames_hostname_post.max(255), ssl: tls_certificates_and_hostnames_sslpost }).passthrough();
const tls_certificates_and_hostnames_custom_hostname_response_single = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_custom_hostname }).partial().passthrough());
const tls_certificates_and_hostnames_fallback_origin_response = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_origin = z.string();
const custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames_Body = z.object({ origin: tls_certificates_and_hostnames_origin.max(255) }).passthrough();
const custom_hostname_for_a_zone_edit_custom_hostname_Body = z.object({ custom_metadata: tls_certificates_and_hostnames_custom_metadata, custom_origin_server: tls_certificates_and_hostnames_custom_origin_server, custom_origin_sni: tls_certificates_and_hostnames_custom_origin_sni, ssl: tls_certificates_and_hostnames_sslpost }).partial().passthrough();
const dns_custom_nameservers_zone_metadata = z.object({ enabled: z.boolean(), ns_set: z.number().gte(1).lte(5).default(1) }).partial().passthrough();
const dns_custom_nameservers_get_response = dns_custom_nameservers_api_response_collection.and(dns_custom_nameservers_zone_metadata);
const dns_custom_nameservers_schemas_empty_response = dns_custom_nameservers_api_response_collection.and(z.object({ result: z.array(z.unknown()) }).partial().passthrough());
const tls_certificates_and_hostnames_uuid = z.string();
const tls_certificates_and_hostnames_uuidObject = z.object({ uuid: tls_certificates_and_hostnames_uuid }).partial().passthrough();
const tls_certificates_and_hostnames_dcv_delegation_response = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_uuidObject }).partial().passthrough());
const dns_records_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const dns_records_api_response_common = z.object({ errors: dns_records_messages, messages: dns_records_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const dns_records_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const dns_records_api_response_collection = dns_records_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: dns_records_result_info }).partial().passthrough());
const dns_records_name = z.string();
const dns_records_proxied = z.boolean();
const dns_records_comment = z.string();
const dns_records_identifier = z.string();
const dns_records_tags = z.array(z.string());
const dns_records_ttl = z.union([z.number(), z.literal(1)]);
const dns_records_base = z.object({ comment: dns_records_comment, created_on: z.string().datetime({ offset: true }), id: dns_records_identifier.max(32), locked: z.boolean(), meta: z.object({ auto_added: z.boolean(), source: z.string() }).partial().passthrough(), modified_on: z.string().datetime({ offset: true }), proxiable: z.boolean(), tags: dns_records_tags, ttl: dns_records_ttl.default(1), zone_id: dns_records_identifier.max(32), zone_name: z.string().url() }).partial().passthrough();
const dns_records_ARecord = z.object({ content: z.string(), name: dns_records_name.max(255), proxied: dns_records_proxied, type: z.literal("A") }).partial().passthrough().and(dns_records_base);
const dns_records_AAAARecord = z.object({ content: z.string(), name: dns_records_name.max(255), proxied: dns_records_proxied, type: z.literal("AAAA") }).partial().passthrough().and(dns_records_base);
const dns_records_CAARecord = z.object({ content: z.string(), data: z.object({ flags: z.number().gte(0).lte(255), tag: z.string(), value: z.string() }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("CAA") }).partial().passthrough().and(dns_records_base);
const dns_records_CERTRecord = z.object({ content: z.string(), data: z.object({ algorithm: z.number().gte(0).lte(255), certificate: z.string(), key_tag: z.number().gte(0).lte(65535), type: z.number().gte(0).lte(65535) }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("CERT") }).partial().passthrough().and(dns_records_base);
const dns_records_CNAMERecord = z.object({ content: z.unknown(), name: dns_records_name.max(255), proxied: dns_records_proxied, type: z.literal("CNAME") }).partial().passthrough().and(dns_records_base);
const dns_records_DNSKEYRecord = z.object({ content: z.string(), data: z.object({ algorithm: z.number().gte(0).lte(255), flags: z.number().gte(0).lte(65535), protocol: z.number().gte(0).lte(255), public_key: z.string() }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("DNSKEY") }).partial().passthrough().and(dns_records_base);
const dns_records_DSRecord = z.object({ content: z.string(), data: z.object({ algorithm: z.number().gte(0).lte(255), digest: z.string(), digest_type: z.number().gte(0).lte(255), key_tag: z.number().gte(0).lte(65535) }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("DS") }).partial().passthrough().and(dns_records_base);
const dns_records_HTTPSRecord = z.object({ content: z.string(), data: z.object({ priority: z.number().gte(0).lte(65535), target: z.string(), value: z.string() }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("HTTPS") }).partial().passthrough().and(dns_records_base);
const dns_records_LOCRecord = z.object({ content: z.string(), data: z.object({ altitude: z.number().gte(-100000).lte(42849672.95), lat_degrees: z.number().gte(0).lte(90), lat_direction: z.unknown(), lat_minutes: z.number().gte(0).lte(59), lat_seconds: z.number().gte(0).lte(59.999), long_degrees: z.number().gte(0).lte(180), long_direction: z.unknown(), long_minutes: z.number().gte(0).lte(59), long_seconds: z.number().gte(0).lte(59.999), precision_horz: z.number().gte(0).lte(90000000), precision_vert: z.number().gte(0).lte(90000000), size: z.number().gte(0).lte(90000000) }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("LOC") }).partial().passthrough().and(dns_records_base);
const dns_records_priority = z.number();
const dns_records_MXRecord = z.object({ content: z.string().url(), name: dns_records_name.max(255), priority: dns_records_priority.gte(0).lte(65535), type: z.literal("MX") }).partial().passthrough().and(dns_records_base);
const dns_records_NAPTRRecord = z.object({ content: z.string(), data: z.object({ flags: z.string(), order: z.number().gte(0).lte(65535), preference: z.number().gte(0).lte(65535), regex: z.string(), replacement: z.string(), service: z.string() }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("NAPTR") }).partial().passthrough().and(dns_records_base);
const dns_records_NSRecord = z.object({ content: z.unknown(), name: dns_records_name.max(255), type: z.literal("NS") }).partial().passthrough().and(dns_records_base);
const dns_records_PTRRecord = z.object({ content: z.string(), name: dns_records_name.max(255), type: z.literal("PTR") }).partial().passthrough().and(dns_records_base);
const dns_records_SMIMEARecord = z.object({ content: z.string(), data: z.object({ certificate: z.string(), matching_type: z.number().gte(0).lte(255), selector: z.number().gte(0).lte(255), usage: z.number().gte(0).lte(255) }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("SMIMEA") }).partial().passthrough().and(dns_records_base);
const dns_records_SRVRecord = z.object({ content: z.string(), data: z.object({ name: z.string().url(), port: z.number().gte(0).lte(65535), priority: dns_records_priority.gte(0).lte(65535), proto: z.string(), service: z.string(), target: z.string().url(), weight: z.number().gte(0).lte(65535) }).partial().passthrough(), name: z.string().max(255), type: z.literal("SRV") }).partial().passthrough().and(dns_records_base);
const dns_records_SSHFPRecord = z.object({ content: z.string(), data: z.object({ algorithm: z.number().gte(0).lte(255), fingerprint: z.string(), type: z.number().gte(0).lte(255) }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("SSHFP") }).partial().passthrough().and(dns_records_base);
const dns_records_SVCBRecord = z.object({ content: z.string(), data: z.object({ priority: z.number().gte(0).lte(65535), target: z.string(), value: z.string() }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("SVCB") }).partial().passthrough().and(dns_records_base);
const dns_records_TLSARecord = z.object({ content: z.string(), data: z.object({ certificate: z.string(), matching_type: z.number().gte(0).lte(255), selector: z.number().gte(0).lte(255), usage: z.number().gte(0).lte(255) }).partial().passthrough(), name: dns_records_name.max(255), type: z.literal("TLSA") }).partial().passthrough().and(dns_records_base);
const dns_records_TXTRecord = z.object({ content: z.string(), name: dns_records_name.max(255), type: z.literal("TXT") }).partial().passthrough().and(dns_records_base);
const dns_records_URIRecord = z.object({ content: z.string(), data: z.object({ content: z.string(), weight: z.number().gte(0).lte(65535) }).partial().passthrough(), name: dns_records_name.max(255), priority: dns_records_priority.gte(0).lte(65535), type: z.literal("URI") }).partial().passthrough().and(dns_records_base);
const dns_records_dns_record = z.union([dns_records_ARecord, dns_records_AAAARecord, dns_records_CAARecord, dns_records_CERTRecord, dns_records_CNAMERecord, dns_records_DNSKEYRecord, dns_records_DSRecord, dns_records_HTTPSRecord, dns_records_LOCRecord, dns_records_MXRecord, dns_records_NAPTRRecord, dns_records_NSRecord, dns_records_PTRRecord, dns_records_SMIMEARecord, dns_records_SRVRecord, dns_records_SSHFPRecord, dns_records_SVCBRecord, dns_records_TLSARecord, dns_records_TXTRecord, dns_records_URIRecord]);
const dns_records_dns_response_collection = dns_records_api_response_collection.and(z.object({ result: z.array(dns_records_dns_record) }).partial().passthrough());
const dns_records_api_response_common_failure = z.object({ errors: dns_records_messages, messages: dns_records_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const dns_records_api_response_single = dns_records_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const dns_records_dns_response_single = dns_records_api_response_single.and(z.object({ result: dns_records_dns_record }).partial().passthrough());
const dns_records_for_a_zone_import_dns_records_Body = z.object({ file: z.string(), proxied: z.string().optional().default("false") }).passthrough();
const dns_records_dns_response_import_scan = dns_records_api_response_single.and(z.object({ result: z.object({ recs_added: z.number(), total_records_parsed: z.number() }).partial().passthrough(), timing: z.object({ end_time: z.string().datetime({ offset: true }), process_time: z.number(), start_time: z.string().datetime({ offset: true }) }).partial().passthrough() }).partial().passthrough());
const dnssec_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const dnssec_api_response_common = z.object({ errors: dnssec_messages, messages: dnssec_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const dnssec_api_response_single = dnssec_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const dnssec_delete_dnssec_response_single = dnssec_api_response_single.and(z.object({ result: z.string() }).partial().passthrough());
const dnssec_api_response_common_failure = z.object({ errors: dnssec_messages, messages: dnssec_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const dnssec_algorithm = z.string();
const dnssec_digest = z.string();
const dnssec_digest_algorithm = z.string();
const dnssec_digest_type = z.string();
const dnssec_dnssec_multi_signer = z.boolean();
const dnssec_dnssec_presigned = z.boolean();
const dnssec_ds = z.string();
const dnssec_flags = z.number();
const dnssec_key_tag = z.number();
const dnssec_key_type = z.string();
const dnssec_modified_on = z.string();
const dnssec_public_key = z.string();
const dnssec_status = z.unknown();
const dnssec_dnssec = z.object({ algorithm: dnssec_algorithm.nullable(), digest: dnssec_digest.nullable(), digest_algorithm: dnssec_digest_algorithm.nullable(), digest_type: dnssec_digest_type.nullable(), dnssec_multi_signer: dnssec_dnssec_multi_signer, dnssec_presigned: dnssec_dnssec_presigned, ds: dnssec_ds.nullable(), flags: dnssec_flags.nullable(), key_tag: dnssec_key_tag.nullable(), key_type: dnssec_key_type.nullable(), modified_on: dnssec_modified_on.datetime({ offset: true }).nullable(), public_key: dnssec_public_key.nullable(), status: dnssec_status }).partial().passthrough();
const dnssec_dnssec_response_single = dnssec_api_response_single.and(z.object({ result: dnssec_dnssec }).partial().passthrough());
const waf_managed_rules_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const waf_managed_rules_api_response_common = z.object({ errors: waf_managed_rules_messages, messages: waf_managed_rules_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const waf_managed_rules_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const waf_managed_rules_api_response_collection = waf_managed_rules_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: waf_managed_rules_result_info }).partial().passthrough());
const waf_managed_rules_description = z.string();
const waf_managed_rules_components_schemas_identifier = z.string();
const waf_managed_rules_modified_rules_count = z.number();
const waf_managed_rules_name = z.string();
const waf_managed_rules_identifier = z.string();
const waf_managed_rules_rules_count = z.number();
const waf_managed_rules_group = z.object({ description: waf_managed_rules_description.nullable(), id: waf_managed_rules_components_schemas_identifier.max(32), modified_rules_count: waf_managed_rules_modified_rules_count, name: waf_managed_rules_name, package_id: waf_managed_rules_identifier.max(32), rules_count: waf_managed_rules_rules_count }).partial().passthrough();
const waf_managed_rules_mode = z.enum(["on", "off"]);
const waf_managed_rules_allowed_modes = z.array(waf_managed_rules_mode);
const waf_managed_rules_schemas_group = waf_managed_rules_group.and(z.object({ allowed_modes: waf_managed_rules_allowed_modes, mode: waf_managed_rules_mode.default("on") }).partial().passthrough());
const waf_managed_rules_rule_group_response_collection = waf_managed_rules_api_response_collection.and(z.object({ result: z.array(waf_managed_rules_schemas_group) }).partial().passthrough());
const waf_managed_rules_api_response_common_failure = z.object({ errors: waf_managed_rules_messages, messages: waf_managed_rules_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const waf_managed_rules_api_response_single = waf_managed_rules_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const waf_managed_rules_rule_group_response_single = waf_managed_rules_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const waf_managed_rules_schemas_description = z.string();
const waf_managed_rules_rule_components_schemas_identifier = z.string();
const waf_managed_rules_priority = z.string();
const waf_managed_rules_base = z.object({ description: waf_managed_rules_schemas_description, group: z.object({ id: waf_managed_rules_components_schemas_identifier.max(32), name: waf_managed_rules_name }).partial().passthrough(), id: waf_managed_rules_rule_components_schemas_identifier.max(32), package_id: waf_managed_rules_identifier.max(32), priority: waf_managed_rules_priority }).partial().passthrough();
const waf_managed_rules_schemas_base = waf_managed_rules_base;
const waf_managed_rules_mode_anomaly = z.enum(["on", "off"]);
const waf_managed_rules_allowed_modes_anomaly = z.array(waf_managed_rules_mode_anomaly);
const waf_managed_rules_anomaly_rule = waf_managed_rules_schemas_base.and(z.object({ allowed_modes: waf_managed_rules_allowed_modes_anomaly, mode: waf_managed_rules_mode_anomaly }).partial().passthrough());
const waf_managed_rules_mode_deny_traditional = z.enum(["default", "disable", "simulate", "block", "challenge"]);
const waf_managed_rules_allowed_modes_deny_traditional = z.array(waf_managed_rules_mode_deny_traditional);
const waf_managed_rules_default_mode = z.unknown();
const waf_managed_rules_traditional_deny_rule = waf_managed_rules_base.and(z.object({ allowed_modes: waf_managed_rules_allowed_modes_deny_traditional, default_mode: waf_managed_rules_default_mode, mode: waf_managed_rules_mode_deny_traditional }).partial().passthrough());
const waf_managed_rules_mode_allow_traditional = z.enum(["on", "off"]);
const waf_managed_rules_allowed_modes_allow_traditional = z.array(waf_managed_rules_mode_allow_traditional);
const waf_managed_rules_traditional_allow_rule = waf_managed_rules_base.and(z.object({ allowed_modes: waf_managed_rules_allowed_modes_allow_traditional, mode: waf_managed_rules_mode_allow_traditional }).partial().passthrough());
const waf_managed_rules_rule = z.union([waf_managed_rules_anomaly_rule, waf_managed_rules_traditional_deny_rule, waf_managed_rules_traditional_allow_rule]);
const waf_managed_rules_rule_response_collection = waf_managed_rules_api_response_collection.and(z.object({ result: z.array(waf_managed_rules_rule) }).partial().passthrough());
const waf_managed_rules_rule_response_single = waf_managed_rules_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const zones_schemas_api_response_common_failure = z.object({ errors: zones_messages, messages: zones_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const zones_schemas_api_response_common = z.object({ errors: zones_messages, messages: zones_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const zones_api_response_single = zones_schemas_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.string()]) }).partial().passthrough());
const tls_certificates_and_hostnames_components_schemas_created_at = z.string();
const tls_certificates_and_hostnames_components_schemas_hostname = z.string();
const tls_certificates_and_hostnames_hostname_tls_settings_components_schemas_status = z.string();
const tls_certificates_and_hostnames_components_schemas_updated_at = z.string();
const tls_certificates_and_hostnames_value = z.union([z.number(), z.string(), z.array(z.string())]);
const tls_certificates_and_hostnames_per_hostname_settings_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(z.object({ created_at: tls_certificates_and_hostnames_components_schemas_created_at.datetime({ offset: true }), hostname: tls_certificates_and_hostnames_components_schemas_hostname, status: tls_certificates_and_hostnames_hostname_tls_settings_components_schemas_status, updated_at: tls_certificates_and_hostnames_components_schemas_updated_at.datetime({ offset: true }), value: tls_certificates_and_hostnames_value }).partial().passthrough()) }).partial().passthrough()).and(z.object({ result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown(), total_pages: z.number() }).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_settingObjectDelete = z.object({ created_at: tls_certificates_and_hostnames_components_schemas_created_at.datetime({ offset: true }), hostname: tls_certificates_and_hostnames_components_schemas_hostname, status: z.unknown(), updated_at: tls_certificates_and_hostnames_components_schemas_updated_at.datetime({ offset: true }), value: z.unknown() }).partial().passthrough();
const tls_certificates_and_hostnames_per_hostname_settings_response_delete = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_settingObjectDelete }).partial().passthrough());
const per_hostname_tls_settings_put_Body = z.object({ value: tls_certificates_and_hostnames_value }).passthrough();
const tls_certificates_and_hostnames_settingObject = z.object({ created_at: tls_certificates_and_hostnames_components_schemas_created_at.datetime({ offset: true }), hostname: tls_certificates_and_hostnames_components_schemas_hostname, status: tls_certificates_and_hostnames_hostname_tls_settings_components_schemas_status, updated_at: tls_certificates_and_hostnames_components_schemas_updated_at.datetime({ offset: true }), value: tls_certificates_and_hostnames_value }).partial().passthrough();
const tls_certificates_and_hostnames_per_hostname_settings_response = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_settingObject }).partial().passthrough());
const tls_certificates_and_hostnames_keyless_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(tls_certificates_and_hostnames_keyless_certificate) }).partial().passthrough());
const tls_certificates_and_hostnames_schemas_certificate = z.string();
const tls_certificates_and_hostnames_name_write = z.string();
const keyless_ssl_for_a_zone_create_keyless_ssl_configuration_Body = z.object({ bundle_method: tls_certificates_and_hostnames_bundle_method.optional().default("ubiquitous"), certificate: tls_certificates_and_hostnames_schemas_certificate, host: tls_certificates_and_hostnames_host.max(253).url(), name: tls_certificates_and_hostnames_name_write.max(180).optional(), port: tls_certificates_and_hostnames_port.default(24008), tunnel: tls_certificates_and_hostnames_keyless_tunnel.optional() }).passthrough();
const tls_certificates_and_hostnames_keyless_response_single = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_base }).partial().passthrough());
const tls_certificates_and_hostnames_keyless_response_single_id = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({ id: tls_certificates_and_hostnames_identifier.max(32) }).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_enabled_write = z.boolean();
const keyless_ssl_for_a_zone_edit_keyless_ssl_configuration_Body = z.object({ enabled: tls_certificates_and_hostnames_enabled_write, host: tls_certificates_and_hostnames_host.max(253).url(), name: tls_certificates_and_hostnames_name_write.max(180), port: tls_certificates_and_hostnames_port.default(24008), tunnel: tls_certificates_and_hostnames_keyless_tunnel }).partial().passthrough();
const load_balancing_adaptive_routing = z.object({ failover_across_pools: z.boolean() }).partial().passthrough();
const load_balancing_country_pools = z.object({}).partial().passthrough();
const load_balancing_default_pools = z.array(z.string());
const load_balancing_components_schemas_description = z.string();
const load_balancing_components_schemas_enabled = z.boolean();
const load_balancing_fallback_pool = z.unknown();
const load_balancing_load_balancer_components_schemas_identifier = z.string();
const load_balancing_location_strategy = z.object({ mode: z.enum(["pop", "resolver_ip"]).default("pop"), prefer_ecs: z.enum(["always", "never", "proximity", "geo"]).default("proximity") }).partial().passthrough();
const load_balancing_components_schemas_name = z.string();
const load_balancing_pop_pools = z.object({}).partial().passthrough();
const load_balancing_proxied = z.boolean();
const load_balancing_random_steering = z.object({ default_weight: z.number().gte(0).lte(1).multipleOf(0.1).default(1), pool_weights: z.object({}).partial().passthrough() }).partial().passthrough();
const load_balancing_region_pools = z.object({}).partial().passthrough();
const load_balancing_session_affinity = z.enum(["none", "cookie", "ip_cookie", "header", """"]);
const load_balancing_session_affinity_attributes = z.object({ drain_duration: z.number(), headers: z.array(z.string()).default("none"), require_all_headers: z.boolean(), samesite: z.enum(["Auto", "Lax", "None", "Strict"]).default("Auto"), secure: z.enum(["Auto", "Always", "Never"]).default("Auto"), zero_downtime_failover: z.enum(["none", "temporary", "sticky"]).default("none") }).partial().passthrough();
const load_balancing_session_affinity_ttl = z.number();
const load_balancing_steering_policy = z.enum(["off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", """"]);
const load_balancing_ttl = z.number();
const load_balancing_rules = z.array(z.object({ condition: z.string(), disabled: z.boolean(), fixed_response: z.object({ content_type: z.string().max(32), location: z.string().max(2048), message_body: z.string().max(1024), status_code: z.number().int() }).partial().passthrough(), name: z.string().max(200), overrides: z.object({ adaptive_routing: load_balancing_adaptive_routing, country_pools: load_balancing_country_pools, default_pools: load_balancing_default_pools, fallback_pool: load_balancing_fallback_pool, location_strategy: load_balancing_location_strategy, pop_pools: load_balancing_pop_pools, random_steering: load_balancing_random_steering, region_pools: load_balancing_region_pools, session_affinity: load_balancing_session_affinity.default("\"\""), session_affinity_attributes: load_balancing_session_affinity_attributes, session_affinity_ttl: load_balancing_session_affinity_ttl, steering_policy: load_balancing_steering_policy.default("\"\""), ttl: load_balancing_ttl }).partial().passthrough(), priority: z.number().int().gte(0), terminates: z.boolean() }).partial());
const load_balancing_load_balancer = z.object({ adaptive_routing: load_balancing_adaptive_routing, country_pools: load_balancing_country_pools, created_on: load_balancing_timestamp.datetime({ offset: true }), default_pools: load_balancing_default_pools, description: load_balancing_components_schemas_description, enabled: load_balancing_components_schemas_enabled.default(true), fallback_pool: load_balancing_fallback_pool, id: load_balancing_load_balancer_components_schemas_identifier, location_strategy: load_balancing_location_strategy, modified_on: load_balancing_timestamp.datetime({ offset: true }), name: load_balancing_components_schemas_name, pop_pools: load_balancing_pop_pools, proxied: load_balancing_proxied, random_steering: load_balancing_random_steering, region_pools: load_balancing_region_pools, rules: load_balancing_rules, session_affinity: load_balancing_session_affinity.default("\"\""), session_affinity_attributes: load_balancing_session_affinity_attributes, session_affinity_ttl: load_balancing_session_affinity_ttl, steering_policy: load_balancing_steering_policy.default("\"\""), ttl: load_balancing_ttl }).partial().passthrough();
const load_balancing_load_balancer_components_schemas_response_collection = load_balancing_api_response_collection.and(z.object({ result: z.array(load_balancing_load_balancer) }).partial().passthrough());
const load_balancing_load_balancer_components_schemas_single_response = load_balancing_api_response_single.and(z.object({ result: load_balancing_load_balancer }).partial().passthrough());
const load_balancing_components_schemas_id_response = load_balancing_api_response_single.and(z.object({ result: z.object({ id: load_balancing_load_balancer_components_schemas_identifier }).partial().passthrough() }).partial().passthrough());
const logpush_schemas_destination_conf = z.string();
const logpush_fields = z.string();
const logpush_filter = z.string();
const logpush_sample = z.number();
const logpush_session_id = z.string();
const logpush_instant_logs_job = z.object({ destination_conf: logpush_schemas_destination_conf.max(4096).url(), fields: logpush_fields, filter: logpush_filter, sample: logpush_sample.int(), session_id: logpush_session_id }).partial().passthrough();
const logpush_instant_logs_job_response_collection = logpush_api_response_common.and(z.object({ result: z.array(logpush_instant_logs_job) }).partial().passthrough());
const logpush_instant_logs_job_response_single = logpush_api_response_single.and(z.object({ result: logpush_instant_logs_job.nullable() }).partial().passthrough());
const rulesets_enabled = z.boolean();
const rulesets_id = z.string();
const rulesets_request_model = z.object({ enabled: rulesets_enabled, id: rulesets_id }).partial().passthrough();
const rulesets_request_list = z.array(rulesets_request_model);
const rulesets_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const rulesets_api_response_common_failure = z.object({ errors: rulesets_messages, messages: rulesets_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const managed_transforms_update_status_of_managed_transforms_Body = z.object({ managed_request_headers: rulesets_request_list, managed_response_headers: rulesets_request_list }).passthrough();
const rulesets_available = z.boolean();
const rulesets_response_model = z.object({ available: rulesets_available, enabled: rulesets_enabled, id: rulesets_id }).partial().passthrough();
const rulesets_response_list = z.array(rulesets_response_model);
const tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_certificate = z.string();
const tls_certificates_and_hostnames_components_schemas_expires_on = z.string();
const tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_status = z.unknown();
const tls_certificates_and_hostnames_schemas_uploaded_on = z.string();
const tls_certificates_and_hostnames_certificateObject = z.object({ certificate: tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_certificate, expires_on: tls_certificates_and_hostnames_components_schemas_expires_on.datetime({ offset: true }), id: tls_certificates_and_hostnames_identifier.max(32), issuer: tls_certificates_and_hostnames_issuer, signature: tls_certificates_and_hostnames_signature, status: tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_status, uploaded_on: tls_certificates_and_hostnames_schemas_uploaded_on.datetime({ offset: true }) }).partial().passthrough();
const tls_certificates_and_hostnames_zone_authenticated_origin_pull = tls_certificates_and_hostnames_certificateObject;
const tls_certificates_and_hostnames_components_schemas_certificate_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(tls_certificates_and_hostnames_zone_authenticated_origin_pull) }).partial().passthrough());
const zone_level_authenticated_origin_pulls_upload_certificate_Body = z.object({ certificate: tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_certificate, private_key: tls_certificates_and_hostnames_private_key }).passthrough();
const tls_certificates_and_hostnames_cert_id = z.string();
const tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_enabled = z.boolean();
const tls_certificates_and_hostnames_schemas_hostname = z.string();
const tls_certificates_and_hostnames_hostname_certid_input = z.object({ cert_id: tls_certificates_and_hostnames_cert_id.max(36), enabled: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_enabled.nullable(), hostname: tls_certificates_and_hostnames_schemas_hostname.max(255) }).partial().passthrough();
const tls_certificates_and_hostnames_config = z.array(tls_certificates_and_hostnames_hostname_certid_input);
const tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_status = z.unknown();
const tls_certificates_and_hostnames_updated_at = z.string();
const tls_certificates_and_hostnames_components_schemas_uploaded_on = z.string();
const tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_certificate = z.string();
const tls_certificates_and_hostnames_schemas_created_at = z.string();
const tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_expires_on = z.string();
const tls_certificates_and_hostnames_serial_number = z.string();
const tls_certificates_and_hostnames_hostname_certid_object = z.object({ cert_id: tls_certificates_and_hostnames_identifier.max(32), cert_status: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_status, cert_updated_at: tls_certificates_and_hostnames_updated_at.datetime({ offset: true }), cert_uploaded_on: tls_certificates_and_hostnames_components_schemas_uploaded_on.datetime({ offset: true }), certificate: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_certificate, created_at: tls_certificates_and_hostnames_schemas_created_at.datetime({ offset: true }), enabled: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_enabled.nullable(), expires_on: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_expires_on.datetime({ offset: true }), hostname: tls_certificates_and_hostnames_schemas_hostname.max(255), issuer: tls_certificates_and_hostnames_issuer, serial_number: tls_certificates_and_hostnames_serial_number, signature: tls_certificates_and_hostnames_signature, status: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_status, updated_at: tls_certificates_and_hostnames_updated_at.datetime({ offset: true }) }).partial().passthrough();
const tls_certificates_and_hostnames_hostname_authenticated_origin_pull = tls_certificates_and_hostnames_hostname_certid_object;
const tls_certificates_and_hostnames_hostname_aop_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(tls_certificates_and_hostnames_hostname_authenticated_origin_pull) }).partial().passthrough());
const tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_certificate_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(tls_certificates_and_hostnames_hostname_authenticated_origin_pull) }).partial().passthrough());
const tls_certificates_and_hostnames_schemas_private_key = z.string();
const per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate_Body = z.object({ certificate: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_certificate, private_key: tls_certificates_and_hostnames_schemas_private_key }).passthrough();
const tls_certificates_and_hostnames_schemas_certificateObject = z.object({ certificate: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_certificate, expires_on: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_expires_on.datetime({ offset: true }), id: tls_certificates_and_hostnames_identifier.max(32), issuer: tls_certificates_and_hostnames_issuer, serial_number: tls_certificates_and_hostnames_serial_number, signature: tls_certificates_and_hostnames_signature, status: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_status, uploaded_on: tls_certificates_and_hostnames_components_schemas_uploaded_on.datetime({ offset: true }) }).partial().passthrough();
const tls_certificates_and_hostnames_components_schemas_certificate_response_single = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_schemas_certificateObject }).partial().passthrough());
const tls_certificates_and_hostnames_hostname_aop_single_response = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_hostname_certid_object }).partial().passthrough());
const tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_enabled = z.boolean();
const tls_certificates_and_hostnames_enabled_response = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({ enabled: tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_enabled }).partial().passthrough() }).partial().passthrough());
const zone_level_authenticated_origin_pulls_set_enablement_for_zone_Body = z.object({ enabled: tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_enabled }).passthrough();
const page_shield_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const page_shield_api_response_common = z.object({ errors: page_shield_messages, messages: page_shield_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const page_shield_api_response_single = page_shield_api_response_common.and(z.object({ result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]) }).partial().passthrough());
const page_shield_zone_settings_response_single = page_shield_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const page_shield_enabled = z.boolean();
const page_shield_updated_at = z.string();
const page_shield_use_cloudflare_reporting_endpoint = z.boolean();
const page_shield_use_connection_url_path = z.boolean();
const page_shield_get_zone_settings_response = z.object({ enabled: page_shield_enabled, updated_at: page_shield_updated_at, use_cloudflare_reporting_endpoint: page_shield_use_cloudflare_reporting_endpoint, use_connection_url_path: page_shield_use_connection_url_path }).partial().passthrough();
const page_shield_api_response_common_failure = z.object({ errors: page_shield_messages, messages: page_shield_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const page_shield_update_zone_settings_response = z.object({ enabled: page_shield_enabled, updated_at: page_shield_updated_at, use_cloudflare_reporting_endpoint: page_shield_use_cloudflare_reporting_endpoint, use_connection_url_path: page_shield_use_connection_url_path }).partial().passthrough();
const page_shield_result_info = z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough();
const page_shield_api_response_collection = page_shield_api_response_common.and(z.object({ result: z.array(z.unknown()).nullable(), result_info: page_shield_result_info }).partial().passthrough());
const page_shield_connection = z.object({ added_at: z.unknown(), domain_reported_malicious: z.unknown(), first_page_url: z.unknown(), first_seen_at: z.unknown(), host: z.unknown(), id: z.unknown(), last_seen_at: z.unknown(), page_urls: z.unknown(), url: z.unknown(), url_contains_cdn_cgi_path: z.unknown() }).partial().passthrough();
const page_shield_list_zone_connections_response = page_shield_api_response_collection.and(z.object({ result: z.array(page_shield_connection), result_info: page_shield_result_info }).partial().passthrough());
const page_shield_get_zone_connection_response = page_shield_connection;
const page_shield_pageshield_policy_action = z.enum(["allow", "log"]);
const page_shield_pageshield_policy_description = z.string();
const page_shield_pageshield_policy_enabled = z.boolean();
const page_shield_pageshield_policy_expression = z.string();
const page_shield_pageshield_policy_id = z.string();
const page_shield_pageshield_policy_value = z.string();
const page_shield_pageshield_policy = z.object({ action: page_shield_pageshield_policy_action, description: page_shield_pageshield_policy_description, enabled: page_shield_pageshield_policy_enabled, expression: page_shield_pageshield_policy_expression, id: page_shield_pageshield_policy_id, value: page_shield_pageshield_policy_value }).partial().passthrough();
const page_shield_list_zone_policies_response = page_shield_api_response_collection.and(z.object({ result: z.array(page_shield_pageshield_policy) }).partial().passthrough());
const page_shield_get_zone_policy_response = page_shield_pageshield_policy;
const page_shield_script = z.object({ added_at: z.unknown(), domain_reported_malicious: z.unknown(), fetched_at: z.unknown(), first_page_url: z.unknown(), first_seen_at: z.unknown(), hash: z.unknown(), host: z.unknown(), id: z.unknown(), js_integrity_score: z.unknown(), last_seen_at: z.unknown(), page_urls: z.unknown(), url: z.unknown(), url_contains_cdn_cgi_path: z.unknown() }).partial().passthrough();
const page_shield_list_zone_scripts_response = page_shield_api_response_collection.and(z.object({ result: z.array(page_shield_script), result_info: page_shield_result_info }).partial().passthrough());
const page_shield_fetched_at = z.string();
const page_shield_hash = z.string();
const page_shield_js_integrity_score = z.number();
const page_shield_version = z.object({ fetched_at: page_shield_fetched_at.nullable(), hash: page_shield_hash.min(64).max(64).nullable(), js_integrity_score: page_shield_js_integrity_score.int().gte(1).lte(99).nullable() }).partial().passthrough();
const page_shield_get_zone_script_response = page_shield_script.and(z.object({ versions: z.array(page_shield_version).nullable() }).partial().passthrough());
const zones_route = z.object({ modified_on: z.string().datetime({ offset: true }), name: z.unknown(), value: z.object({ type: z.unknown(), url: z.string() }).partial().passthrough() }).partial().passthrough();
const zones_actions = z.array(zones_route);
const zones_created_on = z.string();
const zones_schemas_identifier = z.string();
const zones_schemas_modified_on = z.string();
const zones_priority = z.number();
const zones_status = z.enum(["active", "disabled"]);
const zones_string_constraint = z.object({ operator: z.unknown().default("contains"), value: z.string() }).passthrough();
const zones_url_target = z.object({ constraint: zones_string_constraint.and(z.object({ value: z.string().regex(/^(https?:/ /) ? (([-a - zA - Z0 - 9 *] *\.) + [-a - zA - Z0 - 9]{ 2, 20})(: (8080 | 8443 | 443 | 80)) ? (/[\S]+)?$/) }).partial().passthrough()), target: z.unknown() }).partial().passthrough();
const zones_target = zones_url_target;
const zones_targets = z.array(zones_target);
const zones_page_rule = z.object({ actions: zones_actions, created_on: zones_created_on.datetime({ offset: true }), id: zones_schemas_identifier.max(32), modified_on: zones_schemas_modified_on.datetime({ offset: true }), priority: zones_priority.int().default(1), status: zones_status.default("disabled"), targets: zones_targets }).passthrough();
const zones_pagerule_response_collection = zones_schemas_api_response_common.and(z.object({ result: z.array(zones_page_rule) }).partial().passthrough());
const page_rules_create_a_page_rule_Body = z.object({ actions: zones_actions, priority: zones_priority.int().optional().default(1), status: zones_status.optional().default("disabled"), targets: zones_targets }).passthrough();
const zones_pagerule_response_single = zones_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const zones_settings = z.array(z.object({}).partial().passthrough());
const zones_pagerule_settings_response_collection = zones_schemas_api_response_common.and(z.object({ result: zones_settings }).partial().passthrough());
const zones_schemas_api_response_single_id = zones_schemas_api_response_common.and(z.object({ result: z.object({ id: zones_schemas_identifier.max(32) }).passthrough().nullable() }).partial().passthrough());
const page_rules_edit_a_page_rule_Body = z.object({ actions: zones_actions, priority: zones_priority.int().default(1), status: zones_status.default("disabled"), targets: zones_targets }).partial().passthrough();
const cache_purge_Tags = z.object({ tags: z.array(z.string()) }).partial().passthrough();
const cache_purge_Hosts = z.object({ hosts: z.array(z.string()) }).partial().passthrough();
const cache_purge_Prefixes = z.object({ prefixes: z.array(z.string()) }).partial().passthrough();
const cache_purge_Flex = z.union([cache_purge_Tags, cache_purge_Hosts, cache_purge_Prefixes]);
const cache_purge_Everything = z.object({ purge_everything: z.boolean() }).partial().passthrough();
const cache_purge_File = z.string();
const cache_purge_UrlAndHeaders = z.object({ headers: z.object({}).partial().passthrough(), url: z.string() }).partial().passthrough();
const cache_purge_Files = z.object({ files: z.array(z.union([cache_purge_File, cache_purge_UrlAndHeaders])) }).partial().passthrough();
const zone_purge_Body = z.union([cache_purge_Flex, cache_purge_Everything, cache_purge_Files]);
const cache_purge_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const cache_purge_api_response_common = z.object({ errors: cache_purge_messages, messages: cache_purge_messages, result: z.union([z.object({}).partial().passthrough(), z.array(z.unknown()), z.string()]), success: z.literal(true) }).passthrough();
const cache_purge_schemas_identifier = z.string();
const cache_purge_api_response_single_id = cache_purge_api_response_common.and(z.object({ result: z.object({ id: cache_purge_schemas_identifier.max(32) }).passthrough().nullable() }).partial().passthrough());
const cache_purge_api_response_common_failure = z.object({ errors: cache_purge_messages, messages: cache_purge_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const secondary_dns_force_result = z.string();
const secondary_dns_force_response = secondary_dns_api_response_single.and(z.object({ result: secondary_dns_force_result }).partial().passthrough());
const secondary_dns_identifier = z.unknown();
const secondary_dns_id_response = secondary_dns_api_response_single.and(z.object({ result: z.object({ id: secondary_dns_identifier }).partial().passthrough() }).partial().passthrough());
const secondary_dns_auto_refresh_seconds = z.number();
const secondary_dns_time = z.string();
const secondary_dns_name = z.string();
const secondary_dns_peers = z.array(z.unknown());
const secondary_dns_soa_serial = z.number();
const secondary_dns_single_response_incoming = secondary_dns_api_response_single.and(z.object({ result: z.object({ auto_refresh_seconds: secondary_dns_auto_refresh_seconds, checked_time: secondary_dns_time, created_time: secondary_dns_time, id: secondary_dns_identifier, modified_time: secondary_dns_time, name: secondary_dns_name, peers: secondary_dns_peers, soa_serial: secondary_dns_soa_serial }).partial().passthrough() }).partial().passthrough());
const secondary_dns_dns_secondary_secondary_zone = z.object({ auto_refresh_seconds: secondary_dns_auto_refresh_seconds, id: secondary_dns_identifier, name: secondary_dns_name, peers: secondary_dns_peers }).passthrough();
const secondary_dns_single_response_outgoing = secondary_dns_api_response_single.and(z.object({ result: z.object({ checked_time: secondary_dns_time, created_time: secondary_dns_time, id: secondary_dns_identifier, last_transferred_time: secondary_dns_time, name: secondary_dns_name, peers: secondary_dns_peers, soa_serial: secondary_dns_soa_serial }).partial().passthrough() }).partial().passthrough());
const secondary_dns_single_request_outgoing = z.object({ id: secondary_dns_identifier, name: secondary_dns_name, peers: secondary_dns_peers }).passthrough();
const secondary_dns_disable_transfer_result = z.string();
const secondary_dns_disable_transfer_response = secondary_dns_api_response_single.and(z.object({ result: secondary_dns_disable_transfer_result }).partial().passthrough());
const secondary_dns_enable_transfer_result = z.string();
const secondary_dns_enable_transfer_response = secondary_dns_api_response_single.and(z.object({ result: secondary_dns_enable_transfer_result }).partial().passthrough());
const secondary_dns_schemas_force_result = z.string();
const secondary_dns_schemas_force_response = secondary_dns_api_response_single.and(z.object({ result: secondary_dns_schemas_force_result }).partial().passthrough());
const zones_base = z.object({ editable: z.union([z.literal(true), z.literal(false)]).optional().default(true), id: z.string(), modified_on: z.string().datetime({ offset: true }).nullish(), value: z.unknown() }).passthrough();
const zones_0rtt_value = z.enum(["on", "off"]);
const zones_0rtt = zones_base.and(z.object({ id: z.unknown(), value: zones_0rtt_value.default("off") }).partial().passthrough());
const zones_advanced_ddos_value = z.enum(["on", "off"]);
const zones_advanced_ddos = zones_base.and(z.object({ id: z.unknown(), value: zones_advanced_ddos_value.default("off") }).partial().passthrough());
const zones_always_online_value = z.enum(["on", "off"]);
const zones_always_online = zones_base.and(z.object({ id: z.unknown(), value: zones_always_online_value.default("on") }).partial().passthrough());
const zones_always_use_https_value = z.enum(["on", "off"]);
const zones_always_use_https = zones_base.and(z.object({ id: z.unknown(), value: zones_always_use_https_value.default("off") }).partial().passthrough());
const zones_automatic_https_rewrites_value = z.enum(["on", "off"]);
const zones_automatic_https_rewrites = zones_base.and(z.object({ id: z.unknown(), value: zones_automatic_https_rewrites_value.default("on") }).partial().passthrough());
const zones_brotli_value = z.enum(["off", "on"]);
const zones_brotli = zones_base.and(z.object({ id: z.unknown(), value: zones_brotli_value.default("off") }).partial().passthrough());
const zones_browser_cache_ttl_value = z.union([z.literal(0), z.literal(30), z.literal(60), z.literal(120), z.literal(300), z.literal(1200), z.literal(1800), z.literal(3600), z.literal(7200), z.literal(10800), z.literal(14400), z.literal(18000), z.literal(28800), z.literal(43200), z.literal(57600), z.literal(72000), z.literal(86400), z.literal(172800), z.literal(259200), z.literal(345600), z.literal(432000), z.literal(691200), z.literal(1382400), z.literal(2073600), z.literal(2678400), z.literal(5356800), z.literal(16070400), z.literal(31536000)]);
const zones_browser_cache_ttl = zones_base.and(z.object({ id: z.unknown(), value: zones_browser_cache_ttl_value.default(14400) }).partial().passthrough());
const zones_browser_check_value = z.enum(["on", "off"]);
const zones_browser_check = zones_base.and(z.object({ id: z.unknown(), value: zones_browser_check_value.default("on") }).partial().passthrough());
const zones_cache_level_value = z.enum(["aggressive", "basic", "simplified"]);
const zones_cache_level = zones_base.and(z.object({ id: z.unknown(), value: zones_cache_level_value.default("aggressive") }).partial().passthrough());
const zones_challenge_ttl_value = z.union([z.literal(300), z.literal(900), z.literal(1800), z.literal(2700), z.literal(3600), z.literal(7200), z.literal(10800), z.literal(14400), z.literal(28800), z.literal(57600), z.literal(86400), z.literal(604800), z.literal(2592000), z.literal(31536000)]);
const zones_challenge_ttl = zones_base.and(z.object({ id: z.unknown(), value: zones_challenge_ttl_value.default(1800) }).partial().passthrough());
const zones_ciphers_value = z.array(z.string());
const zones_ciphers = zones_base.and(z.object({ id: z.unknown(), value: zones_ciphers_value.default([]) }).partial().passthrough());
const zones_cname_flattening_value = z.enum(["flatten_at_root", "flatten_all"]);
const zones_cname_flattening = zones_base.and(z.object({ id: z.unknown(), value: zones_cname_flattening_value.default("flatten_at_root") }).partial().passthrough());
const zones_development_mode_value = z.enum(["on", "off"]);
const zones_development_mode = zones_base.and(z.object({ id: z.unknown(), time_remaining: z.number(), value: zones_development_mode_value.default("off") }).partial().passthrough());
const zones_early_hints_value = z.enum(["on", "off"]);
const zones_early_hints = zones_base.and(z.object({ id: z.unknown(), value: zones_early_hints_value.default("off") }).partial().passthrough());
const zones_edge_cache_ttl_value = z.union([z.literal(30), z.literal(60), z.literal(300), z.literal(1200), z.literal(1800), z.literal(3600), z.literal(7200), z.literal(10800), z.literal(14400), z.literal(18000), z.literal(28800), z.literal(43200), z.literal(57600), z.literal(72000), z.literal(86400), z.literal(172800), z.literal(259200), z.literal(345600), z.literal(432000), z.literal(518400), z.literal(604800)]);
const zones_edge_cache_ttl = zones_base.and(z.object({ id: z.unknown(), value: zones_edge_cache_ttl_value.default(7200) }).partial().passthrough());
const zones_email_obfuscation_value = z.enum(["on", "off"]);
const zones_email_obfuscation = zones_base.and(z.object({ id: z.unknown(), value: zones_email_obfuscation_value.default("on") }).partial().passthrough());
const zones_h2_prioritization_value = z.enum(["on", "off", "custom"]);
const zones_h2_prioritization = zones_base.and(z.object({ id: z.unknown(), value: zones_h2_prioritization_value.default("off") }).partial().passthrough());
const zones_hotlink_protection_value = z.enum(["on", "off"]);
const zones_hotlink_protection = zones_base.and(z.object({ id: z.unknown(), value: zones_hotlink_protection_value.default("off") }).partial().passthrough());
const zones_http2_value = z.enum(["on", "off"]);
const zones_http2 = zones_base.and(z.object({ id: z.unknown(), value: zones_http2_value.default("off") }).partial().passthrough());
const zones_http3_value = z.enum(["on", "off"]);
const zones_http3 = zones_base.and(z.object({ id: z.unknown(), value: zones_http3_value.default("off") }).partial().passthrough());
const zones_image_resizing_value = z.enum(["on", "off", "open"]);
const zones_image_resizing = zones_base.and(z.object({ id: z.unknown(), value: zones_image_resizing_value.default("off") }).partial().passthrough());
const zones_ip_geolocation_value = z.enum(["on", "off"]);
const zones_ip_geolocation = zones_base.and(z.object({ id: z.unknown(), value: zones_ip_geolocation_value.default("on") }).partial().passthrough());
const zones_ipv6_value = z.enum(["off", "on"]);
const zones_ipv6 = zones_base.and(z.object({ id: z.unknown(), value: zones_ipv6_value.default("off") }).partial().passthrough());
const zones_max_upload_value = z.union([z.literal(100), z.literal(200), z.literal(500)]);
const zones_max_upload = zones_base.and(z.object({ id: z.unknown(), value: zones_max_upload_value.default(100) }).partial().passthrough());
const zones_min_tls_version_value = z.enum(["1.0", "1.1", "1.2", "1.3"]);
const zones_min_tls_version = zones_base.and(z.object({ id: z.unknown(), value: zones_min_tls_version_value.default("1.0") }).partial().passthrough());
const zones_minify_value = z.object({ css: z.unknown().default("off"), html: z.unknown().default("off"), js: z.unknown().default("off") }).partial().passthrough();
const zones_minify = zones_base.and(z.object({ id: z.unknown(), value: zones_minify_value.default({ "css": "off", "html": "off", "js": "off" }) }).partial().passthrough());
const zones_mirage_value = z.enum(["on", "off"]);
const zones_mirage = zones_base.and(z.object({ id: z.unknown(), value: zones_mirage_value.default("off") }).partial().passthrough());
const zones_mobile_redirect_value = z.object({ mobile_subdomain: z.string().min(1).nullable(), status: z.unknown().default("off"), strip_uri: z.boolean() }).partial().passthrough();
const zones_mobile_redirect = zones_base.and(z.object({ id: z.unknown(), value: zones_mobile_redirect_value.default({ "mobile_subdomain": null, "status": "off", "strip_uri": false }) }).partial().passthrough());
const zones_nel_value = z.object({ enabled: z.boolean() }).partial().passthrough();
const zones_nel = zones_base.and(z.object({ id: z.unknown(), value: zones_nel_value.default({ "enabled": false }) }).partial().passthrough());
const zones_opportunistic_encryption_value = z.enum(["on", "off"]);
const zones_opportunistic_encryption = zones_base.and(z.object({ id: z.unknown(), value: zones_opportunistic_encryption_value.default("on") }).partial().passthrough());
const zones_opportunistic_onion_value = z.enum(["on", "off"]);
const zones_opportunistic_onion = zones_base.and(z.object({ id: z.unknown(), value: zones_opportunistic_onion_value.default("off") }).partial().passthrough());
const zones_orange_to_orange_value = z.enum(["on", "off"]);
const zones_orange_to_orange = zones_base.and(z.object({ id: z.unknown(), value: zones_orange_to_orange_value.default("on") }).partial().passthrough());
const zones_origin_error_page_pass_thru_value = z.enum(["on", "off"]);
const zones_origin_error_page_pass_thru = zones_base.and(z.object({ id: z.unknown(), value: zones_origin_error_page_pass_thru_value.default("off") }).partial().passthrough());
const zones_polish_value = z.enum(["off", "lossless", "lossy"]);
const zones_polish = zones_base.and(z.object({ id: z.unknown(), value: zones_polish_value.default("off") }).partial().passthrough());
const zones_prefetch_preload_value = z.enum(["on", "off"]);
const zones_prefetch_preload = zones_base.and(z.object({ id: z.unknown(), value: zones_prefetch_preload_value.default("off") }).partial().passthrough());
const zones_proxy_read_timeout_value = z.number();
const zones_proxy_read_timeout = zones_base.and(z.object({ id: z.unknown(), value: zones_proxy_read_timeout_value.default(100) }).partial().passthrough());
const zones_pseudo_ipv4_value = z.enum(["off", "add_header", "overwrite_header"]);
const zones_pseudo_ipv4 = zones_base.and(z.object({ id: z.unknown().default("pseudo_ipv4"), value: zones_pseudo_ipv4_value.default("off") }).partial().passthrough());
const zones_response_buffering_value = z.enum(["on", "off"]);
const zones_response_buffering = zones_base.and(z.object({ id: z.unknown(), value: zones_response_buffering_value.default("off") }).partial().passthrough());
const zones_rocket_loader_value = z.enum(["on", "off"]);
const zones_rocket_loader = zones_base.and(z.object({ id: z.unknown(), value: zones_rocket_loader_value.default("off") }).partial().passthrough());
const zones_automatic_platform_optimization = z.object({ cache_by_device_type: z.boolean(), cf: z.boolean(), enabled: z.boolean(), hostnames: z.array(z.string()), wordpress: z.boolean(), wp_plugin: z.boolean() }).passthrough();
const zones_schemas_automatic_platform_optimization = zones_base.and(z.object({ id: z.unknown(), value: zones_automatic_platform_optimization }).partial().passthrough());
const zones_security_header_value = z.object({ strict_transport_security: z.object({ enabled: z.boolean(), include_subdomains: z.boolean(), max_age: z.number(), nosniff: z.boolean() }).partial().passthrough() }).partial().passthrough();
const zones_security_header = zones_base.and(z.object({ id: z.unknown(), value: zones_security_header_value.default({ "strict_transport_security": { "enabled": true, "include_subdomains": true, "max_age": 86400, "nosniff": true } }) }).partial().passthrough());
const zones_security_level_value = z.enum(["off", "essentially_off", "low", "medium", "high", "under_attack"]);
const zones_security_level = zones_base.and(z.object({ id: z.unknown(), value: zones_security_level_value.default("medium") }).partial().passthrough());
const zones_server_side_exclude_value = z.enum(["on", "off"]);
const zones_server_side_exclude = zones_base.and(z.object({ id: z.unknown(), value: zones_server_side_exclude_value.default("on") }).partial().passthrough());
const zones_sha1_support_value = z.enum(["off", "on"]);
const zones_sha1_support = zones_base.and(z.object({ id: z.unknown(), value: zones_sha1_support_value.default("off") }).partial().passthrough());
const zones_sort_query_string_for_cache_value = z.enum(["on", "off"]);
const zones_sort_query_string_for_cache = zones_base.and(z.object({ id: z.unknown(), value: zones_sort_query_string_for_cache_value.default("off") }).partial().passthrough());
const zones_ssl_value = z.enum(["off", "flexible", "full", "strict"]);
const zones_ssl = zones_base.and(z.object({ id: z.unknown(), value: zones_ssl_value.default("off") }).partial().passthrough());
const zones_ssl_recommender_enabled = z.boolean();
const zones_ssl_recommender = z.object({ enabled: zones_ssl_recommender_enabled, id: z.unknown() }).partial().passthrough();
const zones_tls_1_2_only_value = z.enum(["off", "on"]);
const zones_tls_1_2_only = zones_base.and(z.object({ id: z.unknown(), value: zones_tls_1_2_only_value.default("off") }).partial().passthrough());
const zones_tls_1_3_value = z.enum(["on", "off", "zrt"]);
const zones_tls_1_3 = zones_base.and(z.object({ id: z.unknown(), value: zones_tls_1_3_value.default("off") }).partial().passthrough());
const zones_tls_client_auth_value = z.enum(["on", "off"]);
const zones_tls_client_auth = zones_base.and(z.object({ id: z.unknown(), value: zones_tls_client_auth_value.default("on") }).partial().passthrough());
const zones_true_client_ip_header_value = z.enum(["on", "off"]);
const zones_true_client_ip_header = zones_base.and(z.object({ id: z.unknown(), value: zones_true_client_ip_header_value.default("off") }).partial().passthrough());
const zones_waf_value = z.enum(["on", "off"]);
const zones_waf = zones_base.and(z.object({ id: z.unknown(), value: zones_waf_value.default("off") }).partial().passthrough());
const zones_webp_value = z.enum(["off", "on"]);
const zones_webp = zones_base.and(z.object({ id: z.unknown(), value: zones_webp_value.default("off") }).partial().passthrough());
const zones_websockets_value = z.enum(["off", "on"]);
const zones_websockets = zones_base.and(z.object({ id: z.unknown(), value: zones_websockets_value.default("off") }).partial().passthrough());
const zones_zone_settings_response_collection = zones_api_response_common.and(z.object({ result: z.array(z.union([zones_0rtt, zones_advanced_ddos, zones_always_online, zones_always_use_https, zones_automatic_https_rewrites, zones_brotli, zones_browser_cache_ttl, zones_browser_check, zones_cache_level, zones_challenge_ttl, zones_ciphers, zones_cname_flattening, zones_development_mode, zones_early_hints, zones_edge_cache_ttl, zones_email_obfuscation, zones_h2_prioritization, zones_hotlink_protection, zones_http2, zones_http3, zones_image_resizing, zones_ip_geolocation, zones_ipv6, zones_max_upload, zones_min_tls_version, zones_minify, zones_mirage, zones_mobile_redirect, zones_nel, zones_opportunistic_encryption, zones_opportunistic_onion, zones_orange_to_orange, zones_origin_error_page_pass_thru, zones_polish, zones_prefetch_preload, zones_proxy_read_timeout, zones_pseudo_ipv4, zones_response_buffering, zones_rocket_loader, zones_schemas_automatic_platform_optimization, zones_security_header, zones_security_level, zones_server_side_exclude, zones_sha1_support, zones_sort_query_string_for_cache, zones_ssl, zones_ssl_recommender, zones_tls_1_2_only, zones_tls_1_3, zones_tls_client_auth, zones_true_client_ip_header, zones_waf, zones_webp, zones_websockets])) }).partial().passthrough());
const zones_setting = z.union([zones_0rtt, zones_advanced_ddos, zones_always_online, zones_always_use_https, zones_automatic_https_rewrites, zones_brotli, zones_browser_cache_ttl, zones_browser_check, zones_cache_level, zones_challenge_ttl, zones_ciphers, zones_cname_flattening, zones_development_mode, zones_early_hints, zones_edge_cache_ttl, zones_email_obfuscation, zones_h2_prioritization, zones_hotlink_protection, zones_http2, zones_http3, zones_image_resizing, zones_ip_geolocation, zones_ipv6, zones_max_upload, zones_min_tls_version, zones_minify, zones_mirage, zones_mobile_redirect, zones_nel, zones_opportunistic_encryption, zones_opportunistic_onion, zones_orange_to_orange, zones_origin_error_page_pass_thru, zones_polish, zones_prefetch_preload, zones_proxy_read_timeout, zones_pseudo_ipv4, zones_response_buffering, zones_rocket_loader, zones_schemas_automatic_platform_optimization, zones_security_header, zones_security_level, zones_server_side_exclude, zones_sha1_support, zones_sort_query_string_for_cache, zones_ssl, zones_ssl_recommender, zones_tls_1_2_only, zones_tls_1_3, zones_tls_client_auth, zones_true_client_ip_header, zones_waf, zones_webp, zones_websockets]);
const zones_zone_settings_response_single = zones_api_response_common.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const speed_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const speed_api_response_common = z.object({ errors: speed_messages, messages: speed_messages, success: z.boolean() }).passthrough();
const speed_base = z.object({ editable: z.union([z.literal(true), z.literal(false)]).optional().default(true), id: z.string(), modified_on: z.string().datetime({ offset: true }).nullish(), value: z.unknown() }).passthrough();
const speed_cloudflare_fonts_value = z.enum(["on", "off"]);
const speed_cloudflare_fonts = speed_base.and(z.object({ id: z.unknown(), value: speed_cloudflare_fonts_value.default("off") }).partial().passthrough());
const speed_api_response_common_failure = z.object({ errors: speed_messages, messages: speed_messages, result: z.object({}).partial().passthrough().nullable(), success: z.boolean() }).passthrough();
const cache_origin_max_http_version = cache_base.and(z.object({ id: z.unknown() }).partial().passthrough());
const cache_origin_max_http_version_value = z.enum(["2", "1"]);
const cache_origin_max_http_version_response_value = z.object({ result: cache_origin_max_http_version.and(z.object({ value: cache_origin_max_http_version_value }).passthrough()) }).partial().passthrough();
const zaraz_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const zaraz_api_response_common = z.object({ errors: zaraz_messages, messages: zaraz_messages, success: z.boolean() }).passthrough();
const zaraz_load_rule = z.object({ id: z.string(), match: z.string(), op: z.enum(["CONTAINS", "EQUALS", "STARTS_WITH", "ENDS_WITH", "MATCH_REGEX", "NOT_MATCH_REGEX", "GREATER_THAN", "GREATER_THAN_OR_EQUAL", "LESS_THAN", "LESS_THAN_OR_EQUAL"]), value: z.string() }).passthrough();
const zaraz_click_listener_rule = z.object({ action: z.literal("clickListener"), id: z.string(), settings: z.object({ selector: z.string(), type: z.enum(["xpath", "css"]), waitForTags: z.number().int().gte(0) }).passthrough() }).passthrough();
const zaraz_timer_rule = z.object({ action: z.literal("timer"), id: z.string(), settings: z.object({ interval: z.number().int().gte(50), limit: z.number().int().gte(0) }).passthrough() }).passthrough();
const zaraz_form_submission_rule = z.object({ action: z.literal("formSubmission"), id: z.string(), settings: z.object({ selector: z.string(), validate: z.boolean() }).passthrough() }).passthrough();
const zaraz_variable_match_rule = z.object({ action: z.literal("variableMatch"), id: z.string(), settings: z.object({ match: z.string(), variable: z.string() }).passthrough() }).passthrough();
const zaraz_scroll_depth_rule = z.object({ action: z.literal("scrollDepth"), id: z.string(), settings: z.object({ positions: z.string() }).passthrough() }).passthrough();
const zaraz_element_visibility_rule = z.object({ action: z.literal("elementVisibility"), id: z.string(), settings: z.object({ selector: z.string() }).passthrough() }).passthrough();
const zaraz_zaraz_config_base = z.object({ consent: z.object({ buttonTextTranslations: z.object({ accept_all: z.record(z.string()), confirm_my_choices: z.record(z.string()), reject_all: z.record(z.string()) }).passthrough().optional(), companyEmail: z.string().optional(), companyName: z.string().optional(), companyStreetAddress: z.string().optional(), consentModalIntroHTML: z.string().optional(), consentModalIntroHTMLWithTranslations: z.record(z.string()).optional(), cookieName: z.string().optional(), customCSS: z.string().optional(), customIntroDisclaimerDismissed: z.boolean().optional(), defaultLanguage: z.string().optional(), enabled: z.boolean(), hideModal: z.boolean().optional(), purposes: z.record(z.object({ description: z.string(), name: z.string() }).passthrough()).optional(), purposesWithTranslations: z.record(z.object({ description: z.record(z.string()), name: z.record(z.string()), order: z.number().int() }).passthrough()).optional() }).passthrough().optional(), dataLayer: z.boolean(), debugKey: z.string(), historyChange: z.boolean().optional(), settings: z.object({ autoInjectScript: z.boolean(), contextEnricher: z.object({ escapedWorkerName: z.string(), workerTag: z.string() }).passthrough().optional(), cookieDomain: z.string().optional(), ecommerce: z.boolean().optional(), eventsApiPath: z.string().optional(), hideExternalReferer: z.boolean().optional(), hideIPAddress: z.boolean().optional(), hideQueryParams: z.boolean().optional(), hideUserAgent: z.boolean().optional(), initPath: z.string().optional(), injectIframes: z.boolean().optional(), mcRootPath: z.string().optional(), scriptPath: z.string().optional(), trackPath: z.string().optional() }).passthrough(), triggers: z.record(z.object({ description: z.string().optional(), excludeRules: z.array(z.union([zaraz_load_rule, zaraz_click_listener_rule, zaraz_timer_rule, zaraz_form_submission_rule, zaraz_variable_match_rule, zaraz_scroll_depth_rule, zaraz_element_visibility_rule])), loadRules: z.array(z.union([zaraz_load_rule, zaraz_click_listener_rule, zaraz_timer_rule, zaraz_form_submission_rule, zaraz_variable_match_rule, zaraz_scroll_depth_rule, zaraz_element_visibility_rule])), name: z.string(), system: z.literal("pageload").optional() }).passthrough()), variables: z.record(z.union([z.object({ name: z.string(), type: z.enum(["string", "secret"]), value: z.string() }).passthrough(), z.object({ name: z.string(), type: z.literal("worker"), value: z.object({ escapedWorkerName: z.string(), workerTag: z.string() }).passthrough() }).passthrough()])), zarazVersion: z.number().int() }).passthrough();
const zaraz_base_tool = z.object({ blockingTriggers: z.array(z.string()), defaultFields: z.record(z.union([z.string(), z.boolean()])), defaultPurpose: z.string().optional(), enabled: z.boolean(), name: z.string() }).passthrough();
const zaraz_base_mc = zaraz_base_tool.and(z.object({ actions: z.record(z.object({ actionType: z.string(), blockingTriggers: z.array(z.string()), data: z.object({}).partial().passthrough(), firingTriggers: z.array(z.string()).min(1) }).passthrough()).optional(), component: z.string(), neoEvents: z.array(z.object({ actionType: z.string(), blockingTriggers: z.array(z.string()), data: z.object({}).partial().passthrough(), firingTriggers: z.array(z.string()).min(1) }).passthrough()).optional(), permissions: z.array(z.string()), settings: z.record(z.union([z.string(), z.boolean()])) }).passthrough());
const zaraz_managed_component = zaraz_base_mc.and(z.object({ type: z.literal("component") }).passthrough());
const zaraz_custom_managed_component = zaraz_base_mc.and(z.object({ type: z.literal("custom-mc"), worker: z.object({ escapedWorkerName: z.string(), workerTag: z.string() }).passthrough() }).passthrough());
const zaraz_zaraz_config_return = zaraz_zaraz_config_base.and(z.object({ tools: z.record(z.union([zaraz_managed_component, zaraz_custom_managed_component])) }).partial().passthrough());
const zaraz_zaraz_config_response = zaraz_api_response_common.and(z.object({ result: zaraz_zaraz_config_return }).partial().passthrough());
const zaraz_api_response_common_failure = z.object({ errors: zaraz_messages, messages: zaraz_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const zaraz_legacy_tool = zaraz_base_tool.and(z.object({ library: z.string(), neoEvents: z.array(z.object({ blockingTriggers: z.array(z.string()), data: z.object({}).partial().passthrough(), firingTriggers: z.array(z.string()).min(1) }).passthrough()), type: z.literal("library") }).passthrough());
const zaraz_zaraz_config_body = zaraz_zaraz_config_base.and(z.object({ tools: z.record(z.union([zaraz_legacy_tool, zaraz_managed_component, zaraz_custom_managed_component])) }).partial().passthrough());
const zaraz_zaraz_config_row_base = z.object({ createdAt: z.string().datetime({ offset: true }), id: z.number().int(), updatedAt: z.string().datetime({ offset: true }), userId: z.string() }).passthrough();
const zaraz_zaraz_history_response = zaraz_api_response_common.and(z.object({ result: z.array(zaraz_zaraz_config_row_base.and(z.object({ description: z.string() }).passthrough())) }).partial().passthrough());
const zaraz_zaraz_config_history_response = zaraz_api_response_common.and(z.object({ result: z.record(zaraz_zaraz_config_row_base.and(z.object({ config: zaraz_zaraz_config_return }).passthrough())) }).partial().passthrough());
const zaraz_zaraz_workflow = z.enum(["realtime", "preview"]);
const zaraz_zaraz_workflow_response = zaraz_api_response_common.and(z.object({ result: zaraz_zaraz_workflow }).partial().passthrough());
const observatory_messages = z.array(z.object({ code: z.number().int().gte(1000), message: z.string() }).passthrough());
const observatory_api_response_common = z.object({ errors: observatory_messages, messages: observatory_messages, success: z.boolean() }).passthrough();
const observatory_api_response_single = observatory_api_response_common;
const observatory_region = z.enum(["asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"]);
const observatory_labeled_region = z.object({ label: z.string(), value: observatory_region }).partial().passthrough();
const observatory_availabilities = z.object({ quota: z.object({ plan: z.string(), quotasPerPlan: z.record(z.number()), remainingSchedules: z.number(), remainingTests: z.number(), scheduleQuotasPerPlan: z.record(z.number()) }).partial().passthrough(), regions: z.array(observatory_labeled_region), regionsPerPlan: z.record(z.array(observatory_labeled_region)) }).partial().passthrough();
const observatory_availabilities_response = observatory_api_response_single.and(z.object({ result: observatory_availabilities }).partial().passthrough());
const observatory_api_response_common_failure = z.object({ errors: observatory_messages, messages: observatory_messages, result: z.object({}).partial().passthrough().nullable(), success: z.literal(false) }).passthrough();
const observatory_api_response_collection = observatory_api_response_common;
const observatory_schedule_frequency = z.enum(["DAILY", "WEEKLY"]);
const observatory_timestamp = z.string();
const observatory_device_type = z.enum(["DESKTOP", "MOBILE"]);
const observatory_lighthouse_error_code = z.enum(["NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN"]);
const observatory_lighthouse_state = z.enum(["RUNNING", "COMPLETE", "FAILED"]);
const observatory_lighthouse_report = z.object({ cls: z.number(), deviceType: observatory_device_type, error: z.object({ code: observatory_lighthouse_error_code, detail: z.string(), finalDisplayedUrl: z.string() }).partial().passthrough(), fcp: z.number(), jsonReportUrl: z.string(), lcp: z.number(), performanceScore: z.number(), si: z.number(), state: observatory_lighthouse_state, tbt: z.number(), ttfb: z.number(), tti: z.number() }).partial().passthrough();
const observatory_uuid = z.string();
const observatory_url = z.string();
const observatory_page_test = z.object({ date: observatory_timestamp.datetime({ offset: true }), desktopReport: observatory_lighthouse_report, id: observatory_uuid.max(36), mobileReport: observatory_lighthouse_report, region: observatory_labeled_region, scheduleFrequency: observatory_schedule_frequency, url: observatory_url }).partial().passthrough();
const observatory_pages_response_collection = observatory_api_response_collection.and(z.object({ result: z.array(z.object({ region: observatory_labeled_region, scheduleFrequency: observatory_schedule_frequency, tests: z.array(observatory_page_test), url: observatory_url }).partial().passthrough()) }).partial().passthrough());
const observatory_count_response = observatory_api_response_single.and(z.object({ result: z.object({ count: z.number() }).partial().passthrough() }).partial().passthrough());
const observatory_result_info = z.object({ count: z.number().int(), page: z.number().int(), per_page: z.number().int(), total_count: z.number().int() }).partial().passthrough();
const observatory_page_test_response_collection = observatory_api_response_collection.and(z.object({ result: z.array(observatory_page_test) }).partial().passthrough()).and(z.object({ result_info: observatory_result_info }).partial().passthrough());
const speed_create_test_Body = z.object({ region: observatory_region }).partial().passthrough();
const observatory_page_test_response_single = observatory_api_response_single.and(z.object({ result: observatory_page_test }).partial().passthrough());
const observatory_trend = z.object({ cls: z.array(z.number()), fcp: z.array(z.number()), lcp: z.array(z.number()), performanceScore: z.array(z.number()), si: z.array(z.number()), tbt: z.array(z.number()), ttfb: z.array(z.number()), tti: z.array(z.number()) }).partial().passthrough();
const observatory_trend_response = observatory_api_response_single.and(z.object({ result: observatory_trend }).partial().passthrough());
const observatory_schedule = z.object({ frequency: observatory_schedule_frequency, region: observatory_region, url: observatory_url }).partial().passthrough();
const observatory_schedule_response_single = observatory_api_response_single.and(z.object({ result: observatory_schedule }).partial().passthrough());
const observatory_create_schedule_response = observatory_api_response_single.and(z.object({ result: z.object({ schedule: observatory_schedule, test: observatory_page_test }).partial().passthrough() }).partial().passthrough());
const analyze_certificate_analyze_certificate_Body = z.object({ bundle_method: tls_certificates_and_hostnames_bundle_method.default("ubiquitous"), certificate: tls_certificates_and_hostnames_certificate }).partial().passthrough();
const tls_certificates_and_hostnames_certificate_analyze_response = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_certificate_pack_response_collection = tls_certificates_and_hostnames_api_response_collection.and(z.object({ result: z.array(z.object({}).partial().passthrough()) }).partial().passthrough());
const tls_certificates_and_hostnames_schemas_certificate_authority = z.enum(["google", "lets_encrypt"]);
const tls_certificates_and_hostnames_cloudflare_branding = z.boolean();
const tls_certificates_and_hostnames_schemas_hosts = z.array(z.string());
const tls_certificates_and_hostnames_advanced_type = z.literal("advanced");
const tls_certificates_and_hostnames_validation_method = z.enum(["txt", "http", "email"]);
const tls_certificates_and_hostnames_validity_days = z.union([z.literal(14), z.literal(30), z.literal(90), z.literal(365)]);
const certificate_packs_order_advanced_certificate_manager_certificate_pack_Body = z.object({ certificate_authority: tls_certificates_and_hostnames_schemas_certificate_authority, cloudflare_branding: tls_certificates_and_hostnames_cloudflare_branding.optional(), hosts: tls_certificates_and_hostnames_schemas_hosts, type: tls_certificates_and_hostnames_advanced_type, validation_method: tls_certificates_and_hostnames_validation_method, validity_days: tls_certificates_and_hostnames_validity_days }).passthrough();
const tls_certificates_and_hostnames_certificate_packs_components_schemas_status = z.enum(["initializing", "pending_validation", "deleted", "pending_issuance", "pending_deployment", "pending_deletion", "pending_expiration", "expired", "active", "initializing_timed_out", "validation_timed_out", "issuance_timed_out", "deployment_timed_out", "deletion_timed_out", "pending_cleanup", "staging_deployment", "staging_active", "deactivating", "inactive", "backup_issued", "holding_deployment"]);
const tls_certificates_and_hostnames_advanced_certificate_pack_response_single = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({ certificate_authority: tls_certificates_and_hostnames_schemas_certificate_authority, cloudflare_branding: tls_certificates_and_hostnames_cloudflare_branding, hosts: tls_certificates_and_hostnames_schemas_hosts, id: tls_certificates_and_hostnames_identifier.max(32), status: tls_certificates_and_hostnames_certificate_packs_components_schemas_status, type: tls_certificates_and_hostnames_advanced_type, validation_method: tls_certificates_and_hostnames_validation_method, validity_days: tls_certificates_and_hostnames_validity_days }).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_quota = z.object({ allocated: z.number().int(), used: z.number().int() }).partial().passthrough();
const tls_certificates_and_hostnames_certificate_pack_quota_response = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({ advanced: tls_certificates_and_hostnames_quota }).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_delete_advanced_certificate_pack_response_single = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({ id: tls_certificates_and_hostnames_identifier.max(32) }).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_certificate_pack_response_single = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());
const tls_certificates_and_hostnames_schemas_enabled = z.boolean();
const tls_certificates_and_hostnames_universal = z.object({ enabled: tls_certificates_and_hostnames_schemas_enabled }).partial().passthrough();
const tls_certificates_and_hostnames_ssl_universal_settings_response = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: tls_certificates_and_hostnames_universal }).partial().passthrough());
const tls_certificates_and_hostnames_brand_check = z.boolean();
const tls_certificates_and_hostnames_cert_pack_uuid = z.string();
const tls_certificates_and_hostnames_certificate_status = z.enum(["initializing", "authorizing", "active", "expired", "issuing", "timing_out", "pending_deployment"]);
const tls_certificates_and_hostnames_schemas_signature = z.enum(["ECDSAWithSHA256", "SHA1WithRSA", "SHA256WithRSA"]);
const tls_certificates_and_hostnames_schemas_validation_method = z.enum(["http", "cname", "txt"]);
const tls_certificates_and_hostnames_verification_info = z.object({ record_name: z.enum(["record_name", "http_url", "cname", "txt_name"]).url(), record_target: z.enum(["record_value", "http_body", "cname_target", "txt_value"]).url() }).partial().passthrough();
const tls_certificates_and_hostnames_verification_status = z.boolean();
const tls_certificates_and_hostnames_verification_type = z.enum(["cname", "meta tag"]);
const tls_certificates_and_hostnames_verification = z.object({ brand_check: tls_certificates_and_hostnames_brand_check.optional(), cert_pack_uuid: tls_certificates_and_hostnames_cert_pack_uuid.optional(), certificate_status: tls_certificates_and_hostnames_certificate_status, signature: tls_certificates_and_hostnames_schemas_signature.optional(), validation_method: tls_certificates_and_hostnames_schemas_validation_method.optional(), verification_info: tls_certificates_and_hostnames_verification_info.optional(), verification_status: tls_certificates_and_hostnames_verification_status.optional(), verification_type: tls_certificates_and_hostnames_verification_type.optional() }).passthrough();
const tls_certificates_and_hostnames_ssl_verification_response_collection = z.object({ result: z.array(tls_certificates_and_hostnames_verification) }).partial().passthrough();
const tls_certificates_and_hostnames_validation_method_definition = z.enum(["http", "cname", "txt", "email"]);
const tls_certificates_and_hostnames_components_schemas_validation_method = z.object({ validation_method: tls_certificates_and_hostnames_validation_method_definition }).passthrough();
const tls_certificates_and_hostnames_validation_method_components_schemas_status = z.string();
const tls_certificates_and_hostnames_ssl_validation_method_response_collection = tls_certificates_and_hostnames_api_response_single.and(z.object({ result: z.object({ status: tls_certificates_and_hostnames_validation_method_components_schemas_status, validation_method: tls_certificates_and_hostnames_validation_method_definition }).partial().passthrough() }).partial().passthrough());
const rulesets_scope = z.string();
const rulesets_type = z.string();
const rulesets_schemas_response_model = z.object({ scope: rulesets_scope, type: rulesets_type }).partial().passthrough();
const rulesets_schemas_request_model = z.object({ scope: rulesets_scope, type: rulesets_type }).partial().passthrough();
const workers_pattern = z.string();
const workers_script_name = z.string();
const workers_routes = z.object({ id: workers_identifier.max(32), pattern: workers_pattern, script: workers_script_name.regex(/^[a-z0-9_][a-z0-9-_]*$/) }).passthrough();
const workers_route_response_collection = workers_api_response_common.and(z.object({ result: z.array(workers_routes) }).partial().passthrough());
const workers_route_no_id = z.object({ pattern: workers_pattern, script: workers_script_name.regex(/^[a-z0-9_][a-z0-9-_]*$/).optional() }).passthrough();
const workers_route_response_single = workers_api_response_single.and(z.object({ result: workers_routes }).partial().passthrough());
const legacy_jhs_analytics_aggregate_components_schemas_response_collection = legacy_jhs_api_response_common.and(z.object({ result: z.array(z.object({}).partial().passthrough()) }).partial().passthrough());
const legacy_jhs_components_schemas_response_collection = legacy_jhs_api_response_collection.and(z.object({ result: z.array(z.object({}).partial().passthrough()) }).partial().passthrough());
const legacy_jhs_argo_smart_routing = z.boolean();
const legacy_jhs_dns_name = z.string();
const legacy_jhs_dns_type = z.enum(["CNAME", "ADDRESS"]);
const legacy_jhs_dns = z.object({ name: legacy_jhs_dns_name.url(), type: legacy_jhs_dns_type }).partial().passthrough();
const legacy_jhs_edge_ips = z.union([z.object({ connectivity: z.enum(["all", "ipv4", "ipv6"]), type: z.literal("dynamic") }).partial().passthrough(), z.object({ ips: z.array(z.string()), type: z.literal("static") }).partial().passthrough()]);
const legacy_jhs_ip_firewall = z.boolean();
const legacy_jhs_origin_dns_name = z.string();
const legacy_jhs_dns_ttl = z.number();
const legacy_jhs_origin_dns_type = z.enum(["", "A", "AAAA", "SRV"]);
const legacy_jhs_origin_dns = z.object({ name: legacy_jhs_origin_dns_name.url(), ttl: legacy_jhs_dns_ttl.int().gte(600), type: legacy_jhs_origin_dns_type }).partial().passthrough();
const legacy_jhs_origin_port = z.union([z.number(), z.string()]);
const legacy_jhs_protocol = z.string();
const legacy_jhs_proxy_protocol = z.enum(["off", "v1", "v2", "simple"]);
const legacy_jhs_tls = z.enum(["off", "flexible", "full", "strict"]);
const legacy_jhs_traffic_type = z.enum(["direct", "http", "https"]);
const spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_Body = z.object({ argo_smart_routing: legacy_jhs_argo_smart_routing.optional(), dns: legacy_jhs_dns, edge_ips: legacy_jhs_edge_ips.optional().default({ "connectivity": "all", "type": "dynamic" }), ip_firewall: legacy_jhs_ip_firewall.optional(), origin_dns: legacy_jhs_origin_dns, origin_port: legacy_jhs_origin_port, protocol: legacy_jhs_protocol, proxy_protocol: legacy_jhs_proxy_protocol.optional().default("off"), tls: legacy_jhs_tls.optional(), traffic_type: legacy_jhs_traffic_type.optional().default("direct") }).passthrough();
const legacy_jhs_created = z.string();
const legacy_jhs_app_id = z.string();
const legacy_jhs_modified = z.string();
const legacy_jhs_response_single_origin_dns = legacy_jhs_api_response_single.and(z.object({ result: z.object({ argo_smart_routing: legacy_jhs_argo_smart_routing, created_on: legacy_jhs_created.datetime({ offset: true }), dns: legacy_jhs_dns, edge_ips: legacy_jhs_edge_ips.default({ "connectivity": "all", "type": "dynamic" }), id: legacy_jhs_app_id.max(32), ip_firewall: legacy_jhs_ip_firewall, modified_on: legacy_jhs_modified.datetime({ offset: true }), origin_dns: legacy_jhs_origin_dns, origin_port: legacy_jhs_origin_port, protocol: legacy_jhs_protocol, proxy_protocol: legacy_jhs_proxy_protocol.default("off"), tls: legacy_jhs_tls, traffic_type: legacy_jhs_traffic_type.default("direct") }).partial().passthrough() }).partial().passthrough());
const legacy_jhs_schemas_response_single = legacy_jhs_api_response_single.and(z.object({ result: z.object({}).partial().passthrough() }).partial().passthrough());

export const schemas = {
	iam_messages,
	iam_api_response_common,
	iam_result_info,
	iam_api_response_collection,
	iam_response_collection,
	iam_api_response_common_failure,
	urlscanner_create_scan_Body,
	nc_challenges_admin_messages,
	nc_challenges_admin_api_response_common,
	nc_challenges_admin_result_info,
	nc_challenges_admin_bot_fight_mode,
	nc_challenges_admin_clearance_level,
	nc_challenges_admin_created_on,
	nc_challenges_admin_domains,
	nc_challenges_admin_mode,
	nc_challenges_admin_modified_on,
	nc_challenges_admin_name,
	nc_challenges_admin_offlabel,
	nc_challenges_admin_region,
	nc_challenges_admin_sitekey,
	nc_challenges_admin_widget_list,
	nc_challenges_admin_api_response_common_failure,
	nc_challenges_admin_secret,
	nc_challenges_admin_widget_detail,
	nc_challenges_admin_invalidate_immediately,
	cloudforce_one_time,
	cloudforce_one_request_type,
	cloudforce_one_request_status,
	cloudforce_one_request_list,
	cloudforce_one_messages,
	cloudforce_one_api_response_common,
	cloudforce_one_uuid,
	cloudforce_one_priority,
	cloudforce_one_request_readable_id,
	cloudforce_one_request_summary,
	cloudforce_one_tlp,
	cloudforce_one_request_list_item,
	cloudforce_one_api_response_common_failure,
	cloudforce_one_request_constants,
	cloudforce_one_request_content,
	cloudforce_one_request_edit,
	cloudforce_one_request_item,
	cloudforce_one_priority_list,
	cloudforce_one_labels,
	cloudforce_one_priority_item,
	cloudforce_one_priority_edit,
	cloudforce_one_quota,
	cloudforce_one_request_types,
	cloudforce_one_request_message_list,
	cloudforce_one_message_content,
	cloudforce_one_request_message_item,
	cloudforce_one_request_message_edit,
	custom_pages_messages,
	custom_pages_api_response_common,
	custom_pages_result_info,
	custom_pages_api_response_collection,
	custom_pages_custom_pages_response_collection,
	custom_pages_api_response_common_failure,
	custom_pages_api_response_single,
	custom_pages_custom_pages_response_single,
	custom_pages_state,
	custom_pages_url,
	d1_messages,
	d1_api_response_common,
	d1_api_response_single,
	d1_api_response_common_failure,
	d1_file_size,
	d1_database_name,
	d1_table_count,
	d1_database_identifier,
	d1_database_version,
	d1_database_details_response,
	d1_params,
	d1_sql,
	cloudflare_d1_query_database_Body,
	d1_query_meta,
	d1_query_result_response,
	dns_dns_analytics_api_messages,
	dns_dns_analytics_api_api_response_common,
	dns_dns_analytics_api_api_response_single,
	dns_dns_analytics_api_data,
	dns_dns_analytics_api_filters,
	dns_dns_analytics_api_limit,
	dns_dns_analytics_api_since,
	dns_dns_analytics_api_until,
	dns_dns_analytics_api_query,
	dns_dns_analytics_api_result,
	dns_dns_analytics_api_report,
	dns_dns_analytics_api_api_response_common_failure,
	dns_dns_analytics_api_time_delta,
	dns_dns_analytics_api_report_bytime,
	email_messages,
	email_api_response_common,
	email_result_info,
	email_api_response_collection,
	email_created,
	email_email,
	email_destination_address_identifier,
	email_modified,
	email_destination_address_tag,
	email_verified,
	email_destination_address_properties,
	email_addresses,
	email_destination_addresses_response_collection,
	email_create_destination_address_properties,
	email_api_response_single,
	email_destination_address_response_single,
	legacy_jhs_schemas_mode,
	filters,
	egs_pagination_json,
	legacy_jhs_messages,
	legacy_jhs_api_response_common,
	legacy_jhs_result_info,
	legacy_jhs_api_response_collection,
	legacy_jhs_response_collection,
	legacy_jhs_api_response_common_failure,
	legacy_jhs_ip_configuration,
	legacy_jhs_ipv6_configuration,
	legacy_jhs_cidr_configuration,
	legacy_jhs_asn_configuration,
	legacy_jhs_country_configuration,
	legacy_jhs_schemas_configuration,
	legacy_jhs_notes,
	legacy_jhs_api_response_single,
	legacy_jhs_response_single,
	legacy_jhs_common_components_schemas_identifier,
	legacy_jhs_api_response_single_id,
	legacy_jhs_rule_components_schemas_identifier,
	legacy_jhs_rule,
	legacy_jhs_email,
	legacy_jhs_schemas_rule,
	magic_messages,
	magic_api_response_common,
	magic_api_response_single,
	magic_components_schemas_name,
	magic_schemas_created_on,
	magic_interconnect_components_schemas_description,
	magic_gre,
	magic_schemas_health_check,
	magic_schemas_identifier,
	magic_interface_address,
	magic_schemas_modified_on,
	magic_schemas_mtu,
	magic_interconnect,
	magic_components_schemas_tunnels_collection_response,
	magic_api_response_common_failure,
	magic_components_schemas_modified_tunnels_collection_response,
	magic_components_schemas_tunnel_single_response,
	magic_components_schemas_tunnel_update_request,
	magic_components_schemas_tunnel_modified_response,
	magic_cloudflare_gre_endpoint,
	magic_customer_gre_endpoint,
	magic_schemas_description,
	magic_health_check,
	magic_mtu,
	magic_name,
	magic_ttl,
	magic_gre_tunnel,
	magic_tunnels_collection_response,
	magic_modified_tunnels_collection_response,
	magic_tunnel_deleted_response,
	magic_tunnel_single_response,
	magic_tunnel_add_single_request,
	magic_tunnel_update_request,
	magic_tunnel_modified_response,
	magic_allow_null_cipher,
	magic_cloudflare_ipsec_endpoint,
	magic_customer_ipsec_endpoint,
	magic_components_schemas_description,
	magic_schemas_name,
	magic_psk_metadata,
	magic_replay_protection,
	magic_tunnel_health_check,
	magic_ipsec_tunnel,
	magic_schemas_tunnels_collection_response,
	magic_psk,
	magic_schemas_tunnel_add_single_request,
	magic_schemas_tunnel_add_request,
	magic_schemas_modified_tunnels_collection_response,
	magic_schemas_tunnel_deleted_response,
	magic_schemas_tunnel_single_response,
	magic_schemas_tunnel_update_request,
	magic_schemas_tunnel_modified_response,
	magic_identifier,
	magic_psk_generation_response,
	magic_route_delete_id,
	magic_route_delete_many_request,
	magic_multiple_route_delete_response,
	magic_created_on,
	magic_description,
	magic_modified_on,
	magic_nexthop,
	magic_prefix,
	magic_priority,
	magic_colo_name,
	magic_colo_names,
	magic_colo_region,
	magic_colo_regions,
	magic_scope,
	magic_weight,
	magic_route,
	magic_routes_collection_response,
	magic_route_add_single_request,
	magic_route_update_single_request,
	magic_route_update_many_request,
	magic_multiple_route_modified_response,
	magic_route_deleted_response,
	magic_route_single_response,
	magic_route_update_request,
	magic_route_modified_response,
	magic_connector_id,
	magic_site_location,
	magic_site_name,
	magic_secondary_connector_id,
	magic_site,
	magic_sites_collection_response,
	magic_sites_add_single_request,
	magic_site_single_response,
	magic_site_deleted_response,
	magic_site_update_request,
	magic_site_modified_response,
	magic_port,
	magic_ip_address,
	magic_cidr,
	magic_acl_subnet,
	magic_lan_acl_configuration,
	magic_acl,
	magic_acls_collection_response,
	magic_acls_add_single_request,
	magic_acl_deleted_response,
	magic_acl_single_response,
	magic_acl_update_request,
	magic_acl_modified_response,
	magic_nat,
	magic_routed_subnet,
	magic_lan_dhcp_relay,
	magic_lan_dhcp_server,
	magic_lan_static_addressing,
	magic_vlan_tag,
	magic_lan,
	magic_lans_collection_response,
	magic_lans_add_single_request,
	magic_lan_deleted_response,
	magic_lan_single_response,
	magic_lan_update_request,
	magic_lan_modified_response,
	magic_wan_static_addressing,
	magic_wan,
	magic_wans_collection_response,
	magic_wans_add_single_request,
	magic_wan_deleted_response,
	magic_wan_single_response,
	magic_wan_update_request,
	magic_wan_modified_response,
	magic_visibility_messages,
	magic_visibility_api_response_common,
	magic_visibility_api_response_single,
	magic_visibility_mnm_config_default_sampling,
	magic_visibility_mnm_config_name,
	magic_visibility_mnm_config_router_ip,
	magic_visibility_mnm_config_router_ips,
	magic_visibility_mnm_config,
	magic_visibility_mnm_config_single_response,
	magic_visibility_api_response_common_failure,
	magic_visibility_result_info,
	magic_visibility_api_response_collection,
	magic_visibility_mnm_rule_automatic_advertisement,
	magic_visibility_mnm_rule_bandwidth_threshold,
	magic_visibility_mnm_rule_duration,
	magic_visibility_rule_identifier,
	magic_visibility_mnm_rule_name,
	magic_visibility_mnm_rule_packet_threshold,
	magic_visibility_mnm_rule_ip_prefix,
	magic_visibility_mnm_rule_ip_prefixes,
	magic_visibility_mnm_rule,
	magic_visibility_mnm_rules_collection_response,
	magic_visibility_mnm_rules_single_response,
	magic_visibility_mnm_rule_advertisable_response,
	magic_visibility_mnm_rule_advertisement_single_response,
	account_request_tracer_request_trace_Body,
	request_tracer_messages,
	request_tracer_api_response_common,
	request_tracer_trace,
	request_tracer_api_response_common_failure,
	lists_messages,
	lists_api_response_common,
	lists_api_response_collection,
	lists_operation_id,
	lists_operation,
	lists_bulk_operation_response_collection,
	lists_api_response_common_failure,
	lists_item_ip,
	lists_item_redirect,
	lists_item_hostname,
	lists_item_asn,
	lists_item,
	lists_item_response_collection,
	bill_subs_api_messages,
	bill_subs_api_api_response_common,
	bill_subs_api_result_info,
	bill_subs_api_api_response_collection,
	bill_subs_api_install_id,
	bill_subs_api_component_value,
	bill_subs_api_component_values,
	bill_subs_api_currency,
	bill_subs_api_current_period_end,
	bill_subs_api_current_period_start,
	bill_subs_api_frequency,
	bill_subs_api_schemas_identifier,
	bill_subs_api_price,
	bill_subs_api_rate_plan,
	bill_subs_api_state,
	bill_subs_api_identifier,
	bill_subs_api_name,
	bill_subs_api_zone,
	bill_subs_api_subscription_v2,
	bill_subs_api_subscription,
	bill_subs_api_account_subscription_response_collection,
	bill_subs_api_api_response_common_failure,
	bill_subs_api_api_response_single,
	bill_subs_api_account_subscription_response_single,
	vectorize_messages,
	vectorize_api_response_common,
	vectorize_index_dimensions,
	vectorize_index_metric,
	vectorize_index_dimension_configuration,
	vectorize_index_description,
	vectorize_index_name,
	vectorize_create_index_response,
	vectorize_api_response_single,
	vectorize_api_response_common_failure,
	vectorize_index_preset,
	vectorize_index_preset_configuration,
	vectorize_index_configuration,
	vectorize_create_index_request,
	vectorize_update_index_request,
	vectorize_identifier,
	vectorize_index_delete_vectors_by_id_request,
	vectorize_index_delete_vectors_by_id_response,
	vectorize_index_get_vectors_by_id_request,
	vectorize_index_get_vectors_by_id_response,
	vectorize_index_insert_response,
	vectorize_index_query_request,
	vectorize_index_query_response,
	vectorize_index_upsert_response,
	iam_api_response_single,
	iam_response_single,
	iam_common_components_schemas_identifier,
	iam_account,
	iam_components_schemas_account,
	addressing_messages,
	addressing_api_response_common,
	addressing_result_info,
	addressing_api_response_collection,
	addressing_can_delete,
	addressing_can_modify_ips,
	addressing_timestamp,
	addressing_default_sni,
	addressing_schemas_description,
	addressing_enabled,
	addressing_identifier,
	addressing_address_maps,
	addressing_components_schemas_response_collection,
	addressing_api_response_common_failure,
	addressing_api_response_single,
	addressing_ip,
	addressing_address_maps_ip,
	addressing_schemas_ips,
	addressing_schemas_can_delete,
	addressing_kind,
	addressing_address_maps_membership,
	addressing_memberships,
	addressing_full_response,
	addressing_components_schemas_single_response,
	addressing_loa_upload_response,
	addressing_advertised,
	addressing_modified_at_nullable,
	addressing_approved,
	addressing_asn,
	addressing_cidr,
	addressing_description,
	addressing_loa_document_identifier,
	addressing_on_demand_enabled,
	addressing_on_demand_locked,
	addressing_ipam_prefixes,
	addressing_response_collection,
	addressing_single_response,
	addressing_bgp_signaling_enabled,
	addressing_bgp_signaling_modified_at,
	addressing_bgp_signal_opts,
	addressing_bgp_on_demand,
	addressing_ipam_bgp_prefixes,
	addressing_response_collection_bgp,
	addressing_single_response_bgp,
	addressing_bgp_prefix_update_advertisement,
	addressing_schemas_advertised,
	addressing_advertised_response,
	addressing_provisioning,
	addressing_service_identifier,
	addressing_service_name,
	addressing_service_binding,
	addressing_create_binding_request,
	addressing_delegated_account_identifier,
	addressing_delegation_identifier,
	addressing_ipam_delegations,
	addressing_schemas_response_collection,
	addressing_schemas_single_response,
	addressing_id_response,
	workers_ai_post_run_cf_baai_bge_base_en_v1_5_Body,
	workers_ai_post_run_cf_bytedance_stable_diffusion_xl_lightning_Body,
	workers_ai_post_run_cf_facebook_bart_large_cnn_Body,
	workers_ai_post_run_cf_meta_m2m100_1_2b_Body,
	workers_ai_post_run_hf_sentence_transformers_all_minilm_l6_v2_Body,
	aaa_messages,
	aaa_api_response_common,
	aaa_result_info,
	aaa_api_response_collection,
	aaa_description,
	aaa_display_name,
	aaa_filter_options,
	aaa_type,
	aaa_alert_types,
	aaa_response_collection,
	aaa_api_response_common_failure,
	aaa_eligible,
	aaa_ready,
	aaa_schemas_type,
	aaa_eligibility,
	aaa_schemas_response_collection,
	aaa_uuid,
	aaa_name,
	aaa_pagerduty,
	aaa_components_schemas_response_collection,
	aaa_api_response_single,
	aaa_token,
	aaa_sensitive_id_response,
	aaa_id_response,
	aaa_created_at,
	aaa_webhook_id,
	aaa_last_failure,
	aaa_last_success,
	aaa_components_schemas_name,
	aaa_secret,
	aaa_components_schemas_type,
	aaa_url,
	aaa_webhooks,
	aaa_webhooks_components_schemas_response_collection,
	aaa_schemas_single_response,
	aaa_alert_body,
	aaa_schemas_alert_type,
	aaa_components_schemas_description,
	aaa_mechanism,
	aaa_mechanism_type,
	aaa_schemas_name,
	aaa_policy_id,
	aaa_sent,
	aaa_history,
	aaa_history_components_schemas_response_collection,
	aaa_alert_type,
	aaa_timestamp,
	aaa_schemas_description,
	aaa_enabled,
	aaa_filters,
	aaa_mechanisms,
	aaa_policies,
	aaa_policies_components_schemas_response_collection,
	aaa_single_response,
	aaa_identifier,
	aaa_audit_logs,
	aaa_audit_logs_response_collection,
	intel_url,
	intel_url_param,
	phishing_url_scanner_submit_suspicious_url_for_scanning_Body,
	intel_messages,
	intel_api_response_common,
	intel_api_response_single,
	intel_phishing_url_submit,
	intel_phishing_url_submit_components_schemas_single_response,
	intel_api_response_common_failure,
	intel_url_id,
	url_id_param,
	intel_phishing_url_info,
	intel_phishing_url_info_components_schemas_single_response,
	calls_messages,
	calls_api_response_common,
	calls_created,
	calls_modified,
	calls_name,
	calls_identifier,
	calls_app,
	calls_app_response_collection,
	calls_api_response_common_failure,
	calls_app_editable_fields,
	calls_api_response_single,
	calls_secret,
	calls_app_with_secret,
	calls_app_response_single_with_secret,
	calls_app_response_single,
	tunnel_messages,
	tunnel_api_response_common,
	tunnel_result_info,
	tunnel_api_response_collection,
	tunnel_cf_account_id,
	tunnel_version,
	tunnel_colo_name,
	tunnel_connection_id,
	tunnel_is_pending_reconnect,
	tunnel_schemas_connection,
	tunnel_connections,
	tunnel_conns_active_at,
	tunnel_conns_inactive_at,
	tunnel_created_at,
	tunnel_deleted_at,
	tunnel_tunnel_id,
	tunnel_metadata,
	tunnel_tunnel_name,
	tunnel_remote_config,
	tunnel_status,
	tunnel_tunnel_type,
	tunnel_cfd_tunnel,
	tunnel_warp_connector_tunnel,
	tunnel_tunnel_response_collection,
	tunnel_api_response_common_failure,
	tunnel_config_src,
	tunnel_tunnel_secret,
	cloudflare_tunnel_create_a_cloudflare_tunnel_Body,
	tunnel_tunnel_response_single,
	cloudflare_tunnel_update_a_cloudflare_tunnel_Body,
	tunnel_config_response_single,
	tunnel_originRequest,
	tunnel_ingressRule,
	tunnel_config,
	cloudflare_tunnel_configuration_put_configuration_Body,
	tunnel_empty_response,
	tunnel_arch,
	tunnel_config_version,
	tunnel_features,
	tunnel_run_at,
	tunnel_tunnel_client,
	tunnel_tunnel_connections_response,
	tunnel_tunnel_client_response,
	tunnel_management_resources,
	cloudflare_tunnel_get_a_cloudflare_tunnel_management_token_Body,
	tunnel_tunnel_response_token,
	dns_custom_nameservers_messages,
	dns_custom_nameservers_api_response_common,
	dns_custom_nameservers_result_info,
	dns_custom_nameservers_api_response_collection,
	dns_custom_nameservers_ns_name,
	dns_custom_nameservers_ns_set,
	dns_custom_nameservers_schemas_identifier,
	dns_custom_nameservers_CustomNS,
	dns_custom_nameservers_acns_response_collection,
	dns_custom_nameservers_api_response_common_failure,
	dns_custom_nameservers_CustomNSInput,
	dns_custom_nameservers_api_response_single,
	dns_custom_nameservers_acns_response_single,
	dns_custom_nameservers_availability_response,
	dns_custom_nameservers_empty_response,
	d1_create_database_response,
	cloudflare_d1_create_database_Body,
	teams_devices_messages,
	teams_devices_api_response_common,
	teams_devices_result_info,
	teams_devices_api_response_collection,
	teams_devices_created,
	teams_devices_deleted,
	teams_devices_platform,
	teams_devices_schemas_uuid,
	teams_devices_ip,
	teams_devices_key,
	teams_devices_last_seen,
	teams_devices_mac_address,
	teams_devices_manufacturer,
	teams_devices_model,
	teams_devices_schemas_name,
	teams_devices_os_distro_name,
	teams_devices_os_distro_revision,
	teams_devices_os_version,
	teams_devices_os_version_extra,
	teams_devices_revoked_at,
	teams_devices_serial_number,
	teams_devices_updated,
	teams_devices_email,
	teams_devices_components_schemas_uuid,
	teams_devices_user,
	teams_devices_version,
	teams_devices_devices,
	teams_devices_devices_response,
	teams_devices_api_response_common_failure,
	teams_devices_api_response_collection_common,
	teams_devices_device_dex_test_schemas_data,
	teams_devices_device_dex_test_schemas_description,
	teams_devices_device_dex_test_schemas_enabled,
	teams_devices_device_dex_test_schemas_interval,
	teams_devices_device_dex_test_schemas_name,
	teams_devices_device_dex_test_schemas_http,
	teams_devices_dex_response_collection,
	teams_devices_api_response_single,
	teams_devices_dex_single_response,
	teams_devices_tls_config_response,
	teams_devices_schemas_config_response,
	teams_devices_device_managed_networks_components_schemas_name,
	teams_devices_uuid,
	teams_devices_components_schemas_type,
	teams_devices_device_managed_networks,
	teams_devices_components_schemas_response_collection,
	teams_devices_tls_config_request,
	teams_devices_schemas_config_request,
	teams_devices_components_schemas_single_response,
	teams_devices_allow_mode_switch,
	teams_devices_allow_updates,
	teams_devices_allowed_to_leave,
	teams_devices_auto_connect,
	teams_devices_captive_portal,
	teams_devices_default,
	teams_devices_schemas_description,
	teams_devices_disable_auto_fallback,
	teams_devices_split_tunnel,
	teams_devices_exclude,
	teams_devices_exclude_office_ips,
	teams_devices_fallback_domain,
	teams_devices_fallback_domains,
	teams_devices_gateway_unique_id,
	teams_devices_split_tunnel_include,
	teams_devices_include,
	teams_devices_lan_allow_minutes,
	teams_devices_lan_allow_subnet_size,
	teams_devices_schemas_match,
	teams_devices_precedence,
	teams_devices_service_mode_v2,
	teams_devices_support_url,
	teams_devices_switch_locked,
	teams_devices_device_settings_policy,
	teams_devices_device_settings_response_collection,
	teams_devices_default_device_settings_policy,
	teams_devices_default_device_settings_response,
	teams_devices_device_settings_response,
	teams_devices_split_tunnel_response_collection,
	teams_devices_fallback_domain_response_collection,
	teams_devices_split_tunnel_include_response_collection,
	teams_devices_description,
	teams_devices_expiration,
	teams_devices_file_input_request,
	teams_devices_unique_client_id_input_request,
	teams_devices_domain_joined_input_request,
	teams_devices_os_version_input_request,
	teams_devices_firewall_input_request,
	teams_devices_sentinelone_input_request,
	teams_devices_carbonblack_input_request,
	teams_devices_checkDisks,
	teams_devices_requireAll,
	teams_devices_disk_encryption_input_request,
	teams_devices_application_input_request,
	teams_devices_client_certificate_input_request,
	teams_devices_workspace_one_input_request,
	teams_devices_crowdstrike_input_request,
	teams_devices_intune_input_request,
	teams_devices_kolide_input_request,
	teams_devices_tanium_input_request,
	teams_devices_sentinelone_s2s_input_request,
	teams_devices_input,
	teams_devices_match_item,
	teams_devices_match,
	teams_devices_name,
	teams_devices_schedule,
	teams_devices_type,
	teams_devices_device_posture_rules,
	teams_devices_response_collection,
	teams_devices_single_response,
	teams_devices_workspace_one_config_response,
	teams_devices_config_response,
	teams_devices_interval,
	teams_devices_components_schemas_name,
	teams_devices_schemas_type,
	teams_devices_device_posture_integrations,
	teams_devices_schemas_response_collection,
	teams_devices_workspace_one_config_request,
	teams_devices_crowdstrike_config_request,
	teams_devices_uptycs_config_request,
	teams_devices_intune_config_request,
	teams_devices_kolide_config_request,
	teams_devices_tanium_config_request,
	teams_devices_sentinelone_s2s_config_request,
	teams_devices_config_request,
	teams_devices_schemas_single_response,
	teams_devices_schemas_id_response,
	teams_devices_id_response,
	teams_devices_revoke_devices_request,
	teams_devices_zero_trust_account_device_settings,
	teams_devices_zero_trust_account_device_settings_response,
	teams_devices_unrevoke_devices_request,
	teams_devices_device_response,
	teams_devices_disable_for_time,
	teams_devices_override_codes_response,
	digital_experience_monitoring_messages,
	digital_experience_monitoring_api_response_common,
	digital_experience_monitoring_result_info,
	digital_experience_monitoring_api_response_collection,
	digital_experience_monitoring_colos_response,
	digital_experience_monitoring_api_response_common_failure,
	digital_experience_monitoring_colo,
	digital_experience_monitoring_personEmail,
	digital_experience_monitoring_platform,
	digital_experience_monitoring_status,
	digital_experience_monitoring_version,
	digital_experience_monitoring_device,
	digital_experience_monitoring_fleet_status_devices_response,
	digital_experience_monitoring_api_response_single,
	digital_experience_monitoring_uniqueDevicesTotal,
	digital_experience_monitoring_live_stat,
	digital_experience_monitoring_fleet_status_live_response,
	digital_experience_monitoring_test_stat_over_time,
	digital_experience_monitoring_http_details_response,
	digital_experience_monitoring_percentiles,
	digital_experience_monitoring_http_details_percentiles_response,
	digital_experience_monitoring_aggregate_time_period,
	digital_experience_monitoring_aggregate_stat,
	digital_experience_monitoring_aggregate_time_slot,
	digital_experience_monitoring_timing_aggregates,
	digital_experience_monitoring_uuid,
	digital_experience_monitoring_tests_response,
	digital_experience_monitoring_unique_devices_response,
	digital_experience_monitoring_traceroute_test_result_network_path_response,
	digital_experience_monitoring_test_stat_pct_over_time,
	digital_experience_monitoring_traceroute_details_response,
	digital_experience_monitoring_traceroute_test_network_path_response,
	digital_experience_monitoring_traceroute_details_percentiles_response,
	magic_transit_colos,
	magic_transit_max_ttl,
	magic_transit_packet_type,
	magic_transit_packets_per_ttl,
	magic_transit_port,
	magic_transit_wait_time,
	magic_transit_options,
	magic_transit_targets,
	magic_transit_messages,
	magic_transit_api_response_common,
	magic_transit_result_info,
	magic_transit_api_response_collection,
	magic_transit_colo_city,
	magic_transit_colo_name,
	magic_transit_colo,
	magic_transit_error,
	magic_transit_asn,
	magic_transit_ip,
	magic_transit_labels,
	magic_transit_max_rtt_ms,
	magic_transit_mean_rtt_ms,
	magic_transit_min_rtt_ms,
	magic_transit_name,
	magic_transit_packet_count,
	magic_transit_std_dev_rtt_ms,
	magic_transit_node_result,
	magic_transit_packets_lost,
	magic_transit_packets_sent,
	magic_transit_packets_ttl,
	magic_transit_hop_result,
	magic_transit_target_summary,
	magic_transit_traceroute_time_ms,
	magic_transit_colo_result,
	magic_transit_target,
	magic_transit_target_result,
	magic_transit_traceroute_response_collection,
	magic_transit_api_response_common_failure,
	dlp_V4ResponseMessage,
	dlp_V4ResponsePagination,
	dlp_V4Response,
	dlp_DatasetUploadStatus,
	dlp_DatasetUpload,
	dlp_Dataset,
	dlp_DatasetArray,
	dlp_DatasetArrayResponse,
	dlp_V4ResponseError,
	dlp_NewDataset,
	dlp_DatasetCreation,
	dlp_DatasetCreationResponse,
	dlp_DatasetResponse,
	dlp_DatasetUpdate,
	dlp_DatasetNewVersion,
	dlp_DatasetNewVersionResponse,
	dlp_validate_pattern,
	dlp_messages,
	dlp_api_response_common,
	dlp_api_response_single,
	dlp_validate_response,
	dlp_api_response_common_failure,
	dlp_get_settings_response,
	dlp_update_settings,
	dlp_update_settings_response,
	dlp_result_info,
	dlp_api_response_collection,
	dlp_allowed_match_count,
	dlp_SkipConfig,
	dlp_ContextAwareness,
	dlp_uuid,
	dlp_entry_id,
	dlp_predefined_entry,
	dlp_profile_id,
	dlp_predefined_profile,
	dlp_timestamp,
	dlp_pattern,
	dlp_custom_entry,
	dlp_custom_profile,
	dlp_integration_entry,
	dlp_integration_profile,
	dlp_profiles,
	dlp_response_collection,
	dlp_new_custom_entry,
	dlp_new_custom_profile,
	dlp_create_custom_profiles,
	dlp_create_custom_profile_response,
	profile_id,
	dlp_custom_profile_response,
	dlp_shared_entry_update_predefined,
	dlp_shared_entry_update_integration,
	dlp_update_custom_profile,
	dlp_predefined_profile_response,
	dlp_update_predefined_profile,
	dlp_either_profile_response,
	dns_firewall_messages,
	dns_firewall_api_response_common,
	dns_firewall_result_info,
	dns_firewall_api_response_collection,
	dns_firewall_attack_mitigation,
	dns_firewall_deprecate_any_requests,
	dns_firewall_dns_firewall_ips,
	dns_firewall_ecs_fallback,
	dns_firewall_identifier,
	dns_firewall_maximum_cache_ttl,
	dns_firewall_minimum_cache_ttl,
	dns_firewall_modified_on,
	dns_firewall_name,
	dns_firewall_negative_cache_ttl,
	dns_firewall_ratelimit,
	dns_firewall_retries,
	dns_firewall_upstream_ips,
	dns_firewall_dns_firewall,
	dns_firewall_dns_firewall_response_collection,
	dns_firewall_api_response_common_failure,
	dns_firewall_api_response_single,
	dns_firewall_dns_firewall_single_response,
	dns_firewall_schemas_dns_firewall,
	zero_trust_gateway_messages,
	zero_trust_gateway_api_response_common,
	zero_trust_gateway_api_response_single,
	zero_trust_gateway_gateway_tag,
	zero_trust_gateway_cf_account_id,
	zero_trust_gateway_provider_name,
	zero_trust_gateway_gateway_account,
	zero_trust_gateway_api_response_common_failure,
	zero_trust_gateway_result_info,
	zero_trust_gateway_api_response_collection,
	zero_trust_gateway_app_type_id,
	zero_trust_gateway_timestamp,
	zero_trust_gateway_app_id,
	zero_trust_gateway_app_types_components_schemas_name,
	zero_trust_gateway_application,
	zero_trust_gateway_application_type,
	zero_trust_gateway_app_types,
	zero_trust_gateway_app_types_components_schemas_response_collection,
	zero_trust_gateway_public_key,
	zero_trust_gateway_audit_ssh_settings_components_schemas_uuid,
	zero_trust_gateway_settings,
	zero_trust_gateway_audit_ssh_settings_components_schemas_single_response,
	zero_trust_gateway_beta,
	zero_trust_gateway_class,
	zero_trust_gateway_components_schemas_description,
	zero_trust_gateway_id,
	zero_trust_gateway_categories_components_schemas_name,
	zero_trust_gateway_subcategory,
	zero_trust_gateway_categories,
	zero_trust_gateway_categories_components_schemas_response_collection,
	zero_trust_gateway_activity_log_settings,
	zero_trust_gateway_enabled_download_phase,
	zero_trust_gateway_enabled_upload_phase,
	zero_trust_gateway_fail_closed,
	zero_trust_gateway_notification_settings,
	zero_trust_gateway_anti_virus_settings,
	zero_trust_gateway_block_page_settings,
	zero_trust_gateway_body_scanning_settings,
	zero_trust_gateway_browser_isolation_settings,
	zero_trust_gateway_custom_certificate_settings,
	zero_trust_gateway_extended_email_matching,
	zero_trust_gateway_fips_settings,
	zero_trust_gateway_protocol_detection,
	zero_trust_gateway_tls_settings,
	zero_trust_gateway_gateway_account_settings,
	zero_trust_gateway_gateway_account_config,
	zero_trust_gateway_count,
	zero_trust_gateway_description,
	zero_trust_gateway_uuid,
	zero_trust_gateway_name,
	zero_trust_gateway_type,
	zero_trust_gateway_lists,
	zero_trust_gateway_response_collection,
	zero_trust_gateway_value,
	zero_trust_gateway_items,
	zero_trust_gateway_single_response_with_list_items,
	zero_trust_gateway_empty_response,
	zero_trust_gateway_single_response,
	zero_trust_gateway_list_item_response_collection,
	zero_trust_gateway_client_default,
	zero_trust_gateway_subdomain,
	zero_trust_gateway_ecs_support,
	zero_trust_gateway_schemas_uuid,
	zero_trust_gateway_ip,
	zero_trust_gateway_schemas_name,
	zero_trust_gateway_network,
	zero_trust_gateway_networks,
	zero_trust_gateway_locations,
	zero_trust_gateway_schemas_response_collection,
	zero_trust_gateway_schemas_single_response,
	zero_trust_gateway_gateway_account_logging_settings,
	zero_trust_gateway_gateway_account_logging_settings_response,
	zero_trust_gateway_ips,
	zero_trust_gateway_proxy_endpoints_components_schemas_name,
	zero_trust_gateway_schemas_subdomain,
	zero_trust_gateway_proxy_endpoints,
	zero_trust_gateway_proxy_endpoints_components_schemas_response_collection,
	zero_trust_gateway_proxy_endpoints_components_schemas_single_response,
	zero_trust_gateway_action,
	zero_trust_gateway_deleted_at,
	zero_trust_gateway_schemas_description,
	zero_trust_gateway_device_posture,
	zero_trust_gateway_enabled,
	zero_trust_gateway_filters,
	zero_trust_gateway_components_schemas_uuid,
	zero_trust_gateway_identity,
	zero_trust_gateway_components_schemas_name,
	zero_trust_gateway_precedence,
	zero_trust_gateway_dns_resolver_settings,
	zero_trust_gateway_rule_settings,
	zero_trust_gateway_schedule,
	zero_trust_gateway_traffic,
	zero_trust_gateway_rules,
	zero_trust_gateway_components_schemas_response_collection,
	zero_trust_gateway_components_schemas_single_response,
	hyperdrive_messages,
	hyperdrive_api_response_common,
	hyperdrive_hyperdrive_caching,
	hyperdrive_hyperdrive_name,
	hyperdrive_hyperdrive_scheme,
	hyperdrive_hyperdrive_origin,
	hyperdrive_hyperdrive,
	hyperdrive_hyperdrive_with_identifier,
	hyperdrive_api_response_single,
	hyperdrive_api_response_common_failure,
	hyperdrive_create_update_hyperdrive_config,
	hyperdrive_patch_hyperdrive_config,
	images_image_upload_via_file,
	images_image_upload_via_url,
	images_image_basic_upload,
	images_messages,
	images_api_response_common,
	images_api_response_single,
	images_image_filename,
	images_image_identifier,
	images_image_metadata,
	images_image_requireSignedURLs,
	images_image_uploaded,
	images_image_thumbnail_url,
	images_image_hero_url,
	images_image_original_url,
	images_image_variants,
	images_image,
	images_image_response_single,
	images_api_response_common_failure,
	images_image_key_name,
	images_image_key_value,
	images_image_keys,
	images_image_keys_response,
	images_image_key_response_collection,
	images_images_stats_allowed,
	images_images_stats_current,
	images_images_stats_count,
	images_images_stats,
	images_images_stats_response,
	images_image_variant_identifier,
	images_image_variant_neverRequireSignedURLs,
	images_image_variant_fit,
	images_image_variant_height,
	images_image_variant_schemas_metadata,
	images_image_variant_width,
	images_image_variant_options,
	images_image_variant_public_request,
	images_image_variants_response,
	images_image_variant_list_response,
	images_image_variant_definition,
	images_image_variant_response,
	images_image_variant_simple_response,
	images_deleted_response,
	images_image_variant_patch_request,
	images_image_patch_request,
	images_image_response_blob,
	images_images_list_continuation_token,
	images_api_response_collection_v2,
	images_images_list_response_v2,
	images_image_direct_upload_request_v2,
	images_image_direct_upload_response_v2,
	intel_asn,
	intel_asn_components_schemas_response,
	intel_count,
	intel_page,
	intel_per_page,
	security_center_messages,
	security_center_api_response_common,
	security_center_api_response_common_failure,
	security_center_issueClass,
	security_center_issueType,
	security_center_subject,
	security_center_page,
	page,
	security_center_perPage,
	per_page,
	security_center_count,
	security_center_issue,
	security_center_valueCountsResponse,
	security_center_api_response_single,
	start_end_params,
	intel_passive_dns_by_ip,
	intel_components_schemas_single_response,
	intel_additional_information,
	intel_application,
	intel_content_categories,
	intel_domain_name,
	intel_category_with_super_category_id,
	intel_categories_with_super_category_ids_example_empty,
	intel_inherited_from,
	intel_popularity_rank,
	intel_stix_identifier,
	intel_resolves_to_ref,
	intel_resolves_to_refs,
	intel_risk_score,
	intel_risk_types,
	intel_domain,
	intel_single_response,
	intel_result_info,
	intel_api_response_collection,
	intel_domain_history,
	intel_response,
	intel_collection_response,
	intel_description,
	intel_id,
	intel_name,
	intel_indicator_feed_item,
	intel_indicator_feed_response,
	intel_create_feed,
	intel_create_feed_response,
	intel_permissions_request,
	intel_permissions_update,
	intel_permissions_response,
	intel_permission_list_item,
	intel_permission_list_item_response,
	intel_indicator_feed_metadata,
	intel_indicator_feed_metadata_response,
	intel_update_feed,
	intel_update_feed_response,
	intel_ipv4,
	intel_ipv6,
	intel_ip,
	intel_schemas_ip,
	intel_schemas_response,
	intel_ip_list,
	intel_components_schemas_response,
	intel_miscategorization,
	intel_sinkholes_messages,
	intel_sinkholes_api_response_common,
	intel_sinkholes_id,
	intel_sinkholes_name,
	intel_sinkholes_sinkhole_item,
	intel_sinkholes_get_sinkholes_response,
	intel_whois,
	intel_schemas_single_response,
	load_balancing_messages,
	load_balancing_api_response_common,
	load_balancing_result_info,
	load_balancing_api_response_collection,
	load_balancing_allow_insecure,
	load_balancing_consecutive_down,
	load_balancing_consecutive_up,
	load_balancing_description,
	load_balancing_expected_body,
	load_balancing_expected_codes,
	load_balancing_follow_redirects,
	load_balancing_header,
	load_balancing_interval,
	load_balancing_method,
	load_balancing_path,
	load_balancing_port,
	load_balancing_probe_zone,
	load_balancing_retries,
	load_balancing_timeout,
	load_balancing_type,
	load_balancing_monitor_editable,
	load_balancing_timestamp,
	load_balancing_identifier,
	load_balancing_monitor,
	load_balancing_monitor_response_collection,
	load_balancing_api_response_common_failure,
	account_load_balancer_monitors_create_monitor_Body,
	load_balancing_api_response_single,
	load_balancing_monitor_response_single,
	load_balancing_id_response,
	load_balancing_preview_response,
	load_balancing_references_response,
	load_balancing_check_regions,
	load_balancing_schemas_description,
	load_balancing_schemas_disabled_at,
	load_balancing_enabled,
	load_balancing_schemas_identifier,
	load_balancing_latitude,
	load_balancing_load_shedding,
	load_balancing_longitude,
	load_balancing_minimum_origins,
	load_balancing_monitor_id,
	load_balancing_name,
	load_balancing_notification_email,
	load_balancing_filter_options,
	load_balancing_notification_filter,
	load_balancing_origin_steering,
	load_balancing_address,
	load_balancing_disabled_at,
	load_balancing_schemas_enabled,
	load_balancing_Host,
	load_balancing_schemas_header,
	load_balancing_schemas_name,
	load_balancing_virtual_network_id,
	load_balancing_weight,
	load_balancing_origin,
	load_balancing_origins,
	load_balancing_pool,
	load_balancing_schemas_response_collection,
	load_balancing_patch_pools_notification_email,
	load_balancing_schemas_single_response,
	load_balancing_schemas_id_response,
	load_balancing_health_details,
	load_balancing_schemas_references_response,
	load_balancing_origin_health_data,
	load_balancing_preview_result,
	load_balancing_preview_result_response,
	load_balancing_region_components_schemas_response_collection,
	load_balancing_components_schemas_single_response,
	search_params,
	load_balancing_resource_reference,
	load_balancing_search,
	load_balancing_search_result,
	logpush_messages,
	logpush_api_response_common,
	logpush_logpush_field_response_collection,
	logpush_api_response_common_failure,
	logpush_dataset,
	logpush_destination_conf,
	logpush_enabled,
	logpush_error_message,
	logpush_frequency,
	logpush_id,
	logpush_last_complete,
	logpush_last_error,
	logpush_logpull_options,
	logpush_name,
	logpush_output_options,
	logpush_logpush_job,
	logpush_logpush_job_response_collection,
	logpush_ownership_challenge,
	logpush_api_response_single,
	logpush_logpush_job_response_single,
	logpush_get_ownership_response,
	logpush_validate_ownership_response,
	logpush_destination_exists_response,
	logpush_validate_response,
	logcontrol_messages,
	logcontrol_api_response_common,
	logcontrol_api_response_common_failure,
	logcontrol_api_response_single,
	logcontrol_regions,
	logcontrol_cmb_config,
	logcontrol_cmb_config_response_single,
	iam_email,
	iam_member_components_schemas_name,
	iam_description,
	iam_role_components_schemas_identifier,
	iam_components_schemas_name,
	iam_schemas_permissions,
	iam_schemas_role,
	iam_components_schemas_member,
	iam_collection_member_response,
	iam_create,
	iam_membership_components_schemas_identifier,
	iam_grants,
	iam_permissions,
	iam_role,
	iam_first_name,
	iam_last_name,
	iam_two_factor_authentication_enabled,
	iam_member,
	iam_code,
	iam_member_with_code,
	iam_single_member_response_with_code,
	iam_api_response_single_id,
	iam_single_member_response,
	iam_schemas_member,
	tls_certificates_and_hostnames_messages,
	tls_certificates_and_hostnames_api_response_common,
	tls_certificates_and_hostnames_result_info,
	tls_certificates_and_hostnames_api_response_collection,
	tls_certificates_and_hostnames_ca,
	tls_certificates_and_hostnames_schemas_certificates,
	tls_certificates_and_hostnames_mtls_management_components_schemas_expires_on,
	tls_certificates_and_hostnames_identifier,
	tls_certificates_and_hostnames_schemas_issuer,
	tls_certificates_and_hostnames_schemas_name,
	tls_certificates_and_hostnames_schemas_serial_number,
	tls_certificates_and_hostnames_signature,
	tls_certificates_and_hostnames_mtls_management_components_schemas_uploaded_on,
	tls_certificates_and_hostnames_components_schemas_certificateObject,
	tls_certificates_and_hostnames_mtls_management_components_schemas_certificate_response_collection,
	tls_certificates_and_hostnames_api_response_common_failure,
	tls_certificates_and_hostnames_components_schemas_private_key,
	m_tls_certificate_management_upload_m_tls_certificate_Body,
	tls_certificates_and_hostnames_api_response_single,
	tls_certificates_and_hostnames_schemas_updated_at,
	tls_certificates_and_hostnames_certificateObjectPost,
	tls_certificates_and_hostnames_certificate_response_single_post,
	tls_certificates_and_hostnames_mtls_management_components_schemas_certificate_response_single,
	tls_certificates_and_hostnames_service,
	tls_certificates_and_hostnames_mtls_management_components_schemas_status,
	tls_certificates_and_hostnames_associationObject,
	tls_certificates_and_hostnames_association_response_collection,
	pages_messages,
	pages_api_response_common,
	pages_stage,
	pages_deployments,
	pages_projects_response,
	pages_api_response_common_failure,
	pages_build_config,
	pages_deployment_configs_values,
	pages_deployment_configs,
	pages_projects,
	pages_new_project_response,
	pages_project_response,
	pages_project_patch,
	pages_deployment_list_response,
	pages_deployment_new_deployment,
	pages_deployment_response_details,
	pages_deployment_response_logs,
	pages_domain_response_collection,
	pages_domains_post,
	pages_api_response_single,
	pages_domain_response_single,
	magic_visibility_pcaps_filter_v1,
	magic_visibility_pcaps_id,
	magic_visibility_pcaps_status,
	magic_visibility_pcaps_submitted,
	magic_visibility_pcaps_system,
	magic_visibility_pcaps_time_limit,
	magic_visibility_pcaps_type,
	magic_visibility_pcaps_response_simple,
	magic_visibility_pcaps_byte_limit,
	magic_visibility_pcaps_colo_name,
	magic_visibility_pcaps_destination_conf,
	magic_visibility_pcaps_error_message,
	magic_visibility_pcaps_response_full,
	magic_visibility_pcaps_collection_response,
	magic_visibility_pcaps_packet_limit,
	magic_visibility_pcaps_request_simple,
	magic_visibility_pcaps_request_full,
	magic_visibility_pcaps_request_pcap,
	magic_visibility_pcaps_single_response,
	magic_visibility_pcaps_ownership_challenge,
	magic_visibility_pcaps_ownership_response,
	magic_visibility_pcaps_ownership_collection,
	magic_visibility_pcaps_ownership_request,
	magic_visibility_pcaps_ownership_single_response,
	magic_visibility_pcaps_ownership_validate_request,
	r2_errors,
	r2_messages,
	r2_v4_response,
	r2_result_info,
	r2_v4_response_list,
	r2_bucket_location,
	r2_bucket_name,
	r2_bucket,
	r2_v4_response_failure,
	r2_create_bucket_Body,
	r2_sippy,
	r2_enable_sippy_aws,
	r2_enable_sippy_gcs,
	r2_put_bucket_sippy_config_Body,
	registrar_api_messages,
	registrar_api_api_response_common,
	registrar_api_result_info,
	registrar_api_api_response_collection,
	registrar_api_available,
	registrar_api_can_register,
	registrar_api_created_at,
	registrar_api_current_registrar,
	registrar_api_expires_at,
	registrar_api_domain_identifier,
	registrar_api_locked,
	registrar_api_address,
	registrar_api_address2,
	registrar_api_city,
	registrar_api_country,
	registrar_api_email,
	registrar_api_fax,
	registrar_api_first_name,
	registrar_api_contact_identifier,
	registrar_api_last_name,
	registrar_api_organization,
	registrar_api_telephone,
	registrar_api_state,
	registrar_api_zipcode,
	registrar_api_contact_properties,
	registrar_api_contacts,
	registrar_api_registrant_contact,
	registrar_api_registry_statuses,
	registrar_api_supported_tld,
	registrar_api_transfer_in,
	registrar_api_updated_at,
	registrar_api_domain_properties,
	registrar_api_domains,
	registrar_api_domain_response_collection,
	registrar_api_api_response_common_failure,
	registrar_api_api_response_single,
	registrar_api_domain_response_single,
	registrar_api_auto_renew,
	registrar_api_privacy,
	registrar_api_domain_update_properties,
	registrar_domains_update_domain_Body,
	iam_collection_role_response,
	iam_single_role_response,
	lists_created_on,
	lists_description,
	lists_list_id,
	lists_kind,
	lists_modified_on,
	lists_name,
	lists_num_items,
	lists_num_referencing_filters,
	lists_list,
	lists_lists_response_collection,
	lists_create_a_list_Body,
	lists_list_response_collection,
	lists_item_id,
	lists_list_delete_response_collection,
	lists_update_a_list_Body,
	lists_lists_async_response,
	lists_items,
	lists_items_list_response_collection,
	lists_item_comment,
	lists_items_update_request_collection,
	rulesets_Message,
	rulesets_Errors,
	rulesets_Messages,
	rulesets_Response,
	rulesets_RulesetId,
	rulesets_RulesetKind,
	rulesets_RulesetPhase,
	rulesets_RulesetVersion,
	rulesets_Ruleset,
	rulesets_RulesetsResponse,
	rulesets_FailureResponse,
	rulesets_RuleAction,
	rulesets_RuleCategory,
	rulesets_RuleEnabled,
	rulesets_RuleId,
	rulesets_Rule,
	rulesets_BlockRule,
	rulesets_ExecuteSensitivityLevel,
	rulesets_ExecuteRule,
	rulesets_LogRule,
	rulesets_SkipRule,
	rulesets_RuleRequest,
	rulesets_RulesRequest,
	rulesets_CreateRulesetRequest,
	rulesets_RuleResponse,
	rulesets_RulesResponse,
	rulesets_RulesetResponse,
	rulesets_UpdateRulesetRequest,
	rulesets_RulePosition,
	rulesets_CreateOrUpdateRuleRequest,
	rum_auto_install,
	rum_zone_tag,
	rum_create_site_request,
	rum_messages,
	rum_api_response_common,
	rum_api_response_single,
	rum_timestamp,
	rum_rule_identifier,
	rum_rule,
	rum_rules,
	rum_ruleset_identifier,
	rum_ruleset,
	rum_site_tag,
	rum_site_token,
	rum_snippet,
	rum_site,
	rum_site_response_single,
	rum_api_response_common_failure,
	rum_api_response_collection,
	rum_result_info,
	rum_sites_response_collection,
	rum_site_tag_response_single,
	rum_create_rule_request,
	rum_rule_response_single,
	rum_rule_id_response_single,
	rum_rules_response_collection,
	rum_modify_rules_request,
	secondary_dns_messages,
	secondary_dns_api_response_common,
	secondary_dns_result_info,
	secondary_dns_api_response_collection,
	secondary_dns_components_schemas_identifier,
	secondary_dns_ip_range,
	secondary_dns_acl_components_schemas_name,
	secondary_dns_acl,
	secondary_dns_components_schemas_response_collection,
	secondary_dns_api_response_common_failure,
	secondary_dns_api_response_single,
	secondary_dns_components_schemas_single_response,
	secondary_dns_components_schemas_id_response,
	secondary_dns_ip,
	secondary_dns_ixfr_enable,
	secondary_dns_components_schemas_name,
	secondary_dns_port,
	secondary_dns_tsig_id,
	secondary_dns_peer,
	secondary_dns_schemas_response_collection,
	secondary_dns_schemas_single_response,
	secondary_dns_algo,
	secondary_dns_schemas_identifier,
	secondary_dns_schemas_name,
	secondary_dns_secret,
	secondary_dns_tsig,
	secondary_dns_response_collection,
	secondary_dns_single_response,
	secondary_dns_schemas_id_response,
	workers_kv_query,
	query,
	workers_kv_messages,
	workers_kv_api_response_common,
	workers_kv_api_response_single,
	workers_kv_result,
	workers_kv_schemas_result,
	workers_kv_api_response_common_failure,
	query__2,
	workers_kv_components_schemas_result,
	workers_kv_result_info,
	workers_kv_api_response_collection,
	workers_kv_namespace_identifier,
	workers_kv_namespace_title,
	workers_kv_namespace,
	workers_kv_create_rename_namespace_body,
	workers_kv_key_name_bulk,
	workers_kv_bulk_delete,
	workers_kv_expiration,
	workers_kv_expiration_ttl,
	workers_kv_list_metadata,
	workers_kv_bulk_write,
	workers_kv_key_name,
	workers_kv_key,
	workers_kv_cursor,
	workers_kv_value,
	workers_kv_metadata,
	workers_kv_namespace_write_key_value_pair_with_metadata_Body,
	stream_messages,
	stream_api_response_common,
	stream_allowedOrigins,
	stream_created,
	stream_creator,
	stream_duration,
	stream_input,
	stream_liveInput,
	stream_maxDurationSeconds,
	stream_media_metadata,
	stream_modified,
	stream_playback,
	stream_preview,
	stream_readyToStream,
	stream_readyToStreamAt,
	stream_requireSignedURLs,
	stream_scheduledDeletion,
	stream_size,
	stream_errorReasonCode,
	stream_errorReasonText,
	stream_pctComplete,
	stream_media_state,
	stream_media_status,
	stream_thumbnail_url,
	stream_thumbnailTimestampPct,
	stream_identifier,
	stream_oneTimeUploadExpiry,
	stream_uploaded,
	stream_watermark_created,
	stream_downloadedFrom,
	stream_height,
	stream_name,
	stream_opacity,
	stream_padding,
	stream_position,
	stream_scale,
	stream_watermark_size,
	stream_watermark_identifier,
	stream_width,
	stream_watermarks,
	stream_videos,
	stream_video_response_collection,
	stream_api_response_common_failure,
	stream_clipped_from_video_uid,
	stream_end_time_seconds,
	stream_start_time_seconds,
	stream_watermarkAtUpload,
	stream_videoClipStandard,
	stream_clipping_created,
	stream_live_input_modified,
	stream_clipping,
	stream_clipResponseSingle,
	stream_watermark_at_upload,
	stream_video_copy_request,
	stream_api_response_single,
	stream_video_response_single,
	stream_direct_upload_request,
	stream_direct_upload_response,
	stream_signing_key_created,
	stream_schemas_identifier,
	stream_key_response_collection,
	stream_jwk,
	stream_pem,
	stream_keys,
	stream_key_generation_response,
	stream_deleted_response,
	stream_live_input_created,
	stream_live_input_recording_deletion,
	stream_live_input_metadata,
	stream_live_input_identifier,
	stream_live_input_object_without_url,
	stream_live_input_response_collection,
	stream_live_input_default_creator,
	stream_live_input_recording_allowedOrigins,
	stream_live_input_recording_mode,
	stream_live_input_recording_requireSignedURLs,
	stream_live_input_recording_timeoutSeconds,
	stream_live_input_recording_settings,
	stream_create_input_request,
	stream_input_rtmps_stream_key,
	stream_input_rtmps_url,
	stream_input_rtmps,
	stream_playback_rtmps_stream_key,
	stream_playback_rtmps_url,
	stream_playback_rtmps,
	stream_input_srt_stream_passphrase,
	stream_input_srt_stream_id,
	stream_input_srt_url,
	stream_input_srt,
	stream_playback_srt_stream_passphrase,
	stream_playback_srt_stream_id,
	stream_playback_srt_url,
	stream_playback_srt,
	stream_live_input_status,
	stream_input_webrtc_url,
	stream_input_webrtc,
	stream_playback_webrtc_url,
	stream_playback_webrtc,
	stream_live_input,
	stream_live_input_response_single,
	stream_update_input_request,
	stream_output_enabled,
	stream_output_streamKey,
	stream_output_identifier,
	stream_output_url,
	stream_output,
	stream_output_response_collection,
	stream_create_output_request,
	stream_output_response_single,
	stream_update_output_request,
	stream_storage_use_response,
	stream_watermark_response_collection,
	stream_watermark_basic_upload,
	stream_watermark_response_single,
	stream_webhook_response_single,
	stream_notificationUrl,
	stream_webhook_request,
	stream_video_update,
	stream_audio_default,
	stream_audio_label,
	stream_audio_state,
	stream_additionalAudio,
	stream_listAudioTrackResponse,
	stream_copyAudioTrack,
	stream_addAudioTrackResponse,
	stream_editAudioTrack,
	stream_label,
	stream_language,
	stream_captions,
	stream_language_response_collection,
	stream_caption_basic_upload,
	stream_language_response_single,
	stream_downloads_response,
	stream_accessRules,
	stream_signed_token_request,
	stream_signed_token_response,
	tunnel_comment,
	tunnel_route_id,
	tunnel_ip_network,
	tunnel_route_tunnel_id,
	tunnel_route_tunnel_name,
	tunnel_route_virtual_network_id,
	tunnel_vnet_name,
	tunnel_teamnet,
	tunnel_teamnet_response_collection,
	tunnel_route_create_a_tunnel_route_Body,
	tunnel_route,
	tunnel_route_response_single,
	tunnel_teamnet_response_single,
	tunnel_route_update_a_tunnel_route_Body,
	tunnel_schemas_comment,
	tunnel_vnet_id,
	tunnel_is_default_network,
	tunnel_virtual_network,
	tunnel_vnet_response_collection,
	tunnel_virtual_network_create_a_virtual_network_Body,
	tunnel_vnet_response_single,
	tunnel_virtual_network_update_a_virtual_network_Body,
	cloudflare_tunnel_create_a_warp_connector_tunnel_Body,
	workers_messages,
	workers_api_response_common,
	workers_account_settings_response,
	workers_api_response_common_failure,
	workers_deployments_list_response,
	workers_deployments_single_response,
	workers_identifier,
	workers_created_on,
	workers_modified_on,
	workers_uuid,
	workers_dispatch_namespace_name,
	workers_namespace_response,
	workers_namespace_list_response,
	workers_namespace_single_response,
	workers_namespace_delete_response,
	workers_etag,
	workers_logpush,
	workers_pipeline_hash,
	workers_placement_mode,
	workers_tail_consumers_script,
	workers_tail_consumers,
	workers_usage_model,
	workers_script_response,
	workers_namespace_script_response,
	workers_namespace_script_response_single,
	workers_migration_tag_conditions,
	workers_migration_step,
	workers_single_step_migrations,
	workers_stepped_migrations,
	workers_placement_config,
	namespace_worker_script_upload_worker_module_Body,
	workers_api_response_single,
	workers_script_response_single,
	workers_binding_name,
	workers_namespace_identifier,
	workers_kv_namespace_binding,
	workers_service_binding,
	workers_do_binding,
	workers_r2_binding,
	workers_queue_binding,
	workers_d1_binding,
	workers_dispatch_namespace_binding,
	workers_mtls_cert_binding,
	workers_binding,
	namespace_worker_put_script_content_Body,
	workers_bindings,
	workers_compatibility_date,
	workers_compatibility_flag,
	workers_compatibility_flags,
	workers_tag,
	workers_tags,
	workers_script_settings_response,
	workers_schemas_environment,
	workers_hostname,
	workers_domain_identifier,
	workers_schemas_service,
	workers_zone_identifier,
	workers_zone_name,
	workers_domain,
	workers_domain_response_collection,
	worker_domain_attach_to_domain_Body,
	workers_domain_response_single,
	workers_result_info,
	workers_api_response_collection,
	workers_namespace,
	workers_object,
	workers_cursor,
	workers_name,
	workers_queue,
	workers_queue_created,
	workers_renamed_name,
	workers_queue_updated,
	workers_batch_size,
	workers_max_retries,
	workers_max_wait_time_ms,
	workers_consumer,
	workers_dlq_name,
	workers_consumer_created,
	workers_consumer_updated,
	workers_script_response_collection,
	workers_cron_trigger_response_collection,
	worker_script_patch_settings_Body,
	workers_tail_response,
	workers_usage_model_response,
	workers_subdomain_response,
	tunnel_icmp_proxy_enabled,
	tunnel_offramp_warp_enabled,
	tunnel_zero_trust_connectivity_settings_response,
	zero_trust_accounts_patch_connectivity_settings_Body,
	access_messages,
	access_api_response_common,
	access_result_info,
	access_api_response_collection,
	access_schemas_aud,
	access_timestamp,
	access_uuid,
	access_basic_app_response_props,
	access_schemas_allow_authenticate_via_warp,
	access_allowed_idps,
	access_app_launcher_visible,
	access_schemas_auto_redirect_to_identity,
	access_allow_all_headers,
	access_allow_all_methods,
	access_allow_all_origins,
	access_allow_credentials,
	access_allowed_headers,
	access_allowed_methods,
	access_allowed_origins,
	access_max_age,
	access_cors_headers,
	access_custom_deny_message,
	access_custom_deny_url,
	access_custom_non_identity_deny_url,
	access_schemas_custom_pages,
	access_domain,
	access_enable_binding_cookie,
	access_http_only_cookie_attribute,
	access_logo_url,
	access_apps_components_schemas_name,
	access_path_cookie_attribute,
	access_same_site_cookie_attribute,
	access_self_hosted_domains,
	access_service_auth_401_redirect,
	access_schemas_session_duration,
	access_skip_interstitial,
	access_tags,
	access_self_hosted_props,
	access_saml_saas_app,
	access_oidc_saas_app,
	access_saas_props,
	access_ssh_props,
	access_vnc_props,
	access_type,
	access_feature_app_props,
	access_app_launcher_props,
	access_warp_props,
	access_biso_props,
	access_bookmark_props,
	access_apps,
	access_apps_components_schemas_response_collection,
	access_api_response_common_failure,
	access_api_response_single,
	access_apps_components_schemas_single_response,
	access_aud,
	access_id,
	access_public_key,
	access_ca,
	access_ca_components_schemas_response_collection,
	access_identifier,
	app_id,
	access_id_response,
	access_schemas_empty_response,
	access_policy_check_response,
	access_approval_group,
	access_approval_groups,
	access_approval_required,
	access_decision,
	access_email_rule,
	access_email_list_rule,
	access_domain_rule,
	access_everyone_rule,
	access_ip_rule,
	access_ip_list_rule,
	access_certificate_rule,
	access_access_group_rule,
	access_azure_group_rule,
	access_github_organization_rule,
	access_gsuite_group_rule,
	access_okta_group_rule,
	access_saml_group_rule,
	access_service_token_rule,
	access_any_valid_service_token_rule,
	access_external_evaluation_rule,
	access_country_rule,
	access_authentication_method_rule,
	access_device_posture_rule,
	access_rule,
	access_schemas_exclude,
	access_include,
	access_isolation_required,
	access_policies_components_schemas_name,
	access_precedence,
	access_purpose_justification_prompt,
	access_purpose_justification_required,
	access_schemas_require,
	access_components_schemas_session_duration,
	access_policies,
	access_policies_components_schemas_single_response,
	access_schemas_id_response,
	access_ca_components_schemas_single_response,
	access_policies_components_schemas_response_collection,
	access_associated_hostnames,
	access_fingerprint,
	access_certificates_components_schemas_name,
	access_certificates,
	access_certificates_components_schemas_response_collection,
	access_certificates_components_schemas_single_response,
	access_settings,
	access_response_collection_hostnames,
	access_mtls_authentication_update_an_mtls_certificate_settings_Body,
	access_components_schemas_id_response,
	access_app_count,
	access_custom_pages_components_schemas_name,
	access_schemas_type,
	access_custom_page_without_html,
	access_custom_pages_components_schemas_response_collection,
	access_custom_page,
	access_single_response_without_html,
	access_custom_pages_components_schemas_single_response,
	access_exclude,
	access_require,
	access_components_schemas_name,
	access_groups,
	access_schemas_response_collection,
	access_is_default,
	access_components_schemas_single_response,
	access_schemas_name,
	access_identity_provider,
	access_generic_oauth_config,
	access_custom_claims_support,
	access_azureAD,
	access_centrify,
	access_facebook,
	access_github,
	access_google,
	access_google_apps,
	access_linkedin,
	access_oidc,
	access_okta,
	access_onelogin,
	access_pingone,
	access_saml,
	access_yandex,
	access_response_collection,
	access_onetimepin,
	access_identity_providers,
	access_schemas_single_response,
	access_days_until_next_rotation,
	access_key_rotation_interval_days,
	access_last_key_rotation_at,
	access_key_config,
	access_keys_components_schemas_single_response,
	access_action,
	access_allowed,
	access_app_domain,
	access_app_uid,
	access_connection,
	access_ip,
	access_ray_id,
	access_email,
	access_access_requests,
	access_access_requests_components_schemas_response_collection,
	access_allow_authenticate_via_warp,
	access_auth_domain,
	access_auto_redirect_to_identity,
	access_custom_pages,
	access_is_ui_read_only,
	access_login_design,
	access_name,
	access_session_duration,
	access_ui_read_only_toggle_reason,
	access_user_seat_expiration_inactive_time,
	access_warp_auth_session_duration,
	access_organizations,
	access_single_response,
	access_empty_response,
	access_access_seat,
	access_gateway_seat,
	access_seat,
	access_seats_definition,
	access_seats,
	access_seats_components_schemas_response_collection,
	access_client_id,
	access_duration,
	access_service_tokens_components_schemas_name,
	access_service_tokens,
	access_components_schemas_response_collection,
	access_client_secret,
	access_create_response,
	access_service_tokens_components_schemas_single_response,
	access_tags_components_schemas_name,
	access_tag,
	access_tags_components_schemas_response_collection,
	access_tag_without_app_count,
	access_tags_components_schemas_single_response,
	access_name_response,
	access_schemas_access_seat,
	access_active_device_count,
	access_schemas_email,
	access_schemas_gateway_seat,
	access_last_successful_login,
	access_users_components_schemas_name,
	access_seat_uid,
	access_uid,
	access_users,
	access_users_components_schemas_response_collection,
	access_active_sessions_response,
	access_device_posture_check,
	access_schemas_device_posture_rule,
	access_device_session,
	access_string_key_map_device_session,
	access_geo,
	access_identity,
	access_active_session_response,
	access_failed_login_response,
	access_last_seen_identity_response,
	tls_certificates_and_hostnames_components_schemas_certificate,
	tls_certificates_and_hostnames_csr,
	tls_certificates_and_hostnames_schemas_expires_on,
	tls_certificates_and_hostnames_hostnames,
	tls_certificates_and_hostnames_request_type,
	tls_certificates_and_hostnames_requested_validity,
	tls_certificates_and_hostnames_certificates,
	tls_certificates_and_hostnames_schemas_certificate_response_collection,
	origin_ca_create_certificate_Body,
	tls_certificates_and_hostnames_schemas_certificate_response_single,
	tls_certificates_and_hostnames_certificate_response_single_id,
	addressing_etag,
	addressing_ipv4_cidrs,
	addressing_ipv6_cidrs,
	addressing_ips,
	addressing_jdcloud_cidrs,
	addressing_ips_jdcloud,
	iam_schemas_account,
	iam_api_access_enabled,
	iam_roles,
	iam_schemas_status,
	iam_membership,
	iam_collection_membership_response,
	iam_single_membership_response,
	iam_single_user_response,
	iam_country,
	iam_telephone,
	iam_zipcode,
	legacy_jhs_rule_collection_response,
	legacy_jhs_rule_single_response,
	legacy_jhs_rule_single_id_response,
	iam_schemas_expires_on,
	iam_invite_components_schemas_identifier,
	iam_invited_by,
	iam_invited_member_email,
	iam_invited_on,
	iam_base,
	iam_user_invite,
	iam_schemas_invite,
	iam_schemas_collection_invite_response,
	iam_single_invite_response,
	load_balancing_analytics,
	load_balancing_components_schemas_response_collection,
	iam_schemas_name,
	iam_components_schemas_status,
	iam_organization,
	iam_collection_organization_response,
	iam_single_organization_response,
	bill_subs_api_user_subscription_response_collection,
	bill_subs_api_user_subscription_response_single,
	iam_cidr_list,
	iam_request_ip,
	iam_condition,
	iam_expires_on,
	iam_name,
	iam_not_before,
	iam_effect,
	iam_identifier,
	iam_permission_group,
	iam_permission_groups,
	iam_resources,
	iam_policy_with_permission_groups,
	iam_access_policy,
	iam_policies,
	iam_create_payload,
	iam_value,
	iam_response_create,
	iam_schemas_response_collection,
	iam_components_schemas_identifier,
	iam_status,
	iam_response_single_segment,
	iam_issued_on,
	iam_modified_on,
	iam_token,
	iam_schemas_token,
	iam_response_single_value,
	zones_messages,
	zones_api_response_common,
	zones_result_info,
	zones_identifier,
	zones_zone,
	zones_api_response_common_failure,
	zones_name,
	zones_type,
	zones_post_Body,
	access_schemas_custom_deny_url,
	access_components_schemas_domain,
	access_schemas_self_hosted_props,
	access_schemas_saml_saas_app,
	access_schemas_saas_props,
	access_schemas_ssh_props,
	access_schemas_vnc_props,
	access_schemas_feature_app_props,
	access_schemas_app_launcher_props,
	access_schemas_warp_props,
	access_schemas_biso_props,
	access_schemas_bookmark_props,
	access_schemas_apps,
	access_apps_components_schemas_response_collection_2,
	access_apps_components_schemas_single_response_2,
	access_schemas_isolation_required,
	access_schemas_policies,
	access_policies_components_schemas_single_response_2,
	access_policies_components_schemas_response_collection_2,
	access_schemas_groups,
	access_groups_components_schemas_response_collection,
	access_groups_components_schemas_single_response,
	access_schemas_identity_provider,
	access_schemas_azureAD,
	access_schemas_centrify,
	access_schemas_facebook,
	access_schemas_github,
	access_schemas_google,
	access_schemas_google_apps,
	access_schemas_linkedin,
	access_schemas_oidc,
	access_schemas_okta,
	access_schemas_onelogin,
	access_schemas_pingone,
	access_schemas_saml,
	access_schemas_yandex,
	access_schemas_onetimepin,
	access_identity_providers_components_schemas_response_collection,
	access_schemas_identity_providers,
	access_identity_providers_components_schemas_single_response,
	access_schemas_organizations,
	access_organizations_components_schemas_single_response,
	bill_subs_api_zone_subscription_response_single,
	bill_subs_api_can_subscribe,
	bill_subs_api_externally_managed,
	bill_subs_api_schemas_frequency,
	bill_subs_api_is_subscribed,
	bill_subs_api_legacy_discount,
	bill_subs_api_legacy_id,
	bill_subs_api_schemas_name,
	bill_subs_api_schemas_price,
	bill_subs_api_available_rate_plan,
	bill_subs_api_default,
	bill_subs_api_components_schemas_name,
	bill_subs_api_unit_price,
	bill_subs_api_schemas_component_values,
	bill_subs_api_duration,
	bill_subs_api_rate_plan_components_schemas_identifier,
	bill_subs_api_schemas_rate_plan,
	bill_subs_api_plan_response_collection,
	email_email_setting_created,
	email_email_setting_enabled,
	email_email_setting_identifier,
	email_email_setting_modified,
	email_email_setting_name,
	email_email_setting_skip_wizard,
	email_email_setting_status,
	email_email_setting_tag,
	email_email_settings_properties,
	email_settings,
	email_email_settings_response_single,
	email_dns_record,
	email_dns_settings_response_collection,
	email_rule_action,
	email_rule_actions,
	email_rule_enabled,
	email_rule_identifier,
	email_rule_matcher,
	email_rule_matchers,
	email_rule_name,
	email_rule_priority,
	email_rule_tag,
	email_rule_properties,
	email_rules,
	email_rules_response_collection,
	email_create_rule_properties,
	email_rule_response_single,
	email_rule_catchall_action,
	email_rule_catchall_actions,
	email_rule_catchall_matcher,
	email_rule_catchall_matchers,
	email_catch_all_rule,
	email_catch_all_rule_response_single,
	email_update_catch_all_rule_properties,
	email_update_rule_properties,
	legacy_jhs_filters_components_schemas_id,
	filters_delete_filters_Body,
	legacy_jhs_filters_components_schemas_description,
	legacy_jhs_expression,
	legacy_jhs_filters_components_schemas_paused,
	legacy_jhs_schemas_ref,
	legacy_jhs_filter,
	legacy_jhs_filter_delete_response_collection,
	legacy_jhs_schemas_filter_response_collection,
	legacy_jhs_filter_delete_response_single,
	legacy_jhs_schemas_filter_response_single,
	legacy_jhs_schemas_ip_configuration,
	legacy_jhs_schemas_cidr_configuration,
	legacy_jhs_configurations,
	legacy_jhs_created_on,
	legacy_jhs_lockdowns_components_schemas_description,
	legacy_jhs_lockdowns_components_schemas_id,
	legacy_jhs_components_schemas_modified_on,
	legacy_jhs_schemas_paused,
	legacy_jhs_schemas_urls,
	legacy_jhs_zonelockdown,
	legacy_jhs_zonelockdown_response_collection,
	legacy_jhs_zonelockdown_response_single,
	legacy_jhs_firewall_rules_components_schemas_id,
	firewall_rules_delete_firewall_rules_Body,
	legacy_jhs_components_schemas_action,
	legacy_jhs_firewall_rules_components_schemas_description,
	legacy_jhs_components_schemas_paused,
	legacy_jhs_firewall_rules_components_schemas_priority,
	legacy_jhs_products,
	legacy_jhs_ref,
	legacy_jhs_filter_rule_base,
	legacy_jhs_deleted,
	legacy_jhs_deleted_filter,
	legacy_jhs_filter_rule_response,
	legacy_jhs_filter_rules_response_collection_delete,
	legacy_jhs_filter_rules_response_collection,
	legacy_jhs_delete_filter_if_unused,
	firewall_rules_delete_a_firewall_rule_Body,
	legacy_jhs_filter_rules_single_response_delete,
	legacy_jhs_filter_rules_single_response,
	legacy_jhs_components_schemas_configuration,
	legacy_jhs_ua_rules_components_schemas_description,
	legacy_jhs_ua_rules_components_schemas_id,
	legacy_jhs_ua_rules_components_schemas_mode,
	legacy_jhs_firewalluablock,
	legacy_jhs_ua_rules,
	legacy_jhs_firewalluablock_response_collection,
	legacy_jhs_firewalluablock_response_single,
	legacy_jhs_overrides_components_schemas_description,
	legacy_jhs_groups,
	legacy_jhs_overrides_components_schemas_id,
	legacy_jhs_paused,
	legacy_jhs_components_schemas_priority,
	legacy_jhs_waf_rewrite_action,
	legacy_jhs_rewrite_action,
	legacy_jhs_waf_action,
	legacy_jhs_rules,
	legacy_jhs_urls,
	legacy_jhs_override,
	legacy_jhs_override_response_collection,
	legacy_jhs_override_response_single,
	legacy_jhs_package_components_schemas_description,
	legacy_jhs_detection_mode,
	legacy_jhs_package_components_schemas_identifier,
	legacy_jhs_package_components_schemas_name,
	legacy_jhs_package_components_schemas_status,
	legacy_jhs_package_definition,
	legacy_jhs_action_mode,
	legacy_jhs_anomaly_description,
	legacy_jhs_anomaly_detection_mode,
	legacy_jhs_anomaly_name,
	legacy_jhs_sensitivity,
	legacy_jhs_anomaly_package,
	legacy_jhs_package,
	legacy_jhs_package_response_collection,
	legacy_jhs_package_response_single,
	waf_packages_update_a_waf_package_Body,
	healthchecks_messages,
	healthchecks_api_response_common,
	healthchecks_result_info,
	healthchecks_api_response_collection,
	healthchecks_address,
	healthchecks_check_regions,
	healthchecks_consecutive_fails,
	healthchecks_consecutive_successes,
	healthchecks_timestamp,
	healthchecks_description,
	healthchecks_failure_reason,
	healthchecks_http_config,
	healthchecks_identifier,
	healthchecks_interval,
	healthchecks_name,
	healthchecks_retries,
	healthchecks_status,
	healthchecks_suspended,
	healthchecks_tcp_config,
	healthchecks_timeout,
	healthchecks_type,
	healthchecks_healthchecks,
	healthchecks_response_collection,
	healthchecks_api_response_common_failure,
	healthchecks_query_healthcheck,
	healthchecks_api_response_single,
	healthchecks_single_response,
	healthchecks_id_response,
	data_zone_analytics_api_messages,
	data_zone_analytics_api_api_response_common,
	data_zone_analytics_api_api_response_single,
	data_zone_analytics_api_flag_response,
	data_zone_analytics_api_api_response_common_failure,
	data_zone_analytics_api_flag,
	logs_received_update_log_retention_flag_Body,
	data_zone_analytics_api_logs,
	end,
	start,
	data_zone_analytics_api_fields_response,
	legacy_jhs_mode,
	legacy_jhs_body,
	legacy_jhs_content_type,
	legacy_jhs_custom_response,
	legacy_jhs_timeout,
	legacy_jhs_schemas_action,
	legacy_jhs_bypass,
	legacy_jhs_components_schemas_description,
	legacy_jhs_disabled,
	legacy_jhs_rate_limits_components_schemas_id,
	legacy_jhs_header_name,
	legacy_jhs_header_op,
	legacy_jhs_header_value,
	legacy_jhs_methods,
	legacy_jhs_schemes,
	legacy_jhs_schemas_url,
	legacy_jhs_origin_traffic,
	legacy_jhs_match,
	legacy_jhs_period,
	legacy_jhs_threshold,
	legacy_jhs_ratelimit,
	legacy_jhs_rate_limits,
	legacy_jhs_ratelimit_response_collection,
	legacy_jhs_ratelimit_response_single,
	snippets_api_messages,
	snippets_api_api_response_common,
	snippets_api_snippet_name,
	snippets_api_snippet,
	snippets_api_api_response_common_failure,
	snippets_api_rules,
	zone_snippets_snippet_rules_put_Body,
	zone_snippets_snippet_put_Body,
	legacy_jhs_id,
	legacy_jhs_timestamp,
	legacy_jhs_ssl_recommender_components_schemas_value,
	waitingroom_messages,
	waitingroom_schemas_api_response_common,
	waitingroom_result_info,
	waitingroom_api_response_collection,
	waitingroom_additional_routes,
	waitingroom_cookie_attributes,
	waitingroom_cookie_suffix,
	waitingroom_timestamp,
	waitingroom_custom_page_html,
	waitingroom_default_template_language,
	waitingroom_description,
	waitingroom_disable_session_renewal,
	waitingroom_host,
	waitingroom_waiting_room_id,
	waitingroom_json_response_enabled,
	waitingroom_name,
	waitingroom_new_users_per_minute,
	waitingroom_next_event_prequeue_start_time,
	waitingroom_next_event_start_time,
	waitingroom_path,
	waitingroom_queue_all,
	waitingroom_queueing_method,
	waitingroom_queueing_status_code,
	waitingroom_session_duration,
	waitingroom_suspended,
	waitingroom_total_active_users,
	waitingroom_waitingroom,
	waitingroom_response_collection,
	waitingroom_api_response_common_failure,
	waitingroom_query_waitingroom,
	waitingroom_api_response_common,
	waitingroom_api_response_single,
	waitingroom_single_response,
	waitingroom_query_preview,
	waitingroom_preview_url,
	waitingroom_preview_response,
	waitingroom_search_engine_crawler_bypass,
	waitingroom_zone_settings_response,
	waitingroom_zone_settings,
	waitingroom_waiting_room_id_response,
	waitingroom_event_custom_page_html,
	waitingroom_event_description,
	waitingroom_event_disable_session_renewal,
	waitingroom_event_end_time,
	waitingroom_event_start_time,
	waitingroom_event_id,
	waitingroom_event_name,
	waitingroom_event_new_users_per_minute,
	waitingroom_event_prequeue_start_time,
	waitingroom_event_queueing_method,
	waitingroom_event_session_duration,
	waitingroom_event_shuffle_at_event_start,
	waitingroom_event_suspended,
	waitingroom_event_total_active_users,
	waitingroom_event_result,
	waitingroom_event_response_collection,
	waitingroom_query_event,
	waitingroom_event_response,
	waitingroom_event_id_response,
	waitingroom_event_details_custom_page_html,
	waitingroom_event_details_disable_session_renewal,
	waitingroom_event_details_new_users_per_minute,
	waitingroom_event_details_queueing_method,
	waitingroom_event_details_session_duration,
	waitingroom_event_details_total_active_users,
	waitingroom_event_details_result,
	waitingroom_event_details_response,
	waitingroom_rule_action,
	waitingroom_rule_description,
	waitingroom_rule_enabled,
	waitingroom_rule_expression,
	waitingroom_rule_id,
	waitingroom_rule_version,
	waitingroom_rule_result,
	waitingroom_rules_response_collection,
	waitingroom_create_rule,
	waitingroom_update_rules,
	waitingroom_rule_position,
	waitingroom_patch_rule,
	waitingroom_estimated_queued_users,
	waitingroom_estimated_total_active_users,
	waitingroom_status_event_id,
	waitingroom_max_estimated_time_minutes,
	waitingroom_status,
	waitingroom_status_response,
	dweb_config_messages,
	dweb_config_api_response_common,
	dweb_config_result_info,
	dweb_config_api_response_collection,
	dweb_config_timestamp,
	dweb_config_description,
	dweb_config_dnslink,
	dweb_config_identifier,
	dweb_config_name,
	dweb_config_status,
	dweb_config_target,
	dweb_config_web3_hostname,
	dweb_config_collection_response,
	dweb_config_api_response_common_failure,
	dweb_config_create_request,
	dweb_config_api_response_single,
	dweb_config_single_response,
	dweb_config_api_response_single_id,
	dweb_config_modify_request,
	dweb_config_content_list_action,
	dweb_config_content_list_details,
	dweb_config_content_list_details_response,
	dweb_config_content_list_entry_content,
	dweb_config_content_list_entry_description,
	dweb_config_content_list_entry_type,
	dweb_config_content_list_entry,
	dweb_config_content_list_entries,
	dweb_config_content_list_update_request,
	dweb_config_content_list_entry_collection_response,
	dweb_config_content_list_entry_create_request,
	dweb_config_content_list_entry_single_response,
	zones_api_response_single_id,
	zones_paused,
	zones_vanity_name_servers,
	zones_0_patch_Body,
	tls_certificates_and_hostnames_components_schemas_certificate_authority,
	tls_certificates_and_hostnames_components_schemas_enabled,
	tls_certificates_and_hostnames_schemas_validity_days,
	tls_certificates_and_hostnames_total_tls_settings_response,
	zone_activation_messages,
	zone_activation_api_response_common,
	zone_activation_api_response_single,
	zone_activation_identifier,
	zone_activation_api_response_common_failure,
	argo_analytics_messages,
	argo_analytics_api_response_common,
	argo_analytics_api_response_single,
	argo_analytics_response_single,
	argo_analytics_api_response_common_failure,
	api_shield_messages,
	api_shield_api_response_common,
	api_shield_api_response_single,
	api_shield_name,
	api_shield_type,
	api_shield_characteristics,
	api_shield_configuration,
	api_shield_single_response,
	api_shield_api_response_common_failure,
	api_shield_default_response,
	api_shield_openapi,
	api_shield_timestamp,
	api_shield_schema_response_discovery,
	api_shield_result_info,
	api_shield_api_response_collection,
	api_shield_traffic_stats,
	api_shield_uuid,
	api_shield_api_discovery_origin,
	api_shield_api_discovery_state,
	api_shield_endpoint,
	api_shield_host,
	api_shield_method,
	api_shield_basic_operation,
	api_shield_discovery_operation,
	api_shield_api_discovery_state_patch,
	api_shield_api_discovery_patch_multiple_request_entry,
	api_shield_api_discovery_patch_multiple_request,
	api_shield_patch_discoveries_response,
	api_shield_api_patch_discovered_operation_Body,
	api_shield_patch_discovery_response,
	api_shield_auth_id_tokens,
	api_shield_data_points,
	api_shield_p50,
	api_shield_p90,
	api_shield_p99,
	api_shield_period_seconds,
	api_shield_requests,
	api_shield_suggested_threshold,
	api_shield_operation_feature_thresholds,
	api_shield_parameter_schemas_definition,
	api_shield_operation_feature_parameter_schemas,
	api_shield_operation_features,
	api_shield_operation,
	api_shield_api_shield,
	api_shield_collection_response_paginated,
	api_shield_collection_response,
	api_shield_operation_mitigation_action,
	api_shield_operation_schema_validation_settings_multiple_request_entry,
	api_shield_operation_schema_validation_settings_multiple_request,
	api_shield_schemas_single_response,
	api_shield_operation_schema_validation_settings,
	api_shield_openapiwiththresholds,
	api_shield_schema_response_with_thresholds,
	api_shield_validation_default_mitigation_action,
	api_shield_validation_override_mitigation_action,
	api_shield_zone_schema_validation_settings,
	api_shield_validation_default_mitigation_action_patch,
	api_shield_validation_override_mitigation_action_patch,
	api_shield_zone_schema_validation_settings_patch,
	api_shield_validation_override_mitigation_action_write,
	api_shield_zone_schema_validation_settings_put,
	api_shield_kind,
	api_shield_validation_enabled,
	api_shield_public_schema,
	api_shield_schema_validation_post_schema_Body,
	api_shield_schema_upload_log_event,
	api_shield_schema_upload_details_warnings_only,
	api_shield_schema_upload_response,
	api_shield_schema_upload_details_errors_critical,
	api_shield_schema_upload_failure,
	api_shield_schema_validation_enable_validation_for_a_schema_Body,
	argo_config_messages,
	argo_config_api_response_common,
	argo_config_api_response_single,
	argo_config_response_single,
	argo_config_api_response_common_failure,
	argo_config_value,
	argo_config_patch,
	cache_messages,
	cache_api_response_common,
	cache_api_response_single,
	cache_response_single,
	cache_api_response_common_failure,
	cache_value,
	cache_patch,
	bot_management_messages,
	bot_management_api_response_common,
	bot_management_api_response_single,
	bot_management_enable_js,
	bot_management_using_latest_model,
	bot_management_base_config,
	bot_management_fight_mode,
	bot_management_bot_fight_mode_config,
	bot_management_optimize_wordpress,
	bot_management_sbfm_definitely_automated,
	bot_management_sbfm_static_resource_protection,
	bot_management_sbfm_verified_bots,
	bot_management_sbfm_definitely_config,
	bot_management_sbfm_likely_automated,
	bot_management_sbfm_likely_config,
	bot_management_auto_update_model,
	bot_management_suppress_session_score,
	bot_management_bm_subscription_config,
	bot_management_bot_management_response_body,
	bot_management_api_response_common_failure,
	bot_management_config_single,
	cache_zone_cache_settings_response_single,
	cache_base,
	cache_cache_reserve,
	cache_cache_reserve_value,
	cache_cache_reserve_response_value,
	cache_cache_reserve_clear,
	cache_cache_reserve_clear_end_ts,
	cache_cache_reserve_clear_start_ts,
	cache_cache_reserve_clear_state,
	cache_cache_reserve_clear_response_value,
	cache_origin_post_quantum_encryption_value,
	cache_regional_tiered_cache,
	cache_regional_tiered_cache_response_value,
	cache_regional_tiered_cache_value,
	cache_schemas_value,
	cache_schemas_patch,
	cache_variants,
	cache_variants_value,
	cache_variants_response_value,
	tls_certificates_and_hostnames_hostname_association,
	tls_certificates_and_hostnames_hostname_associations_response,
	tls_certificates_and_hostnames_client_certificates_components_schemas_certificate,
	tls_certificates_and_hostnames_client_certificates_components_schemas_certificate_authority,
	tls_certificates_and_hostnames_common_name,
	tls_certificates_and_hostnames_country,
	tls_certificates_and_hostnames_schemas_csr,
	tls_certificates_and_hostnames_expired_on,
	tls_certificates_and_hostnames_fingerprint_sha256,
	tls_certificates_and_hostnames_issued_on,
	tls_certificates_and_hostnames_location,
	tls_certificates_and_hostnames_organization,
	tls_certificates_and_hostnames_organizational_unit,
	tls_certificates_and_hostnames_components_schemas_serial_number,
	tls_certificates_and_hostnames_components_schemas_signature,
	tls_certificates_and_hostnames_ski,
	tls_certificates_and_hostnames_state,
	tls_certificates_and_hostnames_client_certificates_components_schemas_status,
	tls_certificates_and_hostnames_components_schemas_validity_days,
	tls_certificates_and_hostnames_client_certificate,
	tls_certificates_and_hostnames_client_certificate_response_collection,
	client_certificate_for_a_zone_create_client_certificate_Body,
	tls_certificates_and_hostnames_client_certificate_response_single,
	tls_certificates_and_hostnames_bundle_method,
	tls_certificates_and_hostnames_expires_on,
	tls_certificates_and_hostnames_geo_restrictions,
	tls_certificates_and_hostnames_hosts,
	tls_certificates_and_hostnames_issuer,
	tls_certificates_and_hostnames_enabled,
	tls_certificates_and_hostnames_host,
	tls_certificates_and_hostnames_schemas_identifier,
	tls_certificates_and_hostnames_name,
	tls_certificates_and_hostnames_port,
	tls_certificates_and_hostnames_schemas_status,
	tls_certificates_and_hostnames_keyless_private_ip,
	tls_certificates_and_hostnames_keyless_vnet_id,
	tls_certificates_and_hostnames_keyless_tunnel,
	tls_certificates_and_hostnames_base,
	tls_certificates_and_hostnames_keyless_certificate,
	tls_certificates_and_hostnames_modified_on,
	tls_certificates_and_hostnames_policy,
	tls_certificates_and_hostnames_priority,
	tls_certificates_and_hostnames_status,
	tls_certificates_and_hostnames_uploaded_on,
	tls_certificates_and_hostnames_custom_certificate,
	tls_certificates_and_hostnames_certificate_response_collection,
	tls_certificates_and_hostnames_certificate,
	tls_certificates_and_hostnames_private_key,
	tls_certificates_and_hostnames_type,
	custom_ssl_for_a_zone_create_ssl_configuration_Body,
	tls_certificates_and_hostnames_certificate_response_single,
	tls_certificates_and_hostnames_certificate_response_id_only,
	custom_ssl_for_a_zone_edit_ssl_configuration_Body,
	tls_certificates_and_hostnames_created_at,
	tls_certificates_and_hostnames_custom_metadata,
	tls_certificates_and_hostnames_custom_origin_server,
	tls_certificates_and_hostnames_custom_origin_sni,
	tls_certificates_and_hostnames_hostname,
	tls_certificates_and_hostnames_ownership_verification,
	tls_certificates_and_hostnames_ownership_verification_http,
	tls_certificates_and_hostnames_certificate_authority,
	tls_certificates_and_hostnames_sslsettings,
	tls_certificates_and_hostnames_validation_record,
	tls_certificates_and_hostnames_ssl,
	tls_certificates_and_hostnames_components_schemas_status,
	tls_certificates_and_hostnames_verification_errors,
	tls_certificates_and_hostnames_customhostname,
	tls_certificates_and_hostnames_custom_hostname,
	tls_certificates_and_hostnames_custom_hostname_response_collection,
	tls_certificates_and_hostnames_hostname_post,
	tls_certificates_and_hostnames_sslpost,
	custom_hostname_for_a_zone_create_custom_hostname_Body,
	tls_certificates_and_hostnames_custom_hostname_response_single,
	tls_certificates_and_hostnames_fallback_origin_response,
	tls_certificates_and_hostnames_origin,
	custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames_Body,
	custom_hostname_for_a_zone_edit_custom_hostname_Body,
	dns_custom_nameservers_zone_metadata,
	dns_custom_nameservers_get_response,
	dns_custom_nameservers_schemas_empty_response,
	tls_certificates_and_hostnames_uuid,
	tls_certificates_and_hostnames_uuidObject,
	tls_certificates_and_hostnames_dcv_delegation_response,
	dns_records_messages,
	dns_records_api_response_common,
	dns_records_result_info,
	dns_records_api_response_collection,
	dns_records_name,
	dns_records_proxied,
	dns_records_comment,
	dns_records_identifier,
	dns_records_tags,
	dns_records_ttl,
	dns_records_base,
	dns_records_ARecord,
	dns_records_AAAARecord,
	dns_records_CAARecord,
	dns_records_CERTRecord,
	dns_records_CNAMERecord,
	dns_records_DNSKEYRecord,
	dns_records_DSRecord,
	dns_records_HTTPSRecord,
	dns_records_LOCRecord,
	dns_records_priority,
	dns_records_MXRecord,
	dns_records_NAPTRRecord,
	dns_records_NSRecord,
	dns_records_PTRRecord,
	dns_records_SMIMEARecord,
	dns_records_SRVRecord,
	dns_records_SSHFPRecord,
	dns_records_SVCBRecord,
	dns_records_TLSARecord,
	dns_records_TXTRecord,
	dns_records_URIRecord,
	dns_records_dns_record,
	dns_records_dns_response_collection,
	dns_records_api_response_common_failure,
	dns_records_api_response_single,
	dns_records_dns_response_single,
	dns_records_for_a_zone_import_dns_records_Body,
	dns_records_dns_response_import_scan,
	dnssec_messages,
	dnssec_api_response_common,
	dnssec_api_response_single,
	dnssec_delete_dnssec_response_single,
	dnssec_api_response_common_failure,
	dnssec_algorithm,
	dnssec_digest,
	dnssec_digest_algorithm,
	dnssec_digest_type,
	dnssec_dnssec_multi_signer,
	dnssec_dnssec_presigned,
	dnssec_ds,
	dnssec_flags,
	dnssec_key_tag,
	dnssec_key_type,
	dnssec_modified_on,
	dnssec_public_key,
	dnssec_status,
	dnssec_dnssec,
	dnssec_dnssec_response_single,
	waf_managed_rules_messages,
	waf_managed_rules_api_response_common,
	waf_managed_rules_result_info,
	waf_managed_rules_api_response_collection,
	waf_managed_rules_description,
	waf_managed_rules_components_schemas_identifier,
	waf_managed_rules_modified_rules_count,
	waf_managed_rules_name,
	waf_managed_rules_identifier,
	waf_managed_rules_rules_count,
	waf_managed_rules_group,
	waf_managed_rules_mode,
	waf_managed_rules_allowed_modes,
	waf_managed_rules_schemas_group,
	waf_managed_rules_rule_group_response_collection,
	waf_managed_rules_api_response_common_failure,
	waf_managed_rules_api_response_single,
	waf_managed_rules_rule_group_response_single,
	waf_managed_rules_schemas_description,
	waf_managed_rules_rule_components_schemas_identifier,
	waf_managed_rules_priority,
	waf_managed_rules_base,
	waf_managed_rules_schemas_base,
	waf_managed_rules_mode_anomaly,
	waf_managed_rules_allowed_modes_anomaly,
	waf_managed_rules_anomaly_rule,
	waf_managed_rules_mode_deny_traditional,
	waf_managed_rules_allowed_modes_deny_traditional,
	waf_managed_rules_default_mode,
	waf_managed_rules_traditional_deny_rule,
	waf_managed_rules_mode_allow_traditional,
	waf_managed_rules_allowed_modes_allow_traditional,
	waf_managed_rules_traditional_allow_rule,
	waf_managed_rules_rule,
	waf_managed_rules_rule_response_collection,
	waf_managed_rules_rule_response_single,
	zones_schemas_api_response_common_failure,
	zones_schemas_api_response_common,
	zones_api_response_single,
	tls_certificates_and_hostnames_components_schemas_created_at,
	tls_certificates_and_hostnames_components_schemas_hostname,
	tls_certificates_and_hostnames_hostname_tls_settings_components_schemas_status,
	tls_certificates_and_hostnames_components_schemas_updated_at,
	tls_certificates_and_hostnames_value,
	tls_certificates_and_hostnames_per_hostname_settings_response_collection,
	tls_certificates_and_hostnames_settingObjectDelete,
	tls_certificates_and_hostnames_per_hostname_settings_response_delete,
	per_hostname_tls_settings_put_Body,
	tls_certificates_and_hostnames_settingObject,
	tls_certificates_and_hostnames_per_hostname_settings_response,
	tls_certificates_and_hostnames_keyless_response_collection,
	tls_certificates_and_hostnames_schemas_certificate,
	tls_certificates_and_hostnames_name_write,
	keyless_ssl_for_a_zone_create_keyless_ssl_configuration_Body,
	tls_certificates_and_hostnames_keyless_response_single,
	tls_certificates_and_hostnames_keyless_response_single_id,
	tls_certificates_and_hostnames_enabled_write,
	keyless_ssl_for_a_zone_edit_keyless_ssl_configuration_Body,
	load_balancing_adaptive_routing,
	load_balancing_country_pools,
	load_balancing_default_pools,
	load_balancing_components_schemas_description,
	load_balancing_components_schemas_enabled,
	load_balancing_fallback_pool,
	load_balancing_load_balancer_components_schemas_identifier,
	load_balancing_location_strategy,
	load_balancing_components_schemas_name,
	load_balancing_pop_pools,
	load_balancing_proxied,
	load_balancing_random_steering,
	load_balancing_region_pools,
	load_balancing_session_affinity,
	load_balancing_session_affinity_attributes,
	load_balancing_session_affinity_ttl,
	load_balancing_steering_policy,
	load_balancing_ttl,
	load_balancing_rules,
	load_balancing_load_balancer,
	load_balancing_load_balancer_components_schemas_response_collection,
	load_balancing_load_balancer_components_schemas_single_response,
	load_balancing_components_schemas_id_response,
	logpush_schemas_destination_conf,
	logpush_fields,
	logpush_filter,
	logpush_sample,
	logpush_session_id,
	logpush_instant_logs_job,
	logpush_instant_logs_job_response_collection,
	logpush_instant_logs_job_response_single,
	rulesets_enabled,
	rulesets_id,
	rulesets_request_model,
	rulesets_request_list,
	rulesets_messages,
	rulesets_api_response_common_failure,
	managed_transforms_update_status_of_managed_transforms_Body,
	rulesets_available,
	rulesets_response_model,
	rulesets_response_list,
	tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_certificate,
	tls_certificates_and_hostnames_components_schemas_expires_on,
	tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_status,
	tls_certificates_and_hostnames_schemas_uploaded_on,
	tls_certificates_and_hostnames_certificateObject,
	tls_certificates_and_hostnames_zone_authenticated_origin_pull,
	tls_certificates_and_hostnames_components_schemas_certificate_response_collection,
	zone_level_authenticated_origin_pulls_upload_certificate_Body,
	tls_certificates_and_hostnames_cert_id,
	tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_enabled,
	tls_certificates_and_hostnames_schemas_hostname,
	tls_certificates_and_hostnames_hostname_certid_input,
	tls_certificates_and_hostnames_config,
	tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_status,
	tls_certificates_and_hostnames_updated_at,
	tls_certificates_and_hostnames_components_schemas_uploaded_on,
	tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_certificate,
	tls_certificates_and_hostnames_schemas_created_at,
	tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_expires_on,
	tls_certificates_and_hostnames_serial_number,
	tls_certificates_and_hostnames_hostname_certid_object,
	tls_certificates_and_hostnames_hostname_authenticated_origin_pull,
	tls_certificates_and_hostnames_hostname_aop_response_collection,
	tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_certificate_response_collection,
	tls_certificates_and_hostnames_schemas_private_key,
	per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate_Body,
	tls_certificates_and_hostnames_schemas_certificateObject,
	tls_certificates_and_hostnames_components_schemas_certificate_response_single,
	tls_certificates_and_hostnames_hostname_aop_single_response,
	tls_certificates_and_hostnames_zone_authenticated_origin_pull_components_schemas_enabled,
	tls_certificates_and_hostnames_enabled_response,
	zone_level_authenticated_origin_pulls_set_enablement_for_zone_Body,
	page_shield_messages,
	page_shield_api_response_common,
	page_shield_api_response_single,
	page_shield_zone_settings_response_single,
	page_shield_enabled,
	page_shield_updated_at,
	page_shield_use_cloudflare_reporting_endpoint,
	page_shield_use_connection_url_path,
	page_shield_get_zone_settings_response,
	page_shield_api_response_common_failure,
	page_shield_update_zone_settings_response,
	page_shield_result_info,
	page_shield_api_response_collection,
	page_shield_connection,
	page_shield_list_zone_connections_response,
	page_shield_get_zone_connection_response,
	page_shield_pageshield_policy_action,
	page_shield_pageshield_policy_description,
	page_shield_pageshield_policy_enabled,
	page_shield_pageshield_policy_expression,
	page_shield_pageshield_policy_id,
	page_shield_pageshield_policy_value,
	page_shield_pageshield_policy,
	page_shield_list_zone_policies_response,
	page_shield_get_zone_policy_response,
	page_shield_script,
	page_shield_list_zone_scripts_response,
	page_shield_fetched_at,
	page_shield_hash,
	page_shield_js_integrity_score,
	page_shield_version,
	page_shield_get_zone_script_response,
	zones_route,
	zones_actions,
	zones_created_on,
	zones_schemas_identifier,
	zones_schemas_modified_on,
	zones_priority,
	zones_status,
	zones_string_constraint,
	zones_url_target,
	zones_target,
	zones_targets,
	zones_page_rule,
	zones_pagerule_response_collection,
	page_rules_create_a_page_rule_Body,
	zones_pagerule_response_single,
	zones_settings,
	zones_pagerule_settings_response_collection,
	zones_schemas_api_response_single_id,
	page_rules_edit_a_page_rule_Body,
	cache_purge_Tags,
	cache_purge_Hosts,
	cache_purge_Prefixes,
	cache_purge_Flex,
	cache_purge_Everything,
	cache_purge_File,
	cache_purge_UrlAndHeaders,
	cache_purge_Files,
	zone_purge_Body,
	cache_purge_messages,
	cache_purge_api_response_common,
	cache_purge_schemas_identifier,
	cache_purge_api_response_single_id,
	cache_purge_api_response_common_failure,
	secondary_dns_force_result,
	secondary_dns_force_response,
	secondary_dns_identifier,
	secondary_dns_id_response,
	secondary_dns_auto_refresh_seconds,
	secondary_dns_time,
	secondary_dns_name,
	secondary_dns_peers,
	secondary_dns_soa_serial,
	secondary_dns_single_response_incoming,
	secondary_dns_dns_secondary_secondary_zone,
	secondary_dns_single_response_outgoing,
	secondary_dns_single_request_outgoing,
	secondary_dns_disable_transfer_result,
	secondary_dns_disable_transfer_response,
	secondary_dns_enable_transfer_result,
	secondary_dns_enable_transfer_response,
	secondary_dns_schemas_force_result,
	secondary_dns_schemas_force_response,
	zones_base,
	zones_0rtt_value,
	zones_0rtt,
	zones_advanced_ddos_value,
	zones_advanced_ddos,
	zones_always_online_value,
	zones_always_online,
	zones_always_use_https_value,
	zones_always_use_https,
	zones_automatic_https_rewrites_value,
	zones_automatic_https_rewrites,
	zones_brotli_value,
	zones_brotli,
	zones_browser_cache_ttl_value,
	zones_browser_cache_ttl,
	zones_browser_check_value,
	zones_browser_check,
	zones_cache_level_value,
	zones_cache_level,
	zones_challenge_ttl_value,
	zones_challenge_ttl,
	zones_ciphers_value,
	zones_ciphers,
	zones_cname_flattening_value,
	zones_cname_flattening,
	zones_development_mode_value,
	zones_development_mode,
	zones_early_hints_value,
	zones_early_hints,
	zones_edge_cache_ttl_value,
	zones_edge_cache_ttl,
	zones_email_obfuscation_value,
	zones_email_obfuscation,
	zones_h2_prioritization_value,
	zones_h2_prioritization,
	zones_hotlink_protection_value,
	zones_hotlink_protection,
	zones_http2_value,
	zones_http2,
	zones_http3_value,
	zones_http3,
	zones_image_resizing_value,
	zones_image_resizing,
	zones_ip_geolocation_value,
	zones_ip_geolocation,
	zones_ipv6_value,
	zones_ipv6,
	zones_max_upload_value,
	zones_max_upload,
	zones_min_tls_version_value,
	zones_min_tls_version,
	zones_minify_value,
	zones_minify,
	zones_mirage_value,
	zones_mirage,
	zones_mobile_redirect_value,
	zones_mobile_redirect,
	zones_nel_value,
	zones_nel,
	zones_opportunistic_encryption_value,
	zones_opportunistic_encryption,
	zones_opportunistic_onion_value,
	zones_opportunistic_onion,
	zones_orange_to_orange_value,
	zones_orange_to_orange,
	zones_origin_error_page_pass_thru_value,
	zones_origin_error_page_pass_thru,
	zones_polish_value,
	zones_polish,
	zones_prefetch_preload_value,
	zones_prefetch_preload,
	zones_proxy_read_timeout_value,
	zones_proxy_read_timeout,
	zones_pseudo_ipv4_value,
	zones_pseudo_ipv4,
	zones_response_buffering_value,
	zones_response_buffering,
	zones_rocket_loader_value,
	zones_rocket_loader,
	zones_automatic_platform_optimization,
	zones_schemas_automatic_platform_optimization,
	zones_security_header_value,
	zones_security_header,
	zones_security_level_value,
	zones_security_level,
	zones_server_side_exclude_value,
	zones_server_side_exclude,
	zones_sha1_support_value,
	zones_sha1_support,
	zones_sort_query_string_for_cache_value,
	zones_sort_query_string_for_cache,
	zones_ssl_value,
	zones_ssl,
	zones_ssl_recommender_enabled,
	zones_ssl_recommender,
	zones_tls_1_2_only_value,
	zones_tls_1_2_only,
	zones_tls_1_3_value,
	zones_tls_1_3,
	zones_tls_client_auth_value,
	zones_tls_client_auth,
	zones_true_client_ip_header_value,
	zones_true_client_ip_header,
	zones_waf_value,
	zones_waf,
	zones_webp_value,
	zones_webp,
	zones_websockets_value,
	zones_websockets,
	zones_zone_settings_response_collection,
	zones_setting,
	zones_zone_settings_response_single,
	speed_messages,
	speed_api_response_common,
	speed_base,
	speed_cloudflare_fonts_value,
	speed_cloudflare_fonts,
	speed_api_response_common_failure,
	cache_origin_max_http_version,
	cache_origin_max_http_version_value,
	cache_origin_max_http_version_response_value,
	zaraz_messages,
	zaraz_api_response_common,
	zaraz_load_rule,
	zaraz_click_listener_rule,
	zaraz_timer_rule,
	zaraz_form_submission_rule,
	zaraz_variable_match_rule,
	zaraz_scroll_depth_rule,
	zaraz_element_visibility_rule,
	zaraz_zaraz_config_base,
	zaraz_base_tool,
	zaraz_base_mc,
	zaraz_managed_component,
	zaraz_custom_managed_component,
	zaraz_zaraz_config_return,
	zaraz_zaraz_config_response,
	zaraz_api_response_common_failure,
	zaraz_legacy_tool,
	zaraz_zaraz_config_body,
	zaraz_zaraz_config_row_base,
	zaraz_zaraz_history_response,
	zaraz_zaraz_config_history_response,
	zaraz_zaraz_workflow,
	zaraz_zaraz_workflow_response,
	observatory_messages,
	observatory_api_response_common,
	observatory_api_response_single,
	observatory_region,
	observatory_labeled_region,
	observatory_availabilities,
	observatory_availabilities_response,
	observatory_api_response_common_failure,
	observatory_api_response_collection,
	observatory_schedule_frequency,
	observatory_timestamp,
	observatory_device_type,
	observatory_lighthouse_error_code,
	observatory_lighthouse_state,
	observatory_lighthouse_report,
	observatory_uuid,
	observatory_url,
	observatory_page_test,
	observatory_pages_response_collection,
	observatory_count_response,
	observatory_result_info,
	observatory_page_test_response_collection,
	speed_create_test_Body,
	observatory_page_test_response_single,
	observatory_trend,
	observatory_trend_response,
	observatory_schedule,
	observatory_schedule_response_single,
	observatory_create_schedule_response,
	analyze_certificate_analyze_certificate_Body,
	tls_certificates_and_hostnames_certificate_analyze_response,
	tls_certificates_and_hostnames_certificate_pack_response_collection,
	tls_certificates_and_hostnames_schemas_certificate_authority,
	tls_certificates_and_hostnames_cloudflare_branding,
	tls_certificates_and_hostnames_schemas_hosts,
	tls_certificates_and_hostnames_advanced_type,
	tls_certificates_and_hostnames_validation_method,
	tls_certificates_and_hostnames_validity_days,
	certificate_packs_order_advanced_certificate_manager_certificate_pack_Body,
	tls_certificates_and_hostnames_certificate_packs_components_schemas_status,
	tls_certificates_and_hostnames_advanced_certificate_pack_response_single,
	tls_certificates_and_hostnames_quota,
	tls_certificates_and_hostnames_certificate_pack_quota_response,
	tls_certificates_and_hostnames_delete_advanced_certificate_pack_response_single,
	tls_certificates_and_hostnames_certificate_pack_response_single,
	tls_certificates_and_hostnames_schemas_enabled,
	tls_certificates_and_hostnames_universal,
	tls_certificates_and_hostnames_ssl_universal_settings_response,
	tls_certificates_and_hostnames_brand_check,
	tls_certificates_and_hostnames_cert_pack_uuid,
	tls_certificates_and_hostnames_certificate_status,
	tls_certificates_and_hostnames_schemas_signature,
	tls_certificates_and_hostnames_schemas_validation_method,
	tls_certificates_and_hostnames_verification_info,
	tls_certificates_and_hostnames_verification_status,
	tls_certificates_and_hostnames_verification_type,
	tls_certificates_and_hostnames_verification,
	tls_certificates_and_hostnames_ssl_verification_response_collection,
	tls_certificates_and_hostnames_validation_method_definition,
	tls_certificates_and_hostnames_components_schemas_validation_method,
	tls_certificates_and_hostnames_validation_method_components_schemas_status,
	tls_certificates_and_hostnames_ssl_validation_method_response_collection,
	rulesets_scope,
	rulesets_type,
	rulesets_schemas_response_model,
	rulesets_schemas_request_model,
	workers_pattern,
	workers_script_name,
	workers_routes,
	workers_route_response_collection,
	workers_route_no_id,
	workers_route_response_single,
	legacy_jhs_analytics_aggregate_components_schemas_response_collection,
	legacy_jhs_components_schemas_response_collection,
	legacy_jhs_argo_smart_routing,
	legacy_jhs_dns_name,
	legacy_jhs_dns_type,
	legacy_jhs_dns,
	legacy_jhs_edge_ips,
	legacy_jhs_ip_firewall,
	legacy_jhs_origin_dns_name,
	legacy_jhs_dns_ttl,
	legacy_jhs_origin_dns_type,
	legacy_jhs_origin_dns,
	legacy_jhs_origin_port,
	legacy_jhs_protocol,
	legacy_jhs_proxy_protocol,
	legacy_jhs_tls,
	legacy_jhs_traffic_type,
	spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_Body,
	legacy_jhs_created,
	legacy_jhs_app_id,
	legacy_jhs_modified,
	legacy_jhs_response_single_origin_dns,
	legacy_jhs_schemas_response_single,
};

const endpoints = makeApi([
	{
		method: "get",
		path: "/accounts",
		alias: "accounts-list-accounts",
		description: `List all accounts you have ownership or verified access to.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
		],
		response: iam_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Accounts response failure`,
				schema: iam_response_collection.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id",
		alias: "accounts-account-details",
		description: `Get information about a specific account that you are a member of.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_response_single,
		errors: [
			{
				status: NaN,
				description: `Account Details response failure`,
				schema: iam_response_single.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id",
		alias: "accounts-update-account",
		description: `Update an existing account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: iam_components_schemas_account
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_response_single,
		errors: [
			{
				status: NaN,
				description: `Update Account response failure`,
				schema: iam_response_single.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/address_maps",
		alias: "ip-address-management-address-maps-list-address-maps",
		description: `List all address maps owned by the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Address Maps response failure`,
				schema: addressing_components_schemas_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/addressing/address_maps",
		alias: "ip-address-management-address-maps-create-address-map",
		description: `Create a new address map under the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ description: addressing_schemas_description.nullable(), enabled: addressing_enabled.nullable() }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_full_response,
		errors: [
			{
				status: NaN,
				description: `Create Address Map response failure`,
				schema: addressing_full_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/addressing/address_maps/:address_map_id",
		alias: "ip-address-management-address-maps-delete-address-map",
		description: `Delete a particular address map owned by the account. An Address Map must be disabled before it can be deleted.`,
		requestFormat: "json",
		parameters: [
			{
				name: "address_map_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete Address Map response failure`,
				schema: addressing_api_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/address_maps/:address_map_id",
		alias: "ip-address-management-address-maps-address-map-details",
		description: `Show a particular address map owned by the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "address_map_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_full_response,
		errors: [
			{
				status: NaN,
				description: `Address Map Details response failure`,
				schema: addressing_full_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/addressing/address_maps/:address_map_id",
		alias: "ip-address-management-address-maps-update-address-map",
		description: `Modify properties of an address map owned by the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ default_sni: addressing_default_sni.nullable(), description: addressing_schemas_description.nullable(), enabled: addressing_enabled.nullable() }).partial().passthrough()
			},
			{
				name: "address_map_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Address Map response failure`,
				schema: addressing_components_schemas_single_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/addressing/address_maps/:address_map_id/accounts/:account_id",
		alias: "ip-address-management-address-maps-remove-an-account-membership-from-an-address-map",
		description: `Remove an account as a member of a particular address map.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "address_map_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Remove an account membership from an Address Map response failure`,
				schema: addressing_api_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/addressing/address_maps/:address_map_id/accounts/:account_id",
		alias: "ip-address-management-address-maps-add-an-account-membership-to-an-address-map",
		description: `Add an account as a member of a particular address map.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "address_map_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Add an account membership to an Address Map response failure`,
				schema: addressing_api_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/addressing/address_maps/:address_map_id/ips/:ip_address",
		alias: "ip-address-management-address-maps-remove-an-ip-from-an-address-map",
		description: `Remove an IP from a particular address map.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ip_address",
				type: "Path",
				schema: z.string()
			},
			{
				name: "address_map_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Remove an IP from an Address Map response failure`,
				schema: addressing_api_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/addressing/address_maps/:address_map_id/ips/:ip_address",
		alias: "ip-address-management-address-maps-add-an-ip-to-an-address-map",
		description: `Add an IP from a prefix owned by the account to a particular address map.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ip_address",
				type: "Path",
				schema: z.string()
			},
			{
				name: "address_map_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Add an IP to an Address Map response failure`,
				schema: addressing_api_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/addressing/address_maps/:address_map_id/zones/:zone_id",
		alias: "ip-address-management-address-maps-remove-a-zone-membership-from-an-address-map",
		description: `Remove a zone as a member of a particular address map.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "address_map_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Remove a zone membership from an Address Map response failure`,
				schema: addressing_api_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/addressing/address_maps/:address_map_id/zones/:zone_id",
		alias: "ip-address-management-address-maps-add-a-zone-membership-to-an-address-map",
		description: `Add a zone as a member of a particular address map.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "address_map_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Add a zone membership to an Address Map response failure`,
				schema: addressing_api_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/addressing/loa_documents",
		alias: "ip-address-management-prefixes-upload-loa-document",
		description: `Submit LOA document (pdf format) under the account.`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ loa_document: z.string() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_loa_upload_response,
		errors: [
			{
				status: NaN,
				description: `Upload LOA Document response failure`,
				schema: addressing_loa_upload_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/loa_documents/:loa_document_id/download",
		alias: "ip-address-management-prefixes-download-loa-document",
		description: `Download specified LOA document under the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "loa_document_id",
				type: "Path",
				schema: z.string().max(32).nullable()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.unknown(),
		errors: [
			{
				status: NaN,
				description: `Download LOA Document response failure`,
				schema: z.unknown().and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/prefixes",
		alias: "ip-address-management-prefixes-list-prefixes",
		description: `List all prefixes owned by the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Prefixes response failure`,
				schema: addressing_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/addressing/prefixes",
		alias: "ip-address-management-prefixes-add-prefix",
		description: `Add a new prefix under the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ asn: addressing_asn.int().nullable(), cidr: addressing_cidr, loa_document_id: addressing_loa_document_identifier.max(32).nullable() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_single_response,
		errors: [
			{
				status: NaN,
				description: `Add Prefix response failure`,
				schema: addressing_single_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id",
		alias: "ip-address-management-prefixes-delete-prefix",
		description: `Delete an unapproved prefix owned by the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete Prefix response failure`,
				schema: addressing_api_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id",
		alias: "ip-address-management-prefixes-prefix-details",
		description: `List a particular prefix owned by the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_single_response,
		errors: [
			{
				status: NaN,
				description: `Prefix Details response failure`,
				schema: addressing_single_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id",
		alias: "ip-address-management-prefixes-update-prefix-description",
		description: `Modify the description for a prefix owned by the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ description: addressing_description.max(1000) }).passthrough()
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Prefix Description response failure`,
				schema: addressing_single_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/bgp/prefixes",
		alias: "ip-address-management-prefixes-list-bgp-prefixes",
		description: `List all BGP Prefixes within the specified IP Prefix. BGP Prefixes are used to control which specific subnets are advertised to the Internet. It is possible to advertise subnets more specific than an IP Prefix by creating more specific BGP Prefixes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_response_collection_bgp,
		errors: [
			{
				status: NaN,
				description: `List BGP Prefixes response failure`,
				schema: addressing_response_collection_bgp.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/bgp/prefixes/:bgp_prefix_id",
		alias: "ip-address-management-prefixes-fetch-bgp-prefix",
		description: `Retrieve a single BGP Prefix according to its identifier`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "bgp_prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_single_response_bgp,
		errors: [
			{
				status: NaN,
				description: `Fetch BGP Prefix response failure`,
				schema: addressing_single_response_bgp.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/bgp/prefixes/:bgp_prefix_id",
		alias: "ip-address-management-prefixes-update-bgp-prefix",
		description: `Update the properties of a BGP Prefix, such as the on demand advertisement status (advertised or withdrawn).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: addressing_bgp_prefix_update_advertisement
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "bgp_prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_single_response_bgp,
		errors: [
			{
				status: NaN,
				description: `Update BGP Prefix response failure`,
				schema: addressing_single_response_bgp.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/bgp/status",
		alias: "ip-address-management-dynamic-advertisement-get-advertisement-status",
		description: `List the current advertisement state for a prefix.`,
		requestFormat: "json",
		parameters: [
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_advertised_response,
		errors: [
			{
				status: NaN,
				description: `Get Advertisement Status response failure`,
				schema: addressing_advertised_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/bgp/status",
		alias: "ip-address-management-dynamic-advertisement-update-prefix-dynamic-advertisement-status",
		description: `Advertise or withdraw BGP route for a prefix.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ advertised: addressing_schemas_advertised }).passthrough()
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_advertised_response,
		errors: [
			{
				status: NaN,
				description: `Update Prefix Dynamic Advertisement Status response failure`,
				schema: addressing_advertised_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/bindings",
		alias: "ip-address-management-service-bindings-list-service-bindings",
		description: `List the Cloudflare services this prefix is currently bound to. Traffic sent to an address within an IP prefix will be routed to the Cloudflare service of the most-specific Service Binding matching the address.
**Example:** binding &#x60;192.0.2.0/24&#x60; to Cloudflare Magic Transit and &#x60;192.0.2.1/32&#x60; to the Cloudflare CDN would route traffic for &#x60;192.0.2.1&#x60; to the CDN, and traffic for all other IPs in the prefix to Cloudflare Magic Transit.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_common.and(z.object({ result: z.array(addressing_service_binding) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Service Bindings response failure`,
				schema: addressing_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/bindings",
		alias: "ip-address-management-service-bindings-create-service-binding",
		description: `Creates a new Service Binding, routing traffic to IPs within the given CIDR to a service running on Cloudflare&#x27;s network.
**Note:** This API may only be used on prefixes currently configured with a Magic Transit service binding, and only allows creating service bindings for the Cloudflare CDN or Cloudflare Spectrum.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: addressing_create_binding_request
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_common.and(z.object({ result: addressing_service_binding }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create Service Binding response failure`,
				schema: addressing_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/bindings/:binding_id",
		alias: "ip-address-management-service-bindings-delete-service-binding",
		description: `Delete a Service Binding`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "binding_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_common,
		errors: [
			{
				status: NaN,
				description: `Delete Service Binding response failure`,
				schema: addressing_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/bindings/:binding_id",
		alias: "ip-address-management-service-bindings-get-service-binding",
		description: `Fetch a single Service Binding`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "binding_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_common.and(z.object({ result: addressing_service_binding }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Service Binding response failure`,
				schema: addressing_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/delegations",
		alias: "ip-address-management-prefix-delegation-list-prefix-delegations",
		description: `List all delegations for a given account IP prefix.`,
		requestFormat: "json",
		parameters: [
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Prefix Delegations response failure`,
				schema: addressing_schemas_response_collection.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/delegations",
		alias: "ip-address-management-prefix-delegation-create-prefix-delegation",
		description: `Create a new account delegation for a given IP prefix.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ cidr: addressing_cidr, delegated_account_id: addressing_delegated_account_identifier.max(32) }).passthrough()
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create Prefix Delegation response failure`,
				schema: addressing_schemas_single_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/addressing/prefixes/:prefix_id/delegations/:delegation_id",
		alias: "ip-address-management-prefix-delegation-delete-prefix-delegation",
		description: `Delete an account delegation for a given IP prefix.`,
		requestFormat: "json",
		parameters: [
			{
				name: "delegation_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "prefix_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Prefix Delegation response failure`,
				schema: addressing_id_response.and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/addressing/services",
		alias: "ip-address-management-service-bindings-list-services",
		description: `Bring-Your-Own IP (BYOIP) prefixes onboarded to Cloudflare must be bound to a service running on the Cloudflare network to enable a Cloudflare product on the IP addresses. This endpoint can be used as a reference of available services on the Cloudflare network, and their service IDs.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: addressing_api_response_common.and(z.object({ result: z.array(z.object({ id: addressing_service_identifier.max(32), name: addressing_service_name }).partial().passthrough()) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Services response failure`,
				schema: addressing_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/:model_name",
		alias: "workers-ai-post-run-model",
		description: `This endpoint provides users with the capability to run specific AI models on-demand.

By submitting the required input data, users can receive real-time predictions or results generated by the chosen AI
model. The endpoint supports various AI model types, ensuring flexibility and adaptability for diverse use cases.

Model specific inputs available in [Cloudflare Docs](https://developers.cloudflare.com/workers-ai/models/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({}).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "model_name",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.string()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/baai/bge-base-en-v1.5",
		alias: "workers-ai-post-run-cf-baai-bge-base-en-v1-5",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_baai_bge_base_en_v1_5_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.object({ data: z.array(z.array(z.number())), shape: z.array(z.number()) }).partial().passthrough(), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/baai/bge-large-en-v1.5",
		alias: "workers-ai-post-run-cf-baai-bge-large-en-v1-5",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_baai_bge_base_en_v1_5_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.object({ data: z.array(z.array(z.number())), shape: z.array(z.number()) }).partial().passthrough(), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/baai/bge-small-en-v1.5",
		alias: "workers-ai-post-run-cf-baai-bge-small-en-v1-5",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_baai_bge_base_en_v1_5_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.object({ data: z.array(z.array(z.number())), shape: z.array(z.number()) }).partial().passthrough(), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/bytedance/stable-diffusion-xl-lightning",
		alias: "workers-ai-post-run-cf-bytedance-stable-diffusion-xl-lightning",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_bytedance_stable_diffusion_xl_lightning_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.void(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/deepseek-ai/deepseek-math-7b-base",
		alias: "workers-ai-post-run-cf-deepseek-ai-deepseek-math-7b-base",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/deepseek-ai/deepseek-math-7b-instruct",
		alias: "workers-ai-post-run-cf-deepseek-ai-deepseek-math-7b-instruct",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/defog/sqlcoder-7b-2",
		alias: "workers-ai-post-run-cf-defog-sqlcoder-7b-2",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/facebook/bart-large-cnn",
		alias: "workers-ai-post-run-cf-facebook-bart-large-cnn",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_facebook_bart_large_cnn_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.object({ summary: z.string() }).partial().passthrough(), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/facebook/detr-resnet-50",
		alias: "workers-ai-post-run-cf-facebook-detr-resnet-50",
		requestFormat: "binary",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.instanceof(File)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.array(z.object({ box: z.object({ xmax: z.number(), xmin: z.number(), ymax: z.number(), ymin: z.number() }).partial().passthrough(), label: z.string(), score: z.number() }).partial().passthrough()), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/huggingface/distilbert-sst-2-int8",
		alias: "workers-ai-post-run-cf-huggingface-distilbert-sst-2-int8",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ text: z.string() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.array(z.object({ label: z.string(), score: z.number() }).partial().passthrough()), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/jpmorganchase/roberta-spam",
		alias: "workers-ai-post-run-cf-jpmorganchase-roberta-spam",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ text: z.string() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.array(z.object({ label: z.string(), score: z.number() }).partial().passthrough()), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/lykon/dreamshaper-8-lcm",
		alias: "workers-ai-post-run-cf-lykon-dreamshaper-8-lcm",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_bytedance_stable_diffusion_xl_lightning_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.void(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/meta/llama-2-7b-chat-fp16",
		alias: "workers-ai-post-run-cf-meta-llama-2-7b-chat-fp16",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/meta/llama-2-7b-chat-int8",
		alias: "workers-ai-post-run-cf-meta-llama-2-7b-chat-int8",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/meta/m2m100-1.2b",
		alias: "workers-ai-post-run-cf-meta-m2m100-1-2b",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_meta_m2m100_1_2b_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.object({ translated_text: z.string() }).partial().passthrough(), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/microsoft/phi-2",
		alias: "workers-ai-post-run-cf-microsoft-phi-2",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/microsoft/resnet-50",
		alias: "workers-ai-post-run-cf-microsoft-resnet-50",
		requestFormat: "binary",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.instanceof(File)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.array(z.object({ label: z.string(), score: z.number() }).partial().passthrough()), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/mistral/mistral-7b-instruct-v0.1",
		alias: "workers-ai-post-run-cf-mistral-mistral-7b-instruct-v0-1",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/openai/whisper",
		alias: "workers-ai-post-run-cf-openai-whisper",
		requestFormat: "binary",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.instanceof(File)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.object({ text: z.string(), word_count: z.number().optional(), words: z.array(z.object({ end: z.number(), start: z.number(), word: z.string() }).partial().passthrough()).optional() }).passthrough(), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/openchat/openchat-3.5-0106",
		alias: "workers-ai-post-run-cf-openchat-openchat-3-5-0106",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/qwen/qwen1.5-0.5b-chat",
		alias: "workers-ai-post-run-cf-qwen-qwen1-5-0-5b-chat",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/qwen/qwen1.5-1.8b-chat",
		alias: "workers-ai-post-run-cf-qwen-qwen1-5-1-8b-chat",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/qwen/qwen1.5-14b-chat-awq",
		alias: "workers-ai-post-run-cf-qwen-qwen1-5-14b-chat-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/qwen/qwen1.5-7b-chat-awq",
		alias: "workers-ai-post-run-cf-qwen-qwen1-5-7b-chat-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/runwayml/stable-diffusion-v1-5-img2img",
		alias: "workers-ai-post-run-cf-runwayml-stable-diffusion-v1-5-img2img",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_bytedance_stable_diffusion_xl_lightning_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.void(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/runwayml/stable-diffusion-v1-5-inpainting",
		alias: "workers-ai-post-run-cf-runwayml-stable-diffusion-v1-5-inpainting",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_bytedance_stable_diffusion_xl_lightning_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.void(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/stabilityai/stable-diffusion-xl-base-1.0",
		alias: "workers-ai-post-run-cf-stabilityai-stable-diffusion-xl-base-1-0",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_bytedance_stable_diffusion_xl_lightning_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.void(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/thebloke/discolm-german-7b-v1-awq",
		alias: "workers-ai-post-run-cf-thebloke-discolm-german-7b-v1-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/thebloke/yarn-mistral-7b-64k-awq",
		alias: "workers-ai-post-run-cf-thebloke-yarn-mistral-7b-64k-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/tiiuae/falcon-7b-instruct",
		alias: "workers-ai-post-run-cf-tiiuae-falcon-7b-instruct",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@cf/tinyllama/tinyllama-1.1b-chat-v1.0",
		alias: "workers-ai-post-run-cf-tinyllama-tinyllama-1-1b-chat-v1-0",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/baai/bge-base-en-v1.5",
		alias: "workers-ai-post-run-hf-baai-bge-base-en-v1-5",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_cf_baai_bge_base_en_v1_5_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.object({ data: z.array(z.array(z.number())), shape: z.array(z.number()) }).partial().passthrough(), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/sentence-transformers/all-minilm-l6-v2",
		alias: "workers-ai-post-run-hf-sentence-transformers-all-minilm-l6-v2",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_ai_post_run_hf_sentence_transformers_all_minilm_l6_v2_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.array(z.number()), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/codellama-7b-instruct-awq",
		alias: "workers-ai-post-run-hf-thebloke-codellama-7b-instruct-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/deepseek-coder-6.7b-base-awq",
		alias: "workers-ai-post-run-hf-thebloke-deepseek-coder-6-7b-base-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/deepseek-coder-6.7b-instruct-awq",
		alias: "workers-ai-post-run-hf-thebloke-deepseek-coder-6-7b-instruct-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/llama-2-13b-chat-awq",
		alias: "workers-ai-post-run-hf-thebloke-llama-2-13b-chat-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/llamaguard-7b-awq",
		alias: "workers-ai-post-run-hf-thebloke-llamaguard-7b-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/mistral-7b-instruct-v0.1-awq",
		alias: "workers-ai-post-run-hf-thebloke-mistral-7b-instruct-v0-1-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/neural-chat-7b-v3-1-awq",
		alias: "workers-ai-post-run-hf-thebloke-neural-chat-7b-v3-1-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/openchat_3.5-awq",
		alias: "workers-ai-post-run-hf-thebloke-openchat_3-5-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/openhermes-2.5-mistral-7b-awq",
		alias: "workers-ai-post-run-hf-thebloke-openhermes-2-5-mistral-7b-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/orca-2-13b-awq",
		alias: "workers-ai-post-run-hf-thebloke-orca-2-13b-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/starling-lm-7b-alpha-awq",
		alias: "workers-ai-post-run-hf-thebloke-starling-lm-7b-alpha-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/ai/run/@hf/thebloke/zephyr-7b-beta-awq",
		alias: "workers-ai-post-run-hf-thebloke-zephyr-7b-beta-awq",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.union([z.object({ max_tokens: z.number().int().optional().default(256), prompt: z.string().max(6144), raw: z.boolean().optional(), stream: z.boolean().optional() }).passthrough(), z.object({ max_tokens: z.number().int().optional().default(256), messages: z.array(z.object({ content: z.string().max(6144), role: z.string() }).passthrough()), stream: z.boolean().optional() }).passthrough()])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ result: z.union([z.object({ response: z.string() }).partial().passthrough(), z.instanceof(File)]), success: z.boolean().default("true") }).partial().passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad request`,
				schema: z.object({ errors: z.array(z.object({ code: z.string(), message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/alerting/v3/available_alerts",
		alias: "notification-alert-types-get-alert-types",
		description: `Gets a list of all alert types for which an account is eligible.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get Alert Types response failure`,
				schema: aaa_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/alerting/v3/destinations/eligible",
		alias: "notification-mechanism-eligibility-get-delivery-mechanism-eligibility",
		description: `Get a list of all delivery mechanism types for which an account is eligible.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get delivery mechanism eligibility response failure`,
				schema: aaa_schemas_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/alerting/v3/destinations/pagerduty",
		alias: "notification-destinations-with-pager-duty-delete-pager-duty-services",
		description: `Deletes all the PagerDuty Services connected to the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete PagerDuty Services response failure`,
				schema: aaa_api_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/alerting/v3/destinations/pagerduty",
		alias: "notification-destinations-with-pager-duty-list-pager-duty-services",
		description: `Get a list of all configured PagerDuty services.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List PagerDuty services response failure`,
				schema: aaa_components_schemas_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/alerting/v3/destinations/pagerduty/connect",
		alias: "notification-destinations-with-pager-duty-connect-pager-duty",
		description: `Creates a new token for integrating with PagerDuty.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_sensitive_id_response,
		errors: [
			{
				status: NaN,
				description: `Create a token for PagerDuty integration failure`,
				schema: aaa_id_response.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/alerting/v3/destinations/pagerduty/connect/:token_id",
		alias: "notification-destinations-with-pager-duty-connect-pager-duty-token",
		description: `Links PagerDuty with the account using the integration token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "token_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_id_response,
		errors: [
			{
				status: NaN,
				description: `Create a Notification policy response failure`,
				schema: aaa_id_response.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/alerting/v3/destinations/webhooks",
		alias: "notification-webhooks-list-webhooks",
		description: `Gets a list of all configured webhook destinations.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_webhooks_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List webhooks response failure`,
				schema: aaa_webhooks_components_schemas_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/alerting/v3/destinations/webhooks",
		alias: "notification-webhooks-create-a-webhook",
		description: `Creates a new webhook destination.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ name: aaa_components_schemas_name, secret: aaa_secret.optional(), url: aaa_url }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_id_response,
		errors: [
			{
				status: NaN,
				description: `Create a webhook response failure`,
				schema: aaa_id_response.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/alerting/v3/destinations/webhooks/:webhook_id",
		alias: "notification-webhooks-delete-a-webhook",
		description: `Delete a configured webhook destination.`,
		requestFormat: "json",
		parameters: [
			{
				name: "webhook_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete a webhook response failure`,
				schema: aaa_api_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/alerting/v3/destinations/webhooks/:webhook_id",
		alias: "notification-webhooks-get-a-webhook",
		description: `Get details for a single webhooks destination.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "webhook_id",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: aaa_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get a webhook response failure`,
				schema: aaa_schemas_single_response.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/alerting/v3/destinations/webhooks/:webhook_id",
		alias: "notification-webhooks-update-a-webhook",
		description: `Update a webhook destination.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ name: aaa_components_schemas_name, secret: aaa_secret.optional(), url: aaa_url }).passthrough()
			},
			{
				name: "webhook_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_id_response,
		errors: [
			{
				status: NaN,
				description: `Update a webhook response failure`,
				schema: aaa_id_response.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/alerting/v3/history",
		alias: "notification-history-list-history",
		description: `Gets a list of history records for notifications sent to an account. The records are displayed for last &#x60;x&#x60; number of days based on the zone plan (free &#x3D; 30, pro &#x3D; 30, biz &#x3D; 30, ent &#x3D; 90).`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(1000).optional().default(25)
			},
			{
				name: "before",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "since",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
		],
		response: aaa_history_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List History response failure`,
				schema: aaa_history_components_schemas_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/alerting/v3/policies",
		alias: "notification-policies-list-notification-policies",
		description: `Get a list of all Notification policies.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_policies_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Notification policies response failure`,
				schema: aaa_policies_components_schemas_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/alerting/v3/policies",
		alias: "notification-policies-create-a-notification-policy",
		description: `Creates a new Notification policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ alert_type: aaa_alert_type, description: aaa_schemas_description.optional(), enabled: aaa_enabled.default(true), filters: aaa_filters.optional(), mechanisms: aaa_mechanisms, name: aaa_schemas_name }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: aaa_id_response,
		errors: [
			{
				status: NaN,
				description: `Create a Notification policy response failure`,
				schema: aaa_id_response.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/alerting/v3/policies/:policy_id",
		alias: "notification-policies-delete-a-notification-policy",
		description: `Delete a Notification policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: aaa_api_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete a Notification policy response failure`,
				schema: aaa_api_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/alerting/v3/policies/:policy_id",
		alias: "notification-policies-get-a-notification-policy",
		description: `Get details for a single policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: aaa_single_response,
		errors: [
			{
				status: NaN,
				description: `Get a Notification policy response failure`,
				schema: aaa_single_response.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/alerting/v3/policies/:policy_id",
		alias: "notification-policies-update-a-notification-policy",
		description: `Update a Notification policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ alert_type: aaa_alert_type, description: aaa_schemas_description, enabled: aaa_enabled.default(true), filters: aaa_filters, mechanisms: aaa_mechanisms, name: aaa_schemas_name }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: aaa_id_response,
		errors: [
			{
				status: NaN,
				description: `Update a Notification policy response failure`,
				schema: aaa_id_response.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/audit_logs",
		alias: "audit-logs-get-account-audit-logs",
		description: `Gets a list of audit logs for an account. Can be filtered by who made the change, on which zone, and the timeframe of the change.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "id",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "export",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "action.type",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "actor.ip",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "actor.email",
				type: "Query",
				schema: z.string().email().optional()
			},
			{
				name: "since",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "before",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "zone.name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["desc", "asc"]).optional().default("desc")
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(1000).optional().default(100)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "hide_user_logs",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: aaa_audit_logs_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get account audit logs response failure`,
				schema: aaa_audit_logs_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/brand-protection/submit",
		alias: "phishing-url-scanner-submit-suspicious-url-for-scanning",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: phishing_url_scanner_submit_suspicious_url_for_scanning_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: intel_phishing_url_submit_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Submit suspicious URL for scanning response failure`,
				schema: intel_phishing_url_submit_components_schemas_single_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/brand-protection/url-info",
		alias: "phishing-url-information-get-results-for-a-url-scan",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "url_id_param",
				type: "Query",
				schema: url_id_param
			},
			{
				name: "url",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: intel_phishing_url_info_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get results for a URL scan response failure`,
				schema: intel_phishing_url_info_components_schemas_single_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/calls/apps",
		alias: "calls-apps-list",
		description: `Lists all apps in the Cloudflare account`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: calls_app_response_collection,
		errors: [
			{
				status: NaN,
				description: `List videos response failure`,
				schema: calls_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/calls/apps",
		alias: "calls-apps-create-a-new-app",
		description: `Creates a new Cloudflare calls app. An app is an unique enviroment where each Session can access all Tracks within the app.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: calls_app_editable_fields
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: calls_app_response_single_with_secret,
	},
	{
		method: "delete",
		path: "/accounts/:account_id/calls/apps/:app_id",
		alias: "calls-apps-delete-app",
		description: `Deletes an app from Cloudflare Calls`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: calls_app_response_single,
	},
	{
		method: "get",
		path: "/accounts/:account_id/calls/apps/:app_id",
		alias: "calls-apps-retrieve-app-details",
		description: `Fetches details for a single Calls app.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: calls_app_response_single,
		errors: [
			{
				status: NaN,
				description: `Retrieve video details response failure`,
				schema: calls_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/calls/apps/:app_id",
		alias: "calls-apps-update-app-details",
		description: `Edit details for a single app.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: calls_app_editable_fields
			},
			{
				name: "app_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: calls_app_response_single,
		errors: [
			{
				status: NaN,
				description: `Edit app details response failure`,
				schema: calls_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/cfd_tunnel",
		alias: "cloudflare-tunnel-list-cloudflare-tunnels",
		description: `Lists and filters Cloudflare Tunnels in an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "is_deleted",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "existed_at",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "uuid",
				type: "Query",
				schema: z.string().max(36).optional()
			},
			{
				name: "was_active_at",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "was_inactive_at",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "include_prefix",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "exclude_prefix",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
		],
		response: tunnel_tunnel_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Cloudflare Tunnels response failure`,
				schema: tunnel_tunnel_response_collection.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/cfd_tunnel",
		alias: "cloudflare-tunnel-create-a-cloudflare-tunnel",
		description: `Creates a new Cloudflare Tunnel in an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudflare_tunnel_create_a_cloudflare_tunnel_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a Cloudflare Tunnel response failure`,
				schema: tunnel_tunnel_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/cfd_tunnel/:tunnel_id",
		alias: "cloudflare-tunnel-delete-a-cloudflare-tunnel",
		description: `Deletes a Cloudflare Tunnel from an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({}).partial().passthrough()
			},
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete a Cloudflare Tunnel response failure`,
				schema: tunnel_tunnel_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/cfd_tunnel/:tunnel_id",
		alias: "cloudflare-tunnel-get-a-cloudflare-tunnel",
		description: `Fetches a single Cloudflare Tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a Cloudflare Tunnel response failure`,
				schema: tunnel_tunnel_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/cfd_tunnel/:tunnel_id",
		alias: "cloudflare-tunnel-update-a-cloudflare-tunnel",
		description: `Updates an existing Cloudflare Tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudflare_tunnel_update_a_cloudflare_tunnel_Body
			},
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a Cloudflare Tunnel response failure`,
				schema: tunnel_tunnel_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/cfd_tunnel/:tunnel_id/configurations",
		alias: "cloudflare-tunnel-configuration-get-configuration",
		description: `Gets the configuration for a remotely-managed tunnel`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_config_response_single,
		errors: [
			{
				status: NaN,
				description: `Get configuration response failure`,
				schema: tunnel_config_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/cfd_tunnel/:tunnel_id/configurations",
		alias: "cloudflare-tunnel-configuration-put-configuration",
		description: `Adds or updates the configuration for a remotely-managed tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudflare_tunnel_configuration_put_configuration_Body
			},
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_config_response_single,
		errors: [
			{
				status: NaN,
				description: `Put configuration response failure`,
				schema: tunnel_config_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/cfd_tunnel/:tunnel_id/connections",
		alias: "cloudflare-tunnel-clean-up-cloudflare-tunnel-connections",
		description: `Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({}).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "client_id",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: tunnel_empty_response,
		errors: [
			{
				status: NaN,
				description: `Clean up Cloudflare Tunnel connections response failure`,
				schema: tunnel_empty_response.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/cfd_tunnel/:tunnel_id/connections",
		alias: "cloudflare-tunnel-list-cloudflare-tunnel-connections",
		description: `Fetches connection details for a Cloudflare Tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: tunnel_tunnel_connections_response,
		errors: [
			{
				status: NaN,
				description: `List Cloudflare Tunnel connections response failure`,
				schema: tunnel_tunnel_connections_response.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/cfd_tunnel/:tunnel_id/connectors/:connector_id",
		alias: "cloudflare-tunnel-get-cloudflare-tunnel-connector",
		description: `Fetches connector and connection details for a Cloudflare Tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "connector_id",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: tunnel_tunnel_client_response,
		errors: [
			{
				status: NaN,
				description: `Get Cloudflare Tunnel connector response failure`,
				schema: tunnel_tunnel_client_response.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/cfd_tunnel/:tunnel_id/management",
		alias: "cloudflare-tunnel-get-a-cloudflare-tunnel-management-token",
		description: `Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudflare_tunnel_get_a_cloudflare_tunnel_management_token_Body
			},
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_token,
		errors: [
			{
				status: NaN,
				description: `Cloudflare API response failure`,
				schema: tunnel_tunnel_response_token.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/cfd_tunnel/:tunnel_id/token",
		alias: "cloudflare-tunnel-get-a-cloudflare-tunnel-token",
		description: `Gets the token used to associate cloudflared with a specific tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_token,
		errors: [
			{
				status: NaN,
				description: `Get a Cloudflare Tunnel token response failure`,
				schema: tunnel_tunnel_response_token.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/custom_ns",
		alias: "account-level-custom-nameservers-list-account-custom-nameservers",
		description: `List an account&#x27;s custom nameservers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_custom_nameservers_acns_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Account Custom Nameservers response failure`,
				schema: dns_custom_nameservers_acns_response_collection.and(dns_custom_nameservers_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/custom_ns",
		alias: "account-level-custom-nameservers-add-account-custom-nameserver",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ ns_name: dns_custom_nameservers_ns_name.url(), ns_set: dns_custom_nameservers_ns_set.gte(1).lte(5).optional().default(1) }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_custom_nameservers_acns_response_single,
		errors: [
			{
				status: NaN,
				description: `Add Account Custom Nameserver response failure`,
				schema: dns_custom_nameservers_acns_response_single.and(dns_custom_nameservers_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/custom_ns/:custom_ns_id",
		alias: "account-level-custom-nameservers-delete-account-custom-nameserver",
		requestFormat: "json",
		parameters: [
			{
				name: "custom_ns_id",
				type: "Path",
				schema: z.string().url()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_custom_nameservers_empty_response,
		errors: [
			{
				status: NaN,
				description: `Delete Account Custom Nameserver response failure`,
				schema: dns_custom_nameservers_empty_response.and(dns_custom_nameservers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/custom_ns/availability",
		alias: "account-level-custom-nameservers-get-eligible-zones-for-account-custom-nameservers",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_custom_nameservers_availability_response,
		errors: [
			{
				status: NaN,
				description: `Get Eligible Zones for Account Custom Nameservers response failure`,
				schema: dns_custom_nameservers_availability_response.and(dns_custom_nameservers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/d1/database",
		alias: "cloudflare-d1-list-databases",
		description: `Returns a list of D1 databases.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(10).lte(10000).optional().default(1000)
			},
		],
		response: d1_api_response_common.and(z.object({ result: z.array(d1_create_database_response), result_info: z.object({ count: z.number(), page: z.number(), per_page: z.number(), total_count: z.number() }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List D1 databases response failure`,
				schema: d1_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(d1_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/d1/database",
		alias: "cloudflare-d1-create-database",
		description: `Returns the created D1 database.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudflare_d1_create_database_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: d1_api_response_single.and(z.object({ result: d1_create_database_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Database details response failure`,
				schema: d1_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(d1_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices",
		alias: "devices-list-devices",
		description: `Fetches a list of enrolled devices.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_devices_response,
		errors: [
			{
				status: NaN,
				description: `List devices response failure`,
				schema: teams_devices_devices_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/:device_id",
		alias: "devices-device-details",
		description: `Fetches details for a single device.`,
		requestFormat: "json",
		parameters: [
			{
				name: "device_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_device_response,
		errors: [
			{
				status: NaN,
				description: `Get device details response failure`,
				schema: teams_devices_device_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/:device_id/override_codes",
		alias: "devices-list-admin-override-code-for-device",
		description: `Fetches a one-time use admin override code for a device. This relies on the **Admin Override** setting being enabled in your device configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "device_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_override_codes_response,
		errors: [
			{
				status: NaN,
				description: `Get an admin override code for a device response failure`,
				schema: teams_devices_override_codes_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/dex_tests",
		alias: "device-dex-test-details",
		description: `Fetch all DEX tests.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_dex_response_collection,
		errors: [
			{
				status: NaN,
				description: `Device DEX test response failure`,
				schema: teams_devices_dex_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/devices/dex_tests",
		alias: "device-dex-test-create-device-dex-test",
		description: `Create a DEX test.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: teams_devices_device_dex_test_schemas_http
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_dex_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Dex test response failure`,
				schema: teams_devices_dex_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/devices/dex_tests/:dex_test_id",
		alias: "device-dex-test-delete-device-dex-test",
		description: `Delete a Device DEX test. Returns the remaining device dex tests for the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "dex_test_id",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: teams_devices_dex_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete DEX test response failure`,
				schema: teams_devices_dex_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/dex_tests/:dex_test_id",
		alias: "device-dex-test-get-device-dex-test",
		description: `Fetch a single DEX test.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "dex_test_id",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: teams_devices_dex_single_response,
		errors: [
			{
				status: NaN,
				description: `Device DEX test response failure`,
				schema: teams_devices_dex_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/devices/dex_tests/:dex_test_id",
		alias: "device-dex-test-update-device-dex-test",
		description: `Update a DEX test.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: teams_devices_device_dex_test_schemas_http
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "dex_test_id",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: teams_devices_dex_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Dex test response failure`,
				schema: teams_devices_dex_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/networks",
		alias: "device-managed-networks-list-device-managed-networks",
		description: `Fetches a list of managed networks for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List your device managed networks response failure`,
				schema: teams_devices_components_schemas_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/devices/networks",
		alias: "device-managed-networks-create-device-managed-network",
		description: `Creates a new device managed network.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ config: teams_devices_schemas_config_request, name: teams_devices_device_managed_networks_components_schemas_name, type: teams_devices_components_schemas_type }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create a device managed networks response failure`,
				schema: teams_devices_components_schemas_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/devices/networks/:network_id",
		alias: "device-managed-networks-delete-device-managed-network",
		description: `Deletes a device managed network and fetches a list of the remaining device managed networks for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "network_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete a device managed network response failure`,
				schema: teams_devices_components_schemas_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/networks/:network_id",
		alias: "device-managed-networks-device-managed-network-details",
		description: `Fetches details for a single managed network.`,
		requestFormat: "json",
		parameters: [
			{
				name: "network_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get device managed network details response failure`,
				schema: teams_devices_components_schemas_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/devices/networks/:network_id",
		alias: "device-managed-networks-update-device-managed-network",
		description: `Updates a configured device managed network.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ config: teams_devices_schemas_config_request, name: teams_devices_device_managed_networks_components_schemas_name, type: teams_devices_components_schemas_type }).partial().passthrough()
			},
			{
				name: "network_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update a device managed network response failure`,
				schema: teams_devices_components_schemas_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/policies",
		alias: "devices-list-device-settings-policies",
		description: `Fetches a list of the device settings profiles for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_device_settings_response_collection,
		errors: [
			{
				status: NaN,
				description: `List device settings profiles response failure`,
				schema: teams_devices_device_settings_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/policy",
		alias: "devices-get-default-device-settings-policy",
		description: `Fetches the default device settings profile for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_default_device_settings_response,
		errors: [
			{
				status: NaN,
				description: `Get the default device settings profile response failure`,
				schema: teams_devices_default_device_settings_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/devices/policy",
		alias: "devices-update-default-device-settings-policy",
		description: `Updates the default device settings profile for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ allow_mode_switch: teams_devices_allow_mode_switch, allow_updates: teams_devices_allow_updates, allowed_to_leave: teams_devices_allowed_to_leave, auto_connect: teams_devices_auto_connect, captive_portal: teams_devices_captive_portal, disable_auto_fallback: teams_devices_disable_auto_fallback, exclude_office_ips: teams_devices_exclude_office_ips, service_mode_v2: teams_devices_service_mode_v2, support_url: teams_devices_support_url, switch_locked: teams_devices_switch_locked }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_default_device_settings_response,
		errors: [
			{
				status: NaN,
				description: `Update the default device settings profile response failure`,
				schema: teams_devices_default_device_settings_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/devices/policy",
		alias: "devices-create-device-settings-policy",
		description: `Creates a device settings profile to be applied to certain devices matching the criteria.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ allow_mode_switch: teams_devices_allow_mode_switch.optional(), allow_updates: teams_devices_allow_updates.optional(), allowed_to_leave: teams_devices_allowed_to_leave.optional(), auto_connect: teams_devices_auto_connect.optional(), captive_portal: teams_devices_captive_portal.optional(), description: teams_devices_schemas_description.max(500).optional(), disable_auto_fallback: teams_devices_disable_auto_fallback.optional(), enabled: z.boolean().optional(), exclude_office_ips: teams_devices_exclude_office_ips.optional(), lan_allow_minutes: teams_devices_lan_allow_minutes.optional(), lan_allow_subnet_size: teams_devices_lan_allow_subnet_size.optional(), match: teams_devices_schemas_match.max(500), name: z.string().max(100), precedence: teams_devices_precedence, service_mode_v2: teams_devices_service_mode_v2.optional(), support_url: teams_devices_support_url.optional(), switch_locked: teams_devices_switch_locked.optional() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_device_settings_response,
		errors: [
			{
				status: NaN,
				description: `Create a device settings profile response failure`,
				schema: teams_devices_device_settings_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/devices/policy/:policy_id",
		alias: "devices-delete-device-settings-policy",
		description: `Deletes a device settings profile and fetches a list of the remaining profiles for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_device_settings_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete a device settings profile response failure`,
				schema: teams_devices_device_settings_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/policy/:policy_id",
		alias: "devices-get-device-settings-policy-by-id",
		description: `Fetches a device settings profile by ID.`,
		requestFormat: "json",
		parameters: [
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_device_settings_response,
		errors: [
			{
				status: NaN,
				description: `Get device settings profile by ID response failure`,
				schema: teams_devices_device_settings_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/devices/policy/:policy_id",
		alias: "devices-update-device-settings-policy",
		description: `Updates a configured device settings profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ allow_mode_switch: teams_devices_allow_mode_switch, allow_updates: teams_devices_allow_updates, allowed_to_leave: teams_devices_allowed_to_leave, auto_connect: teams_devices_auto_connect, captive_portal: teams_devices_captive_portal, description: teams_devices_schemas_description.max(500), disable_auto_fallback: teams_devices_disable_auto_fallback, enabled: z.boolean(), exclude_office_ips: teams_devices_exclude_office_ips, match: teams_devices_schemas_match.max(500), name: z.string().max(100), precedence: teams_devices_precedence, service_mode_v2: teams_devices_service_mode_v2, support_url: teams_devices_support_url, switch_locked: teams_devices_switch_locked }).partial().passthrough()
			},
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_device_settings_response,
		errors: [
			{
				status: NaN,
				description: `Update a device settings profile Policy response failure`,
				schema: teams_devices_device_settings_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/policy/:policy_id/exclude",
		alias: "devices-get-split-tunnel-exclude-list-for-a-device-settings-policy",
		description: `Fetches the list of routes excluded from the WARP client&#x27;s tunnel for a specific device settings profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_split_tunnel_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get the Split Tunnel exclude list for a device settings profile response failure`,
				schema: teams_devices_split_tunnel_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/devices/policy/:policy_id/exclude",
		alias: "devices-set-split-tunnel-exclude-list-for-a-device-settings-policy",
		description: `Sets the list of routes excluded from the WARP client&#x27;s tunnel for a specific device settings profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(teams_devices_split_tunnel)
			},
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_split_tunnel_response_collection,
		errors: [
			{
				status: NaN,
				description: `Set the Split Tunnel exclude list for a device settings profile response failure`,
				schema: teams_devices_split_tunnel_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/policy/:policy_id/fallback_domains",
		alias: "devices-get-local-domain-fallback-list-for-a-device-settings-policy",
		description: `Fetches the list of domains to bypass Gateway DNS resolution from a specified device settings profile. These domains will use the specified local DNS resolver instead.`,
		requestFormat: "json",
		parameters: [
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_fallback_domain_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get the Local Domain Fallback list for a device settings profile response failure`,
				schema: teams_devices_fallback_domain_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/devices/policy/:policy_id/fallback_domains",
		alias: "devices-set-local-domain-fallback-list-for-a-device-settings-policy",
		description: `Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead. This will only apply to the specified device settings profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(teams_devices_fallback_domain)
			},
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_fallback_domain_response_collection,
		errors: [
			{
				status: NaN,
				description: `Set the Local Domain Fallback list for a device settings profile response failure`,
				schema: teams_devices_fallback_domain_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/policy/:policy_id/include",
		alias: "devices-get-split-tunnel-include-list-for-a-device-settings-policy",
		description: `Fetches the list of routes included in the WARP client&#x27;s tunnel for a specific device settings profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_split_tunnel_include_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get the Split Tunnel include list for a device settings profile response failure`,
				schema: teams_devices_split_tunnel_include_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/devices/policy/:policy_id/include",
		alias: "devices-set-split-tunnel-include-list-for-a-device-settings-policy",
		description: `Sets the list of routes included in the WARP client&#x27;s tunnel for a specific device settings profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(teams_devices_split_tunnel_include)
			},
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_split_tunnel_include_response_collection,
		errors: [
			{
				status: NaN,
				description: `Set the Split Tunnel include list for a device settings profile response failure`,
				schema: teams_devices_split_tunnel_include_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/policy/exclude",
		alias: "devices-get-split-tunnel-exclude-list",
		description: `Fetches the list of routes excluded from the WARP client&#x27;s tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_split_tunnel_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get the Split Tunnel exclude list response failure`,
				schema: teams_devices_split_tunnel_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/devices/policy/exclude",
		alias: "devices-set-split-tunnel-exclude-list",
		description: `Sets the list of routes excluded from the WARP client&#x27;s tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(teams_devices_split_tunnel)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_split_tunnel_response_collection,
		errors: [
			{
				status: NaN,
				description: `Set the Split Tunnel exclude list response failure`,
				schema: teams_devices_split_tunnel_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/policy/fallback_domains",
		alias: "devices-get-local-domain-fallback-list",
		description: `Fetches a list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_fallback_domain_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get your Local Domain Fallback list response failure`,
				schema: teams_devices_fallback_domain_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/devices/policy/fallback_domains",
		alias: "devices-set-local-domain-fallback-list",
		description: `Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(teams_devices_fallback_domain)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_fallback_domain_response_collection,
		errors: [
			{
				status: NaN,
				description: `Set your Local Domain Fallback list response failure`,
				schema: teams_devices_fallback_domain_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/policy/include",
		alias: "devices-get-split-tunnel-include-list",
		description: `Fetches the list of routes included in the WARP client&#x27;s tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_split_tunnel_include_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get the Split Tunnel include list response failure`,
				schema: teams_devices_split_tunnel_include_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/devices/policy/include",
		alias: "devices-set-split-tunnel-include-list",
		description: `Sets the list of routes included in the WARP client&#x27;s tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(teams_devices_split_tunnel_include)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_split_tunnel_include_response_collection,
		errors: [
			{
				status: NaN,
				description: `Set the Split Tunnel include list response failure`,
				schema: teams_devices_split_tunnel_include_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/posture",
		alias: "device-posture-rules-list-device-posture-rules",
		description: `Fetches device posture rules for a Zero Trust account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_response_collection,
		errors: [
			{
				status: NaN,
				description: `List device posture rules response failure`,
				schema: teams_devices_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/devices/posture",
		alias: "device-posture-rules-create-device-posture-rule",
		description: `Creates a new device posture rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ description: teams_devices_description.optional(), expiration: teams_devices_expiration.optional(), input: teams_devices_input.optional(), match: teams_devices_match.optional(), name: teams_devices_name, schedule: teams_devices_schedule.optional(), type: teams_devices_type }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_single_response,
		errors: [
			{
				status: NaN,
				description: `Create device posture rule response failure`,
				schema: teams_devices_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/devices/posture/:rule_id",
		alias: "device-posture-rules-delete-device-posture-rule",
		description: `Deletes a device posture rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete a device posture rule response failure`,
				schema: teams_devices_id_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/posture/:rule_id",
		alias: "device-posture-rules-device-posture-rules-details",
		description: `Fetches a single device posture rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_single_response,
		errors: [
			{
				status: NaN,
				description: `Get device posture rule details response failure`,
				schema: teams_devices_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/devices/posture/:rule_id",
		alias: "device-posture-rules-update-device-posture-rule",
		description: `Updates a device posture rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ description: teams_devices_description.optional(), expiration: teams_devices_expiration.optional(), input: teams_devices_input.optional(), match: teams_devices_match.optional(), name: teams_devices_name, schedule: teams_devices_schedule.optional(), type: teams_devices_type }).passthrough()
			},
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_single_response,
		errors: [
			{
				status: NaN,
				description: `Update a device posture rule response failure`,
				schema: teams_devices_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/posture/integration",
		alias: "device-posture-integrations-list-device-posture-integrations",
		description: `Fetches the list of device posture integrations for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List your device posture integrations response failure`,
				schema: teams_devices_schemas_response_collection.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/devices/posture/integration",
		alias: "device-posture-integrations-create-device-posture-integration",
		description: `Create a new device posture integration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ config: teams_devices_config_request, interval: teams_devices_interval, name: teams_devices_components_schemas_name, type: teams_devices_schemas_type }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create a device posture integration response failure`,
				schema: teams_devices_schemas_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/devices/posture/integration/:integration_id",
		alias: "device-posture-integrations-delete-device-posture-integration",
		description: `Delete a configured device posture integration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "integration_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete a device posture integration response failure`,
				schema: teams_devices_schemas_id_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/posture/integration/:integration_id",
		alias: "device-posture-integrations-device-posture-integration-details",
		description: `Fetches details for a single device posture integration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "integration_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get device posture integration details response failure`,
				schema: teams_devices_schemas_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/devices/posture/integration/:integration_id",
		alias: "device-posture-integrations-update-device-posture-integration",
		description: `Updates a configured device posture integration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ config: teams_devices_config_request, interval: teams_devices_interval, name: teams_devices_components_schemas_name, type: teams_devices_schemas_type }).partial().passthrough()
			},
			{
				name: "integration_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update a device posture integration response failure`,
				schema: teams_devices_schemas_single_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/devices/revoke",
		alias: "devices-revoke-devices",
		description: `Revokes a list of devices.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(teams_devices_schemas_uuid)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Revoke devices response failure`,
				schema: teams_devices_api_response_single.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/devices/settings",
		alias: "zero-trust-accounts-get-device-settings-for-zero-trust-account",
		description: `Describes the current device settings for a Zero Trust account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_zero_trust_account_device_settings_response,
		errors: [
			{
				status: NaN,
				description: `Get device settings for a Zero Trust account response failure`,
				schema: teams_devices_zero_trust_account_device_settings_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/devices/settings",
		alias: "zero-trust-accounts-update-device-settings-for-the-zero-trust-account",
		description: `Updates the current device settings for a Zero Trust account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: teams_devices_zero_trust_account_device_settings
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_zero_trust_account_device_settings_response,
		errors: [
			{
				status: NaN,
				description: `Update device settings for a Zero Trust account response failure`,
				schema: teams_devices_zero_trust_account_device_settings_response.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/devices/unrevoke",
		alias: "devices-unrevoke-devices",
		description: `Unrevokes a list of devices.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(teams_devices_schemas_uuid)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: teams_devices_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Unrevoke devices response failure`,
				schema: teams_devices_api_response_single.and(teams_devices_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/colos",
		alias: "dex-endpoints-list-colos",
		description: `List Cloudflare colos that account&#x27;s devices were connected to during a time period, sorted by usage starting from the most used colo. Colos without traffic are also returned and sorted alphabetically.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "timeStart",
				type: "Query",
				schema: z.string()
			},
			{
				name: "timeEnd",
				type: "Query",
				schema: z.string()
			},
			{
				name: "sortBy",
				type: "Query",
				schema: z.enum(["fleet-status-usage", "application-tests-usage"]).optional()
			},
		],
		response: digital_experience_monitoring_api_response_collection.and(z.object({ result: digital_experience_monitoring_colos_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List colos failure response`,
				schema: digital_experience_monitoring_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/fleet-status/devices",
		alias: "dex-fleet-status-devices",
		description: `List details for devices using WARP`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "time_end",
				type: "Query",
				schema: z.string()
			},
			{
				name: "time_start",
				type: "Query",
				schema: z.string()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(50)
			},
			{
				name: "sort_by",
				type: "Query",
				schema: z.enum(["colo", "device_id", "mode", "platform", "status", "timestamp", "version"]).optional().default("timestamp")
			},
			{
				name: "colo",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "device_id",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "mode",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "status",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "platform",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "version",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: digital_experience_monitoring_fleet_status_devices_response,
		errors: [
			{
				status: NaN,
				description: `List devices response failure`,
				schema: digital_experience_monitoring_api_response_single.and(digital_experience_monitoring_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/fleet-status/live",
		alias: "dex-fleet-status-live",
		description: `List details for live (up to 60 minutes) devices using WARP`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "since_minutes",
				type: "Query",
				schema: z.number().gte(1).lte(60).default(10)
			},
		],
		response: digital_experience_monitoring_fleet_status_live_response,
		errors: [
			{
				status: NaN,
				description: `List device details (live) response failure`,
				schema: digital_experience_monitoring_api_response_single.and(digital_experience_monitoring_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/fleet-status/over-time",
		alias: "dex-fleet-status-over-time",
		description: `List details for devices using WARP, up to 7 days`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "time_end",
				type: "Query",
				schema: z.string()
			},
			{
				name: "time_start",
				type: "Query",
				schema: z.string()
			},
			{
				name: "colo",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "device_id",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `DEX HTTP test details failure response`,
				schema: digital_experience_monitoring_api_response_single.and(digital_experience_monitoring_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/http-tests/:test_id",
		alias: "dex-endpoints-http-test-details",
		description: `Get test details and aggregate performance metrics for an http test for a given time period between 1 hour and 7 days.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "test_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "deviceId",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "timeStart",
				type: "Query",
				schema: z.string()
			},
			{
				name: "timeEnd",
				type: "Query",
				schema: z.string()
			},
			{
				name: "interval",
				type: "Query",
				schema: z.enum(["minute", "hour"])
			},
			{
				name: "colo",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: digital_experience_monitoring_api_response_single.and(z.object({ result: digital_experience_monitoring_http_details_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `DEX HTTP test details failure response`,
				schema: digital_experience_monitoring_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/http-tests/:test_id/percentiles",
		alias: "dex-endpoints-http-test-percentiles",
		description: `Get percentiles for an http test for a given time period between 1 hour and 7 days.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "test_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "deviceId",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "timeStart",
				type: "Query",
				schema: z.string()
			},
			{
				name: "timeEnd",
				type: "Query",
				schema: z.string()
			},
			{
				name: "colo",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: digital_experience_monitoring_api_response_single.and(z.object({ result: digital_experience_monitoring_http_details_percentiles_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `DEX HTTP test percentiles failure response`,
				schema: digital_experience_monitoring_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/tests",
		alias: "dex-endpoints-list-tests",
		description: `List DEX tests`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "colo",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "testName",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "deviceId",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(50).optional().default(10)
			},
		],
		response: digital_experience_monitoring_api_response_single.and(z.object({ result: digital_experience_monitoring_tests_response, result_info: digital_experience_monitoring_result_info }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List DEX tests failure response`,
				schema: digital_experience_monitoring_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/tests/unique-devices",
		alias: "dex-endpoints-tests-unique-devices",
		description: `Returns unique count of devices that have run synthetic application monitoring tests in the past 7 days.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "testName",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "deviceId",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
		],
		response: digital_experience_monitoring_api_response_single.and(z.object({ result: digital_experience_monitoring_unique_devices_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `DEX unique devices targeted failure response`,
				schema: digital_experience_monitoring_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/traceroute-test-results/:test_result_id/network-path",
		alias: "dex-endpoints-traceroute-test-result-network-path",
		description: `Get a breakdown of hops and performance metrics for a specific traceroute test run`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "test_result_id",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: digital_experience_monitoring_api_response_single.and(z.object({ result: digital_experience_monitoring_traceroute_test_result_network_path_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `DEX traceroute test result network path failure response`,
				schema: digital_experience_monitoring_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/traceroute-tests/:test_id",
		alias: "dex-endpoints-traceroute-test-details",
		description: `Get test details and aggregate performance metrics for an traceroute test for a given time period between 1 hour and 7 days.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "test_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "deviceId",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "timeStart",
				type: "Query",
				schema: z.string()
			},
			{
				name: "timeEnd",
				type: "Query",
				schema: z.string()
			},
			{
				name: "interval",
				type: "Query",
				schema: z.enum(["minute", "hour"])
			},
			{
				name: "colo",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: digital_experience_monitoring_api_response_single.and(z.object({ result: digital_experience_monitoring_traceroute_details_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `DEX traceroute test details response failure response`,
				schema: digital_experience_monitoring_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/traceroute-tests/:test_id/network-path",
		alias: "dex-endpoints-traceroute-test-network-path",
		description: `Get a breakdown of metrics by hop for individual traceroute test runs`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "test_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "deviceId",
				type: "Query",
				schema: z.string()
			},
			{
				name: "timeStart",
				type: "Query",
				schema: z.string()
			},
			{
				name: "timeEnd",
				type: "Query",
				schema: z.string()
			},
			{
				name: "interval",
				type: "Query",
				schema: z.enum(["minute", "hour"])
			},
		],
		response: digital_experience_monitoring_api_response_single.and(z.object({ result: digital_experience_monitoring_traceroute_test_network_path_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `DEX traceroute test network path failure response`,
				schema: digital_experience_monitoring_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dex/traceroute-tests/:test_id/percentiles",
		alias: "dex-endpoints-traceroute-test-percentiles",
		description: `Get percentiles for a traceroute test for a given time period between 1 hour and 7 days.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "test_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "deviceId",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "timeStart",
				type: "Query",
				schema: z.string()
			},
			{
				name: "timeEnd",
				type: "Query",
				schema: z.string()
			},
			{
				name: "colo",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: digital_experience_monitoring_api_response_single.and(z.object({ result: digital_experience_monitoring_traceroute_details_percentiles_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `DEX Traceroute test percentiles failure response`,
				schema: digital_experience_monitoring_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/diagnostics/traceroute",
		alias: "diagnostics-traceroute",
		description: `Run traceroutes from Cloudflare colos.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ colos: magic_transit_colos.optional(), options: magic_transit_options.optional(), targets: magic_transit_targets }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_transit_traceroute_response_collection,
		errors: [
			{
				status: NaN,
				description: `Traceroute response failure`,
				schema: magic_transit_traceroute_response_collection.and(magic_transit_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dlp/datasets",
		alias: "dlp-datasets-read-all",
		description: `Fetch all datasets with information about available versions.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: dlp_DatasetArrayResponse,
		errors: [
			{
				status: NaN,
				description: `Datasets read failed`,
				schema: dlp_V4ResponseError
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/dlp/datasets",
		alias: "dlp-datasets-create",
		description: `Create a new dataset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				description: `Dataset description`,
				type: "Body",
				schema: dlp_NewDataset
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: dlp_DatasetCreationResponse,
		errors: [
			{
				status: NaN,
				description: `Dataset creation failed`,
				schema: dlp_V4ResponseError
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/dlp/datasets/:dataset_id",
		alias: "dlp-datasets-delete",
		description: `Delete a dataset.

This deletes all versions of the dataset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "dataset_id",
				type: "Path",
				schema: z.string().uuid()
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Dataset delete failed`,
				schema: dlp_V4ResponseError
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dlp/datasets/:dataset_id",
		alias: "dlp-datasets-read",
		description: `Fetch a specific dataset with information about available versions.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "dataset_id",
				type: "Path",
				schema: z.string().uuid()
			},
		],
		response: dlp_DatasetResponse,
		errors: [
			{
				status: NaN,
				description: `Dataset read failed`,
				schema: dlp_V4ResponseError
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/dlp/datasets/:dataset_id",
		alias: "dlp-datasets-update",
		description: `Update details about a dataset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				description: `Dataset description`,
				type: "Body",
				schema: dlp_DatasetUpdate
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "dataset_id",
				type: "Path",
				schema: z.string().uuid()
			},
		],
		response: dlp_DatasetResponse,
		errors: [
			{
				status: NaN,
				description: `Dataset update failed`,
				schema: dlp_V4ResponseError
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/dlp/datasets/:dataset_id/upload",
		alias: "dlp-datasets-create-version",
		description: `Prepare to upload a new version of a dataset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "dataset_id",
				type: "Path",
				schema: z.string().uuid()
			},
		],
		response: dlp_DatasetNewVersionResponse,
		errors: [
			{
				status: NaN,
				description: `Dataset version creation failed`,
				schema: dlp_V4ResponseError
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/dlp/datasets/:dataset_id/upload/:version",
		alias: "dlp-datasets-upload-version",
		description: `Upload a new version of a dataset.`,
		requestFormat: "binary",
		parameters: [
			{
				name: "body",
				description: `Dataset. For custom wordlists this contains UTF-8 patterns separated by newline characters.`,
				type: "Body",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "dataset_id",
				type: "Path",
				schema: z.string().uuid()
			},
			{
				name: "version",
				type: "Path",
				schema: z.number().int()
			},
		],
		response: dlp_DatasetResponse,
		errors: [
			{
				status: NaN,
				description: `Dataset version upload failed`,
				schema: dlp_V4ResponseError
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/dlp/patterns/validate",
		alias: "dlp-pattern-validation-validate-pattern",
		description: `Validates whether this pattern is a valid regular expression. Rejects it if the regular expression is too complex or can match an unbounded-length string. Your regex will be rejected if it uses the Kleene Star -- be sure to bound the maximum number of characters that can be matched.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ regex: z.string() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_validate_response,
		errors: [
			{
				status: NaN,
				description: `Validate pattern response failure`,
				schema: dlp_validate_response.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dlp/payload_log",
		alias: "dlp-payload-log-settings-get-settings",
		description: `Gets the current DLP payload log settings for this account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_get_settings_response,
		errors: [
			{
				status: NaN,
				description: `Get settings response failure`,
				schema: dlp_get_settings_response.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/dlp/payload_log",
		alias: "dlp-payload-log-settings-update-settings",
		description: `Updates the DLP payload log settings for this account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ public_key: z.string().nullable() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_update_settings_response,
		errors: [
			{
				status: NaN,
				description: `Update settings response failure`,
				schema: dlp_update_settings_response.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dlp/profiles",
		alias: "dlp-profiles-list-all-profiles",
		description: `Lists all DLP profiles in an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_response_collection,
		errors: [
			{
				status: NaN,
				description: `List all profiles response failure`,
				schema: dlp_response_collection.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dlp/profiles/:profile_id",
		alias: "dlp-profiles-get-dlp-profile",
		description: `Fetches a DLP profile by ID. Supports both predefined and custom profiles`,
		requestFormat: "json",
		parameters: [
			{
				name: "profile_id",
				type: "Path",
				schema: profile_id
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_either_profile_response,
		errors: [
			{
				status: NaN,
				description: `Get DLP Profile response failure`,
				schema: dlp_either_profile_response.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/dlp/profiles/custom",
		alias: "dlp-profiles-create-custom-profiles",
		description: `Creates a set of DLP custom profiles.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ profiles: z.array(dlp_new_custom_profile) }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_create_custom_profile_response,
		errors: [
			{
				status: NaN,
				description: `Create custom profiles response failure`,
				schema: dlp_create_custom_profile_response.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/dlp/profiles/custom/:profile_id",
		alias: "dlp-profiles-delete-custom-profile",
		description: `Deletes a DLP custom profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "profile_id",
				type: "Path",
				schema: profile_id
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete custom profile response failure`,
				schema: dlp_api_response_single.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dlp/profiles/custom/:profile_id",
		alias: "dlp-profiles-get-custom-profile",
		description: `Fetches a custom DLP profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "profile_id",
				type: "Path",
				schema: profile_id
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_custom_profile_response,
		errors: [
			{
				status: NaN,
				description: `Get custom profile response failure`,
				schema: dlp_custom_profile_response.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/dlp/profiles/custom/:profile_id",
		alias: "dlp-profiles-update-custom-profile",
		description: `Updates a DLP custom profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dlp_update_custom_profile
			},
			{
				name: "profile_id",
				type: "Path",
				schema: profile_id
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_custom_profile,
		errors: [
			{
				status: NaN,
				description: `Update custom profile response failure`,
				schema: dlp_custom_profile.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dlp/profiles/predefined/:profile_id",
		alias: "dlp-profiles-get-predefined-profile",
		description: `Fetches a predefined DLP profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "profile_id",
				type: "Path",
				schema: profile_id
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_predefined_profile_response,
		errors: [
			{
				status: NaN,
				description: `Get predefined profile response failure`,
				schema: dlp_predefined_profile_response.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/dlp/profiles/predefined/:profile_id",
		alias: "dlp-profiles-update-predefined-profile",
		description: `Updates a DLP predefined profile. Only supports enabling/disabling entries.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dlp_update_predefined_profile
			},
			{
				name: "profile_id",
				type: "Path",
				schema: profile_id
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dlp_predefined_profile,
		errors: [
			{
				status: NaN,
				description: `Update predefined profile response failure`,
				schema: dlp_predefined_profile.and(dlp_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dns_firewall",
		alias: "dns-firewall-list-dns-firewall-clusters",
		description: `List configured DNS Firewall clusters for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(100).optional().default(20)
			},
		],
		response: dns_firewall_dns_firewall_response_collection,
		errors: [
			{
				status: NaN,
				description: `List DNS Firewall Clusters response failure`,
				schema: dns_firewall_dns_firewall_response_collection.and(dns_firewall_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/dns_firewall",
		alias: "dns-firewall-create-dns-firewall-cluster",
		description: `Create a configured DNS Firewall Cluster.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ attack_mitigation: dns_firewall_attack_mitigation.nullish(), deprecate_any_requests: dns_firewall_deprecate_any_requests.optional(), ecs_fallback: dns_firewall_ecs_fallback.optional(), maximum_cache_ttl: dns_firewall_maximum_cache_ttl.gte(30).lte(36000).optional().default(900), minimum_cache_ttl: dns_firewall_minimum_cache_ttl.gte(30).lte(36000).optional().default(60), name: dns_firewall_name.max(160), negative_cache_ttl: dns_firewall_negative_cache_ttl.gte(30).lte(36000).nullish(), origin_ips: z.unknown().optional(), ratelimit: dns_firewall_ratelimit.gte(100).lte(1000000000).nullish(), retries: dns_firewall_retries.gte(0).lte(2).optional().default(2), upstream_ips: dns_firewall_upstream_ips }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_firewall_dns_firewall_single_response,
		errors: [
			{
				status: NaN,
				description: `Create DNS Firewall Cluster response failure`,
				schema: dns_firewall_dns_firewall_single_response.and(dns_firewall_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/dns_firewall/:dns_firewall_id",
		alias: "dns-firewall-delete-dns-firewall-cluster",
		description: `Delete a configured DNS Firewall Cluster.`,
		requestFormat: "json",
		parameters: [
			{
				name: "dns_firewall_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_firewall_api_response_single.and(z.object({ result: z.object({ id: dns_firewall_identifier.max(32) }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete DNS Firewall Cluster response failure`,
				schema: dns_firewall_api_response_single.and(z.object({ result: z.object({ id: dns_firewall_identifier.max(32) }).partial().passthrough() }).partial().passthrough()).and(dns_firewall_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/dns_firewall/:dns_firewall_id",
		alias: "dns-firewall-dns-firewall-cluster-details",
		description: `Show a single configured DNS Firewall cluster for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "dns_firewall_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_firewall_dns_firewall_single_response,
		errors: [
			{
				status: NaN,
				description: `DNS Firewall Cluster Details response failure`,
				schema: dns_firewall_dns_firewall_single_response.and(dns_firewall_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/dns_firewall/:dns_firewall_id",
		alias: "dns-firewall-update-dns-firewall-cluster",
		description: `Modify a DNS Firewall Cluster configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dns_firewall_schemas_dns_firewall
			},
			{
				name: "dns_firewall_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_firewall_dns_firewall_single_response,
		errors: [
			{
				status: NaN,
				description: `Update DNS Firewall Cluster response failure`,
				schema: dns_firewall_dns_firewall_single_response.and(dns_firewall_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway",
		alias: "zero-trust-accounts-get-zero-trust-account-information",
		description: `Gets information about the current Zero Trust account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_gateway_account,
		errors: [
			{
				status: NaN,
				description: `Get Zero Trust account information response failure`,
				schema: zero_trust_gateway_gateway_account.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/gateway",
		alias: "zero-trust-accounts-create-zero-trust-account",
		description: `Creates a Zero Trust account with an existing Cloudflare account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_gateway_account,
		errors: [
			{
				status: NaN,
				description: `Create Zero Trust account response failure`,
				schema: zero_trust_gateway_gateway_account.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/app_types",
		alias: "zero-trust-gateway-application-and-application-type-mappings-list-application-and-application-type-mappings",
		description: `Fetches all application and application type mappings.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zero_trust_gateway_app_types_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List application and application type mappings response failure`,
				schema: zero_trust_gateway_app_types_components_schemas_response_collection.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/audit_ssh_settings",
		alias: "zero-trust-get-audit-ssh-settings",
		description: `Get all Zero Trust Audit SSH settings for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_audit_ssh_settings_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get Zero Trust Audit SSH Settings response failure`,
				schema: zero_trust_gateway_audit_ssh_settings_components_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/gateway/audit_ssh_settings",
		alias: "zero-trust-update-audit-ssh-settings",
		description: `Updates Zero Trust Audit SSH settings.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ public_key: zero_trust_gateway_public_key, seed_id: zero_trust_gateway_audit_ssh_settings_components_schemas_uuid.max(36).optional() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_audit_ssh_settings_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Zero Trust Audit SSH Setting response failure`,
				schema: zero_trust_gateway_audit_ssh_settings_components_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/categories",
		alias: "zero-trust-gateway-categories-list-categories",
		description: `Fetches a list of all categories.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zero_trust_gateway_categories_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List categories response failure`,
				schema: zero_trust_gateway_categories_components_schemas_response_collection.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/configuration",
		alias: "zero-trust-accounts-get-zero-trust-account-configuration",
		description: `Fetches the current Zero Trust account configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_gateway_account_config,
		errors: [
			{
				status: NaN,
				description: `Get Zero Trust account configuration response failure`,
				schema: zero_trust_gateway_gateway_account_config.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/gateway/configuration",
		alias: "zero-trust-accounts-patch-zero-trust-account-configuration",
		description: `Patches the current Zero Trust account configuration. This endpoint can update a single subcollection of settings such as &#x60;antivirus&#x60;, &#x60;tls_decrypt&#x60;, &#x60;activity_log&#x60;, &#x60;block_page&#x60;, &#x60;browser_isolation&#x60;, &#x60;fips&#x60;, &#x60;body_scanning&#x60;, or &#x60;custom_certificate&#x60;, without updating the entire configuration object. Returns an error if any collection of settings is not properly configured.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zero_trust_gateway_gateway_account_settings
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_gateway_account_config,
		errors: [
			{
				status: NaN,
				description: `Update Zero Trust account configuration response failure`,
				schema: zero_trust_gateway_gateway_account_config.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/gateway/configuration",
		alias: "zero-trust-accounts-update-zero-trust-account-configuration",
		description: `Updates the current Zero Trust account configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zero_trust_gateway_gateway_account_settings
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_gateway_account_config,
		errors: [
			{
				status: NaN,
				description: `Update Zero Trust account configuration response failure`,
				schema: zero_trust_gateway_gateway_account_config.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/lists",
		alias: "zero-trust-lists-list-zero-trust-lists",
		description: `Fetches all Zero Trust lists for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Zero Trust lists response failure`,
				schema: zero_trust_gateway_response_collection.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/gateway/lists",
		alias: "zero-trust-lists-create-zero-trust-list",
		description: `Creates a new Zero Trust list.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ description: zero_trust_gateway_description.optional(), items: zero_trust_gateway_items.optional(), name: zero_trust_gateway_name, type: zero_trust_gateway_type }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_single_response_with_list_items,
		errors: [
			{
				status: NaN,
				description: `Create Zero Trust list response failure`,
				schema: zero_trust_gateway_single_response_with_list_items.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/gateway/lists/:list_id",
		alias: "zero-trust-lists-delete-zero-trust-list",
		description: `Deletes a Zero Trust list.`,
		requestFormat: "json",
		parameters: [
			{
				name: "list_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_empty_response,
		errors: [
			{
				status: NaN,
				description: `Delete Zero Trust list response failure`,
				schema: zero_trust_gateway_empty_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/lists/:list_id",
		alias: "zero-trust-lists-zero-trust-list-details",
		description: `Fetches a single Zero Trust list.`,
		requestFormat: "json",
		parameters: [
			{
				name: "list_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_single_response,
		errors: [
			{
				status: NaN,
				description: `Get Zero Trust list details response failure`,
				schema: zero_trust_gateway_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/gateway/lists/:list_id",
		alias: "zero-trust-lists-patch-zero-trust-list",
		description: `Appends or removes an item from a configured Zero Trust list.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ append: zero_trust_gateway_items, remove: z.array(zero_trust_gateway_value) }).partial().passthrough()
			},
			{
				name: "list_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_single_response,
		errors: [
			{
				status: NaN,
				description: `Patch Zero Trust list response failure`,
				schema: zero_trust_gateway_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/gateway/lists/:list_id",
		alias: "zero-trust-lists-update-zero-trust-list",
		description: `Updates a configured Zero Trust list.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ description: zero_trust_gateway_description.optional(), name: zero_trust_gateway_name }).passthrough()
			},
			{
				name: "list_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Zero Trust list response failure`,
				schema: zero_trust_gateway_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/lists/:list_id/items",
		alias: "zero-trust-lists-zero-trust-list-items",
		description: `Fetches all items in a single Zero Trust list.`,
		requestFormat: "json",
		parameters: [
			{
				name: "list_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_list_item_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get Zero Trust list items response failure`,
				schema: zero_trust_gateway_list_item_response_collection.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/locations",
		alias: "zero-trust-gateway-locations-list-zero-trust-gateway-locations",
		description: `Fetches Zero Trust Gateway locations for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Zero Trust Gateway locations response failure`,
				schema: zero_trust_gateway_schemas_response_collection.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/gateway/locations",
		alias: "zero-trust-gateway-locations-create-zero-trust-gateway-location",
		description: `Creates a new Zero Trust Gateway location.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ client_default: zero_trust_gateway_client_default.optional(), ecs_support: zero_trust_gateway_ecs_support.optional(), name: zero_trust_gateway_schemas_name, networks: zero_trust_gateway_networks.optional() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create a Zero Trust Gateway location response failure`,
				schema: zero_trust_gateway_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/gateway/locations/:location_id",
		alias: "zero-trust-gateway-locations-delete-zero-trust-gateway-location",
		description: `Deletes a configured Zero Trust Gateway location.`,
		requestFormat: "json",
		parameters: [
			{
				name: "location_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_empty_response,
		errors: [
			{
				status: NaN,
				description: `Delete a Zero Trust Gateway location response failure`,
				schema: zero_trust_gateway_empty_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/locations/:location_id",
		alias: "zero-trust-gateway-locations-zero-trust-gateway-location-details",
		description: `Fetches a single Zero Trust Gateway location.`,
		requestFormat: "json",
		parameters: [
			{
				name: "location_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get Zero Trust Gateway location details response failure`,
				schema: zero_trust_gateway_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/gateway/locations/:location_id",
		alias: "zero-trust-gateway-locations-update-zero-trust-gateway-location",
		description: `Updates a configured Zero Trust Gateway location.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ client_default: zero_trust_gateway_client_default.optional(), ecs_support: zero_trust_gateway_ecs_support.optional(), name: zero_trust_gateway_schemas_name, networks: zero_trust_gateway_networks.optional() }).passthrough()
			},
			{
				name: "location_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update a Zero Trust Gateway location response failure`,
				schema: zero_trust_gateway_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/logging",
		alias: "zero-trust-accounts-get-logging-settings-for-the-zero-trust-account",
		description: `Fetches the current logging settings for Zero Trust account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_gateway_account_logging_settings_response,
		errors: [
			{
				status: NaN,
				description: `Get logging settings for the Zero Trust account response failure`,
				schema: zero_trust_gateway_gateway_account_logging_settings_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/gateway/logging",
		alias: "zero-trust-accounts-update-logging-settings-for-the-zero-trust-account",
		description: `Updates logging settings for the current Zero Trust account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zero_trust_gateway_gateway_account_logging_settings
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_gateway_account_logging_settings_response,
		errors: [
			{
				status: NaN,
				description: `Update logging settings for the Zero Trust account response failure`,
				schema: zero_trust_gateway_gateway_account_logging_settings_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/proxy_endpoints",
		alias: "zero-trust-gateway-proxy-endpoints-list-proxy-endpoints",
		description: `Fetches a single Zero Trust Gateway proxy endpoint.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_proxy_endpoints_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get a proxy endpoint response failure`,
				schema: zero_trust_gateway_proxy_endpoints_components_schemas_response_collection.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/gateway/proxy_endpoints",
		alias: "zero-trust-gateway-proxy-endpoints-create-proxy-endpoint",
		description: `Creates a new Zero Trust Gateway proxy endpoint.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ ips: zero_trust_gateway_ips, name: zero_trust_gateway_proxy_endpoints_components_schemas_name, subdomain: zero_trust_gateway_schemas_subdomain.optional() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_proxy_endpoints_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create a proxy endpoint response failure`,
				schema: zero_trust_gateway_proxy_endpoints_components_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/gateway/proxy_endpoints/:proxy_endpoint_id",
		alias: "zero-trust-gateway-proxy-endpoints-delete-proxy-endpoint",
		description: `Deletes a configured Zero Trust Gateway proxy endpoint.`,
		requestFormat: "json",
		parameters: [
			{
				name: "proxy_endpoint_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_empty_response,
		errors: [
			{
				status: NaN,
				description: `Delete a proxy endpoint response failure`,
				schema: zero_trust_gateway_empty_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/proxy_endpoints/:proxy_endpoint_id",
		alias: "zero-trust-gateway-proxy-endpoints-proxy-endpoint-details",
		description: `Fetches all Zero Trust Gateway proxy endpoints for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "proxy_endpoint_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_proxy_endpoints_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `List proxy endpoints response failure`,
				schema: zero_trust_gateway_proxy_endpoints_components_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/gateway/proxy_endpoints/:proxy_endpoint_id",
		alias: "zero-trust-gateway-proxy-endpoints-update-proxy-endpoint",
		description: `Updates a configured Zero Trust Gateway proxy endpoint.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ ips: zero_trust_gateway_ips, name: zero_trust_gateway_proxy_endpoints_components_schemas_name, subdomain: zero_trust_gateway_schemas_subdomain }).partial().passthrough()
			},
			{
				name: "proxy_endpoint_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_proxy_endpoints_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update a proxy endpoint response failure`,
				schema: zero_trust_gateway_proxy_endpoints_components_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/rules",
		alias: "zero-trust-gateway-rules-list-zero-trust-gateway-rules",
		description: `Fetches the Zero Trust Gateway rules for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Zero Trust Gateway rules response failure`,
				schema: zero_trust_gateway_components_schemas_response_collection.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/gateway/rules",
		alias: "zero-trust-gateway-rules-create-zero-trust-gateway-rule",
		description: `Creates a new Zero Trust Gateway rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ action: zero_trust_gateway_action, description: zero_trust_gateway_schemas_description.optional(), device_posture: zero_trust_gateway_device_posture.optional(), enabled: zero_trust_gateway_enabled.optional(), filters: zero_trust_gateway_filters.optional(), identity: zero_trust_gateway_identity.optional(), name: zero_trust_gateway_components_schemas_name, precedence: zero_trust_gateway_precedence.int().optional(), rule_settings: zero_trust_gateway_rule_settings.optional(), schedule: zero_trust_gateway_schedule.optional(), traffic: zero_trust_gateway_traffic.optional() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create a Zero Trust Gateway rule response failure`,
				schema: zero_trust_gateway_components_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/gateway/rules/:rule_id",
		alias: "zero-trust-gateway-rules-delete-zero-trust-gateway-rule",
		description: `Deletes a Zero Trust Gateway rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_empty_response,
		errors: [
			{
				status: NaN,
				description: `Delete a Zero Trust Gateway rule response failure`,
				schema: zero_trust_gateway_empty_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/gateway/rules/:rule_id",
		alias: "zero-trust-gateway-rules-zero-trust-gateway-rule-details",
		description: `Fetches a single Zero Trust Gateway rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get Zero Trust Gateway rule details response failure`,
				schema: zero_trust_gateway_components_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/gateway/rules/:rule_id",
		alias: "zero-trust-gateway-rules-update-zero-trust-gateway-rule",
		description: `Updates a configured Zero Trust Gateway rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ action: zero_trust_gateway_action, description: zero_trust_gateway_schemas_description.optional(), device_posture: zero_trust_gateway_device_posture.optional(), enabled: zero_trust_gateway_enabled.optional(), filters: zero_trust_gateway_filters.optional(), identity: zero_trust_gateway_identity.optional(), name: zero_trust_gateway_components_schemas_name, precedence: zero_trust_gateway_precedence.int().optional(), rule_settings: zero_trust_gateway_rule_settings.optional(), schedule: zero_trust_gateway_schedule.optional(), traffic: zero_trust_gateway_traffic.optional() }).passthrough()
			},
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: zero_trust_gateway_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update a Zero Trust Gateway rule response failure`,
				schema: zero_trust_gateway_components_schemas_single_response.and(zero_trust_gateway_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/hyperdrive/configs",
		alias: "list-hyperdrive",
		description: `Returns a list of Hyperdrives`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: hyperdrive_api_response_common.and(z.object({ result: z.array(hyperdrive_hyperdrive_with_identifier) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Hyperdrives Failure Response`,
				schema: hyperdrive_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(hyperdrive_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/hyperdrive/configs",
		alias: "create-hyperdrive",
		description: `Creates and returns a new Hyperdrive configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: hyperdrive_create_update_hyperdrive_config
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: hyperdrive_api_response_single.and(z.object({ result: hyperdrive_hyperdrive_with_identifier }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create Hyperdrive Failure Response`,
				schema: hyperdrive_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(hyperdrive_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/hyperdrive/configs/:hyperdrive_id",
		alias: "delete-hyperdrive",
		description: `Deletes the specified Hyperdrive.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "hyperdrive_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: hyperdrive_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Hyperdrive Failure`,
				schema: hyperdrive_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(hyperdrive_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/hyperdrive/configs/:hyperdrive_id",
		alias: "get-hyperdrive",
		description: `Returns the specified Hyperdrive configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "hyperdrive_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: hyperdrive_api_response_single.and(z.object({ result: hyperdrive_hyperdrive_with_identifier }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Hyperdrive Failure`,
				schema: hyperdrive_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(hyperdrive_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/hyperdrive/configs/:hyperdrive_id",
		alias: "patch-hyperdrive",
		description: `Patches and returns the specified Hyperdrive configuration. Updates to the origin and caching settings are applied with an all-or-nothing approach.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: hyperdrive_patch_hyperdrive_config
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "hyperdrive_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: hyperdrive_api_response_single.and(z.object({ result: hyperdrive_hyperdrive_with_identifier }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Patch Hyperdrive Failure Response`,
				schema: hyperdrive_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(hyperdrive_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/hyperdrive/configs/:hyperdrive_id",
		alias: "update-hyperdrive",
		description: `Updates and returns the specified Hyperdrive configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: hyperdrive_create_update_hyperdrive_config
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "hyperdrive_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: hyperdrive_api_response_single.and(z.object({ result: hyperdrive_hyperdrive_with_identifier }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update Hyperdrive Failure Response`,
				schema: hyperdrive_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(hyperdrive_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/images/v1",
		alias: "cloudflare-images-upload-an-image-via-url",
		description: `Upload an image with up to 10 Megabytes using a single HTTP POST (multipart/form-data) request.
An image can be uploaded by sending an image file or passing an accessible to an API url.
`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: images_image_basic_upload
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_response_single,
		errors: [
			{
				status: NaN,
				description: `Upload an image response failure`,
				schema: images_image_response_single.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/images/v1/:image_id",
		alias: "cloudflare-images-delete-image",
		description: `Delete an image on Cloudflare Images. On success, all copies of the image are deleted and purged from cache.`,
		requestFormat: "json",
		parameters: [
			{
				name: "image_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete image response failure`,
				schema: images_deleted_response.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/images/v1/:image_id",
		alias: "cloudflare-images-image-details",
		description: `Fetch details for a single image.`,
		requestFormat: "json",
		parameters: [
			{
				name: "image_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_response_single,
		errors: [
			{
				status: NaN,
				description: `Image details response failure`,
				schema: images_image_response_single.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/images/v1/:image_id",
		alias: "cloudflare-images-update-image",
		description: `Update image access control. On access control change, all copies of the image are purged from cache.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: images_image_patch_request
			},
			{
				name: "image_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_response_single,
		errors: [
			{
				status: NaN,
				description: `Update image response failure`,
				schema: images_image_response_single.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/images/v1/:image_id/blob",
		alias: "cloudflare-images-base-image",
		description: `Fetch base image. For most images this will be the originally uploaded file. For larger images it can be a near-lossless version of the original.`,
		requestFormat: "json",
		parameters: [
			{
				name: "image_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Base image response failure`,
				schema: images_image_response_blob.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/images/v1/keys",
		alias: "cloudflare-images-keys-list-signing-keys",
		description: `Lists your signing keys. These can be found on your Cloudflare Images dashboard.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_key_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Signing Keys response failure`,
				schema: images_image_key_response_collection.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/images/v1/keys/:signing_key_name",
		alias: "cloudflare-images-keys-delete-signing-key",
		description: `Delete signing key with specified name. Returns all keys available.
When last key is removed, a new default signing key will be generated.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "signing_key_name",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_key_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete Signing Key response failure`,
				schema: images_image_key_response_collection.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/images/v1/keys/:signing_key_name",
		alias: "cloudflare-images-keys-add-signing-key",
		description: `Create a new signing key with specified name. Returns all keys available.`,
		requestFormat: "json",
		parameters: [
			{
				name: "signing_key_name",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_key_response_collection,
		errors: [
			{
				status: NaN,
				description: `Add Signing Key response failure`,
				schema: images_image_key_response_collection.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/images/v1/stats",
		alias: "cloudflare-images-images-usage-statistics",
		description: `Fetch usage statistics details for Cloudflare Images.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_images_stats_response,
		errors: [
			{
				status: NaN,
				description: `Images usage statistics response failure`,
				schema: images_images_stats_response.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/images/v1/variants",
		alias: "cloudflare-images-variants-list-variants",
		description: `Lists existing variants.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_variant_list_response,
		errors: [
			{
				status: NaN,
				description: `List variants response failure`,
				schema: images_image_variant_list_response.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/images/v1/variants",
		alias: "cloudflare-images-variants-create-a-variant",
		description: `Specify variants that allow you to resize images for different use cases.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: images_image_variant_definition
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_variant_simple_response,
		errors: [
			{
				status: NaN,
				description: `Create a variant response failure`,
				schema: images_image_variant_simple_response.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/images/v1/variants/:variant_id",
		alias: "cloudflare-images-variants-delete-a-variant",
		description: `Deleting a variant purges the cache for all images associated with the variant.`,
		requestFormat: "json",
		parameters: [
			{
				name: "variant_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete a variant response failure`,
				schema: images_deleted_response.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/images/v1/variants/:variant_id",
		alias: "cloudflare-images-variants-variant-details",
		description: `Fetch details for a single variant.`,
		requestFormat: "json",
		parameters: [
			{
				name: "variant_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_variant_simple_response,
		errors: [
			{
				status: NaN,
				description: `Variant details response failure`,
				schema: images_image_variant_simple_response.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/images/v1/variants/:variant_id",
		alias: "cloudflare-images-variants-update-a-variant",
		description: `Updating a variant purges the cache for all images associated with the variant.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: images_image_variant_patch_request
			},
			{
				name: "variant_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_variant_simple_response,
		errors: [
			{
				status: NaN,
				description: `Update a variant response failure`,
				schema: images_image_variant_simple_response.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/images/v2",
		alias: "cloudflare-images-list-images-v2",
		description: `List up to 10000 images with one request. Use the optional parameters below to get a specific range of images.
Endpoint returns continuation_token if more images are present.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "continuation_token",
				type: "Query",
				schema: z.string().nullish()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(10).lte(10000).optional().default(1000)
			},
			{
				name: "sort_order",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional().default("desc")
			},
		],
		response: images_images_list_response_v2,
		errors: [
			{
				status: NaN,
				description: `List images response failure`,
				schema: images_images_list_response_v2.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/images/v2/direct_upload",
		alias: "cloudflare-images-create-authenticated-direct-upload-url-v-2",
		description: `Direct uploads allow users to upload images without API keys. A common use case are web apps, client-side applications, or mobile devices where users upload content directly to Cloudflare Images. This method creates a draft record for a future image. It returns an upload URL and an image identifier. To verify if the image itself has been uploaded, send an image details request (accounts/:account_identifier/images/v1/:identifier), and check that the &#x60;draft: true&#x60; property is not present.`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: images_image_direct_upload_request_v2
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: images_image_direct_upload_response_v2,
		errors: [
			{
				status: NaN,
				description: `Create authenticated direct upload URL V2 response failure`,
				schema: images_image_direct_upload_response_v2.and(images_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/asn/:asn",
		alias: "asn-intelligence-get-asn-overview",
		requestFormat: "json",
		parameters: [
			{
				name: "asn",
				type: "Path",
				schema: z.number().int()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: intel_asn_components_schemas_response,
		errors: [
			{
				status: NaN,
				description: `Get ASN Overview response failure`,
				schema: intel_asn_components_schemas_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/asn/:asn/subnets",
		alias: "asn-intelligence-get-asn-subnets",
		requestFormat: "json",
		parameters: [
			{
				name: "asn",
				type: "Path",
				schema: z.number().int()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ asn: intel_asn.int(), count: intel_count, ip_count_total: z.number().int(), page: intel_page, per_page: intel_per_page, subnets: z.array(z.string()) }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Get ASN Subnets response failure`,
				schema: z.object({ asn: intel_asn.int(), count: intel_count, ip_count_total: z.number().int(), page: intel_page, per_page: intel_per_page, subnets: z.array(z.string()) }).partial().passthrough().and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/intel/attack-surface-report/:issue_id/dismiss",
		alias: "archive-security-center-insight",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ dismiss: z.boolean().default(true) }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "issue_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: security_center_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Client Error`,
				schema: security_center_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/attack-surface-report/issue-types",
		alias: "get-security-center-issue-types",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: security_center_api_response_common.and(z.object({ result: z.array(z.string()) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Client Error`,
				schema: security_center_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/attack-surface-report/issues",
		alias: "get-security-center-issues",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dismissed",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "issue_class",
				type: "Query",
				schema: z.array(security_center_issueClass).optional()
			},
			{
				name: "issue_type",
				type: "Query",
				schema: z.array(security_center_issueType).optional()
			},
			{
				name: "product",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "severity",
				type: "Query",
				schema: z.array(z.enum(["low", "moderate", "critical"])).optional()
			},
			{
				name: "subject",
				type: "Query",
				schema: z.array(security_center_subject).optional()
			},
			{
				name: "issue_class~neq",
				type: "Query",
				schema: z.array(security_center_issueClass).optional()
			},
			{
				name: "issue_type~neq",
				type: "Query",
				schema: z.array(security_center_issueType).optional()
			},
			{
				name: "product~neq",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "severity~neq",
				type: "Query",
				schema: z.array(z.enum(["low", "moderate", "critical"])).optional()
			},
			{
				name: "subject~neq",
				type: "Query",
				schema: z.array(security_center_subject).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: page
			},
			{
				name: "per_page",
				type: "Query",
				schema: per_page
			},
		],
		response: security_center_api_response_common.and(z.object({ result: z.object({ count: security_center_count.int(), issues: z.array(security_center_issue), page: security_center_page.int(), per_page: security_center_perPage.int().gte(1).lte(1000) }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Client Error`,
				schema: security_center_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/attack-surface-report/issues/class",
		alias: "get-security-center-issue-counts-by-class",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dismissed",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "issue_class",
				type: "Query",
				schema: z.array(security_center_issueClass).optional()
			},
			{
				name: "issue_type",
				type: "Query",
				schema: z.array(security_center_issueType).optional()
			},
			{
				name: "product",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "severity",
				type: "Query",
				schema: z.array(z.enum(["low", "moderate", "critical"])).optional()
			},
			{
				name: "subject",
				type: "Query",
				schema: z.array(security_center_subject).optional()
			},
			{
				name: "issue_class~neq",
				type: "Query",
				schema: z.array(security_center_issueClass).optional()
			},
			{
				name: "issue_type~neq",
				type: "Query",
				schema: z.array(security_center_issueType).optional()
			},
			{
				name: "product~neq",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "severity~neq",
				type: "Query",
				schema: z.array(z.enum(["low", "moderate", "critical"])).optional()
			},
			{
				name: "subject~neq",
				type: "Query",
				schema: z.array(security_center_subject).optional()
			},
		],
		response: security_center_valueCountsResponse,
		errors: [
			{
				status: NaN,
				description: `Client Error`,
				schema: security_center_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/attack-surface-report/issues/severity",
		alias: "get-security-center-issue-counts-by-severity",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dismissed",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "issue_class",
				type: "Query",
				schema: z.array(security_center_issueClass).optional()
			},
			{
				name: "issue_type",
				type: "Query",
				schema: z.array(security_center_issueType).optional()
			},
			{
				name: "product",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "severity",
				type: "Query",
				schema: z.array(z.enum(["low", "moderate", "critical"])).optional()
			},
			{
				name: "subject",
				type: "Query",
				schema: z.array(security_center_subject).optional()
			},
			{
				name: "issue_class~neq",
				type: "Query",
				schema: z.array(security_center_issueClass).optional()
			},
			{
				name: "issue_type~neq",
				type: "Query",
				schema: z.array(security_center_issueType).optional()
			},
			{
				name: "product~neq",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "severity~neq",
				type: "Query",
				schema: z.array(z.enum(["low", "moderate", "critical"])).optional()
			},
			{
				name: "subject~neq",
				type: "Query",
				schema: z.array(security_center_subject).optional()
			},
		],
		response: security_center_valueCountsResponse,
		errors: [
			{
				status: NaN,
				description: `Client Error`,
				schema: security_center_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/attack-surface-report/issues/type",
		alias: "get-security-center-issue-counts-by-type",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dismissed",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "issue_class",
				type: "Query",
				schema: z.array(security_center_issueClass).optional()
			},
			{
				name: "issue_type",
				type: "Query",
				schema: z.array(security_center_issueType).optional()
			},
			{
				name: "product",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "severity",
				type: "Query",
				schema: z.array(z.enum(["low", "moderate", "critical"])).optional()
			},
			{
				name: "subject",
				type: "Query",
				schema: z.array(security_center_subject).optional()
			},
			{
				name: "issue_class~neq",
				type: "Query",
				schema: z.array(security_center_issueClass).optional()
			},
			{
				name: "issue_type~neq",
				type: "Query",
				schema: z.array(security_center_issueType).optional()
			},
			{
				name: "product~neq",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "severity~neq",
				type: "Query",
				schema: z.array(z.enum(["low", "moderate", "critical"])).optional()
			},
			{
				name: "subject~neq",
				type: "Query",
				schema: z.array(security_center_subject).optional()
			},
		],
		response: security_center_valueCountsResponse,
		errors: [
			{
				status: NaN,
				description: `Client Error`,
				schema: security_center_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/dns",
		alias: "passive-dns-by-ip-get-passive-dns-by-ip",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "start_end_params",
				type: "Query",
				schema: start_end_params
			},
			{
				name: "ipv4",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().optional()
			},
		],
		response: intel_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get Passive DNS by IP response failure`,
				schema: intel_components_schemas_single_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/domain",
		alias: "domain-intelligence-get-domain-details",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "domain",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: intel_single_response,
		errors: [
			{
				status: NaN,
				description: `Get Domain Details response failure`,
				schema: intel_single_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/domain-history",
		alias: "domain-history-get-domain-history",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "domain",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: intel_response,
		errors: [
			{
				status: NaN,
				description: `Get Domain History response failure`,
				schema: intel_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/domain/bulk",
		alias: "domain-intelligence-get-multiple-domain-details",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "domain",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: intel_collection_response,
		errors: [
			{
				status: NaN,
				description: `Get Multiple Domain Details response failure`,
				schema: intel_collection_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/indicator-feeds",
		alias: "custom-indicator-feeds-get-indicator-feeds",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: intel_indicator_feed_response,
		errors: [
			{
				status: NaN,
				description: `Get indicator feeds response failure`,
				schema: intel_indicator_feed_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/intel/indicator-feeds",
		alias: "custom-indicator-feeds-create-indicator-feeds",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ description: intel_description, name: intel_name }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: intel_create_feed_response,
		errors: [
			{
				status: NaN,
				description: `Get indicator feeds failure response`,
				schema: intel_create_feed_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/indicator-feeds/:feed_id",
		alias: "custom-indicator-feeds-get-indicator-feed-metadata",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "feed_id",
				type: "Path",
				schema: z.number().int()
			},
		],
		response: intel_indicator_feed_metadata_response,
		errors: [
			{
				status: NaN,
				description: `Get indicator feeds response failure`,
				schema: intel_indicator_feed_metadata_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/indicator-feeds/:feed_id/data",
		alias: "custom-indicator-feeds-get-indicator-feed-data",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "feed_id",
				type: "Path",
				schema: z.number().int()
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Get indicator feeds response failure`,
				schema: intel_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/intel/indicator-feeds/:feed_id/snapshot",
		alias: "custom-indicator-feeds-update-indicator-feed-data",
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ source: z.string() }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "feed_id",
				type: "Path",
				schema: z.number().int()
			},
		],
		response: intel_update_feed_response,
		errors: [
			{
				status: NaN,
				description: `Get indicator feeds response failure`,
				schema: intel_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/intel/indicator-feeds/permissions/add",
		alias: "custom-indicator-feeds-add-permission",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ account_tag: z.string(), feed_id: z.number().int() }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: intel_permissions_response,
		errors: [
			{
				status: NaN,
				description: `Get indicator feeds response failure`,
				schema: intel_permissions_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/intel/indicator-feeds/permissions/remove",
		alias: "custom-indicator-feeds-remove-permission",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ account_tag: z.string(), feed_id: z.number().int() }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: intel_permissions_response,
		errors: [
			{
				status: NaN,
				description: `Get indicator feeds response failure`,
				schema: intel_permissions_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/indicator-feeds/permissions/view",
		alias: "custom-indicator-feeds-view-permissions",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: intel_permission_list_item_response,
		errors: [
			{
				status: NaN,
				description: `Get indicator feeds response failure`,
				schema: intel_permission_list_item_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/ip",
		alias: "ip-intelligence-get-ip-overview",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "ipv4",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "ipv6",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: intel_schemas_response,
		errors: [
			{
				status: NaN,
				description: `Get IP Overview response failure`,
				schema: intel_schemas_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/ip-list",
		alias: "ip-list-get-ip-lists",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: intel_components_schemas_response,
		errors: [
			{
				status: NaN,
				description: `Get IP Lists response failure`,
				schema: intel_components_schemas_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/intel/miscategorization",
		alias: "miscategorization-create-miscategorization",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ content_adds: z.unknown(), content_removes: z.unknown(), indicator_type: z.unknown(), ip: z.unknown(), security_adds: z.unknown(), security_removes: z.unknown(), url: z.string() }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: intel_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Miscategorization response failure`,
				schema: intel_api_response_single.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/sinkholes",
		alias: "sinkhole-config-get-sinkholes",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: intel_sinkholes_get_sinkholes_response,
	},
	{
		method: "get",
		path: "/accounts/:account_id/intel/whois",
		alias: "whois-record-get-whois-record",
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "domain",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: intel_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get WHOIS Record response failure`,
				schema: intel_schemas_single_response.and(intel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/monitors",
		alias: "account-load-balancer-monitors-list-monitors",
		description: `List configured monitors for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_monitor_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Monitors response failure`,
				schema: load_balancing_monitor_response_collection.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/load_balancers/monitors",
		alias: "account-load-balancer-monitors-create-monitor",
		description: `Create a configured monitor.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_load_balancer_monitors_create_monitor_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_monitor_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Monitor response failure`,
				schema: load_balancing_monitor_response_single.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/load_balancers/monitors/:monitor_id",
		alias: "account-load-balancer-monitors-delete-monitor",
		description: `Delete a configured monitor.`,
		requestFormat: "json",
		parameters: [
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Monitor response failure`,
				schema: load_balancing_id_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/monitors/:monitor_id",
		alias: "account-load-balancer-monitors-monitor-details",
		description: `List a single configured monitor for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_monitor_response_single,
		errors: [
			{
				status: NaN,
				description: `Monitor Details response failure`,
				schema: load_balancing_monitor_response_single.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/load_balancers/monitors/:monitor_id",
		alias: "account-load-balancer-monitors-patch-monitor",
		description: `Apply changes to an existing monitor, overwriting the supplied properties.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_load_balancer_monitors_create_monitor_Body
			},
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_monitor_response_single,
		errors: [
			{
				status: NaN,
				description: `Patch Monitor response failure`,
				schema: load_balancing_monitor_response_single.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/load_balancers/monitors/:monitor_id",
		alias: "account-load-balancer-monitors-update-monitor",
		description: `Modify a configured monitor.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_load_balancer_monitors_create_monitor_Body
			},
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_monitor_response_single,
		errors: [
			{
				status: NaN,
				description: `Update Monitor response failure`,
				schema: load_balancing_monitor_response_single.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/load_balancers/monitors/:monitor_id/preview",
		alias: "account-load-balancer-monitors-preview-monitor",
		description: `Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_load_balancer_monitors_create_monitor_Body
			},
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_preview_response,
		errors: [
			{
				status: NaN,
				description: `Preview Monitor response failure`,
				schema: load_balancing_preview_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/monitors/:monitor_id/references",
		alias: "account-load-balancer-monitors-list-monitor-references",
		description: `Get the list of resources that reference the provided monitor.`,
		requestFormat: "json",
		parameters: [
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_references_response,
		errors: [
			{
				status: NaN,
				description: `List Monitor References response failure`,
				schema: load_balancing_references_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/pools",
		alias: "account-load-balancer-pools-list-pools",
		description: `List configured pools.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "monitor",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: load_balancing_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Pools response failure`,
				schema: load_balancing_schemas_response_collection.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/load_balancers/pools",
		alias: "account-load-balancer-pools-patch-pools",
		description: `Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending &#x60;name&#x60;. Returns the list of affected pools. Supports the standard pagination query parameters, either &#x60;limit&#x60;/&#x60;offset&#x60; or &#x60;per_page&#x60;/&#x60;page&#x60;.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ notification_email: load_balancing_patch_pools_notification_email }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `Patch Pools response failure`,
				schema: load_balancing_schemas_response_collection.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/load_balancers/pools",
		alias: "account-load-balancer-pools-create-pool",
		description: `Create a new pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ description: load_balancing_schemas_description.optional(), enabled: load_balancing_enabled.optional().default(true), latitude: load_balancing_latitude.optional(), load_shedding: load_balancing_load_shedding.optional(), longitude: load_balancing_longitude.optional(), minimum_origins: load_balancing_minimum_origins.int().optional().default(1), monitor: load_balancing_monitor_id.optional(), name: load_balancing_name, notification_email: load_balancing_notification_email.optional(), notification_filter: load_balancing_notification_filter.nullish(), origin_steering: load_balancing_origin_steering.optional(), origins: load_balancing_origins }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create Pool response failure`,
				schema: load_balancing_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/load_balancers/pools/:pool_id",
		alias: "account-load-balancer-pools-delete-pool",
		description: `Delete a configured pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Pool response failure`,
				schema: load_balancing_schemas_id_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/pools/:pool_id",
		alias: "account-load-balancer-pools-pool-details",
		description: `Fetch a single configured pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Pool Details response failure`,
				schema: load_balancing_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/load_balancers/pools/:pool_id",
		alias: "account-load-balancer-pools-patch-pool",
		description: `Apply changes to an existing pool, overwriting the supplied properties.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ check_regions: load_balancing_check_regions.nullable(), description: load_balancing_schemas_description, disabled_at: load_balancing_schemas_disabled_at.datetime({ offset: true }), enabled: load_balancing_enabled.default(true), latitude: load_balancing_latitude, load_shedding: load_balancing_load_shedding, longitude: load_balancing_longitude, minimum_origins: load_balancing_minimum_origins.int().default(1), monitor: load_balancing_monitor_id, name: load_balancing_name, notification_email: load_balancing_notification_email, notification_filter: load_balancing_notification_filter.nullable(), origin_steering: load_balancing_origin_steering, origins: load_balancing_origins }).partial().passthrough()
			},
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Patch Pool response failure`,
				schema: load_balancing_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/load_balancers/pools/:pool_id",
		alias: "account-load-balancer-pools-update-pool",
		description: `Modify a configured pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ check_regions: load_balancing_check_regions.nullish(), description: load_balancing_schemas_description.optional(), disabled_at: load_balancing_schemas_disabled_at.datetime({ offset: true }).optional(), enabled: load_balancing_enabled.optional().default(true), latitude: load_balancing_latitude.optional(), load_shedding: load_balancing_load_shedding.optional(), longitude: load_balancing_longitude.optional(), minimum_origins: load_balancing_minimum_origins.int().optional().default(1), monitor: load_balancing_monitor_id.optional(), name: load_balancing_name, notification_email: load_balancing_notification_email.optional(), notification_filter: load_balancing_notification_filter.nullish(), origin_steering: load_balancing_origin_steering.optional(), origins: load_balancing_origins }).passthrough()
			},
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Pool response failure`,
				schema: load_balancing_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/pools/:pool_id/health",
		alias: "account-load-balancer-pools-pool-health-details",
		description: `Fetch the latest pool health status for a single pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_health_details,
		errors: [
			{
				status: NaN,
				description: `Pool Health Details response failure`,
				schema: load_balancing_health_details.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/load_balancers/pools/:pool_id/preview",
		alias: "account-load-balancer-pools-preview-pool",
		description: `Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_load_balancer_monitors_create_monitor_Body
			},
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_preview_response,
		errors: [
			{
				status: NaN,
				description: `Preview Pool response failure`,
				schema: load_balancing_preview_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/pools/:pool_id/references",
		alias: "account-load-balancer-pools-list-pool-references",
		description: `Get the list of resources that reference the provided pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_schemas_references_response,
		errors: [
			{
				status: NaN,
				description: `List Pool References response failure`,
				schema: load_balancing_schemas_references_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/preview/:preview_id",
		alias: "account-load-balancer-monitors-preview-result",
		description: `Get the result of a previous preview operation using the provided preview_id.`,
		requestFormat: "json",
		parameters: [
			{
				name: "preview_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_preview_result_response,
		errors: [
			{
				status: NaN,
				description: `Preview Result response failure`,
				schema: load_balancing_preview_result_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/regions",
		alias: "load-balancer-regions-list-regions",
		description: `List all region mappings.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "subdivision_code",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "subdivision_code_a2",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "country_code_a2",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: load_balancing_region_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Regions response failure`,
				schema: load_balancing_region_components_schemas_response_collection.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/regions/:region_id",
		alias: "load-balancer-regions-get-region",
		description: `Get a single region mapping.`,
		requestFormat: "json",
		parameters: [
			{
				name: "region_id",
				type: "Path",
				schema: z.enum(["WNAM", "ENAM", "WEU", "EEU", "NSAM", "SSAM", "OC", "ME", "NAF", "SAF", "SAS", "SEAS", "NEAS"])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: load_balancing_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get Region response failure`,
				schema: load_balancing_components_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/load_balancers/search",
		alias: "account-load-balancer-search-search-resources",
		description: `Search for Load Balancing resources.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "search_params",
				type: "Query",
				schema: search_params
			},
			{
				name: "page",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.unknown().optional().default(25)
			},
		],
		response: load_balancing_api_response_collection.and(load_balancing_search_result),
		errors: [
			{
				status: NaN,
				description: `Search Resources response failure`,
				schema: load_balancing_api_response_collection.and(load_balancing_search_result).and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/logpush/datasets/:dataset_id/fields",
		alias: "get-accounts-account_identifier-logpush-datasets-dataset-fields",
		description: `Lists all fields available for a dataset. The response result is an object with key-value pairs, where keys are field names, and values are descriptions.`,
		requestFormat: "json",
		parameters: [
			{
				name: "dataset_id",
				type: "Path",
				schema: z.string().max(256).regex(/^[a-zA-Z0-9_\-]*$/).nullable()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_field_response_collection,
		errors: [
			{
				status: NaN,
				description: `List fields response failure`,
				schema: logpush_logpush_field_response_collection.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/logpush/datasets/:dataset_id/jobs",
		alias: "get-accounts-account_identifier-logpush-datasets-dataset-jobs",
		description: `Lists Logpush jobs for an account for a dataset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "dataset_id",
				type: "Path",
				schema: z.string().max(256).regex(/^[a-zA-Z0-9_\-]*$/).nullable()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_job_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Logpush jobs for a dataset response failure`,
				schema: logpush_logpush_job_response_collection.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/logpush/jobs",
		alias: "get-accounts-account_identifier-logpush-jobs",
		description: `Lists Logpush jobs for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_job_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Logpush jobs response failure`,
				schema: logpush_logpush_job_response_collection.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/logpush/jobs",
		alias: "post-accounts-account_identifier-logpush-jobs",
		description: `Creates a new Logpush job for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ dataset: logpush_dataset.max(256).regex(/^[a-zA-Z0-9_\-]*$/).nullish(), destination_conf: logpush_destination_conf.max(4096).url(), enabled: logpush_enabled.optional(), frequency: logpush_frequency.nullish().default("high"), logpull_options: logpush_logpull_options.max(4096).nullish(), name: logpush_name.max(512).regex(/^[a-zA-Z0-9\-\.]*$/).nullish(), output_options: logpush_output_options.nullish(), ownership_challenge: logpush_ownership_challenge.max(4096).regex(/^[a-zA-Z0-9/\+\.\-_]*$/).optional() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_job_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Logpush job response failure`,
				schema: logpush_logpush_job_response_single.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/logpush/jobs/:job_id",
		alias: "delete-accounts-account_identifier-logpush-jobs-job_identifier",
		description: `Deletes a Logpush job.`,
		requestFormat: "json",
		parameters: [
			{
				name: "job_id",
				type: "Path",
				schema: z.number().int().gte(1)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_api_response_common.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Logpush job response failure`,
				schema: logpush_api_response_common.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/logpush/jobs/:job_id",
		alias: "get-accounts-account_identifier-logpush-jobs-job_identifier",
		description: `Gets the details of a Logpush job.`,
		requestFormat: "json",
		parameters: [
			{
				name: "job_id",
				type: "Path",
				schema: z.number().int().gte(1)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_job_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Logpush job details response failure`,
				schema: logpush_logpush_job_response_single.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/logpush/jobs/:job_id",
		alias: "put-accounts-account_identifier-logpush-jobs-job_identifier",
		description: `Updates a Logpush job.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ destination_conf: logpush_destination_conf.max(4096).url(), enabled: logpush_enabled, frequency: logpush_frequency.nullable().default("high"), logpull_options: logpush_logpull_options.max(4096).nullable(), output_options: logpush_output_options.nullable(), ownership_challenge: logpush_ownership_challenge.max(4096).regex(/^[a-zA-Z0-9/\+\.\-_]*$/) }).partial().passthrough()
			},
			{
				name: "job_id",
				type: "Path",
				schema: z.number().int().gte(1)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_job_response_single,
		errors: [
			{
				status: NaN,
				description: `Update Logpush job response failure`,
				schema: logpush_logpush_job_response_single.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/logpush/ownership",
		alias: "post-accounts-account_identifier-logpush-ownership",
		description: `Gets a new ownership challenge sent to your destination.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ destination_conf: logpush_destination_conf.max(4096).url() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_get_ownership_response,
		errors: [
			{
				status: NaN,
				description: `Get ownership challenge response failure`,
				schema: logpush_get_ownership_response.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/logpush/ownership/validate",
		alias: "post-accounts-account_identifier-logpush-ownership-validate",
		description: `Validates ownership challenge of the destination.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ destination_conf: logpush_destination_conf.max(4096).url(), ownership_challenge: logpush_ownership_challenge.max(4096).regex(/^[a-zA-Z0-9/\+\.\-_]*$/) }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_validate_ownership_response,
		errors: [
			{
				status: NaN,
				description: `Validate ownership challenge response failure`,
				schema: logpush_validate_ownership_response.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/logpush/validate/destination/exists",
		alias: "delete-accounts-account_identifier-logpush-validate-destination-exists",
		description: `Checks if there is an existing job with a destination.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ destination_conf: logpush_destination_conf.max(4096).url() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_destination_exists_response,
		errors: [
			{
				status: NaN,
				description: `Check destination exists response failure`,
				schema: logpush_destination_exists_response.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/logpush/validate/origin",
		alias: "post-accounts-account_identifier-logpush-validate-origin",
		description: `Validates logpull origin with logpull_options.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ logpull_options: logpush_logpull_options.max(4096).nullable() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_validate_response,
		errors: [
			{
				status: NaN,
				description: `Validate origin response failure`,
				schema: logpush_validate_response.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/logs/control/cmb/config",
		alias: "delete-accounts-account_identifier-logs-control-cmb-config",
		description: `Deletes CMB config.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logcontrol_api_response_common.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete CMB config response failure`,
				schema: logcontrol_api_response_common.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(logcontrol_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/logs/control/cmb/config",
		alias: "get-accounts-account_identifier-logs-control-cmb-config",
		description: `Gets CMB config.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logcontrol_cmb_config_response_single,
		errors: [
			{
				status: NaN,
				description: `Get CMB config response failure`,
				schema: logcontrol_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/logs/control/cmb/config",
		alias: "put-accounts-account_identifier-logs-control-cmb-config",
		description: `Updates CMB config.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: logcontrol_cmb_config.nullable()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logcontrol_cmb_config_response_single,
		errors: [
			{
				status: NaN,
				description: `Update CMB config response failure`,
				schema: logcontrol_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/members",
		alias: "account-members-list-members",
		description: `List all members of an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "order",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "status",
				type: "Query",
				schema: z.enum(["accepted", "pending", "rejected"]).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
		],
		response: iam_collection_member_response,
		errors: [
			{
				status: NaN,
				description: `List Members response failure`,
				schema: iam_response_collection.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/members",
		alias: "account-members-add-member",
		description: `Add a user to the list of members for this account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: iam_create
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_single_member_response_with_code,
		errors: [
			{
				status: NaN,
				description: `Add Member response failure`,
				schema: iam_response_single.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/members/:member_id",
		alias: "account-members-remove-member",
		description: `Remove a member from an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "member_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_api_response_single_id,
		errors: [
			{
				status: NaN,
				description: `Remove Member response failure`,
				schema: iam_api_response_single_id.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/members/:member_id",
		alias: "account-members-member-details",
		description: `Get information about a specific member of an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "member_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_single_member_response,
		errors: [
			{
				status: NaN,
				description: `Member Details response failure`,
				schema: iam_response_single.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/members/:member_id",
		alias: "account-members-update-member",
		description: `Modify an account member.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: iam_schemas_member
			},
			{
				name: "member_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_single_member_response,
		errors: [
			{
				status: NaN,
				description: `Update Member response failure`,
				schema: iam_response_single.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/mtls_certificates",
		alias: "m-tls-certificate-management-list-m-tls-certificates",
		description: `Lists all mTLS certificates.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_mtls_management_components_schemas_certificate_response_collection,
		errors: [
			{
				status: NaN,
				description: `List mTLS certificates response failure`,
				schema: tls_certificates_and_hostnames_mtls_management_components_schemas_certificate_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/mtls_certificates",
		alias: "m-tls-certificate-management-upload-m-tls-certificate",
		description: `Upload a certificate that you want to use with mTLS-enabled Cloudflare services.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: m_tls_certificate_management_upload_m_tls_certificate_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_single_post,
		errors: [
			{
				status: NaN,
				description: `Upload mTLS certificate response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_single_post.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/mtls_certificates/:mtls_certificate_id",
		alias: "m-tls-certificate-management-delete-m-tls-certificate",
		description: `Deletes the mTLS certificate unless the certificate is in use by one or more Cloudflare services.`,
		requestFormat: "json",
		parameters: [
			{
				name: "mtls_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_mtls_management_components_schemas_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete mTLS certificate response failure`,
				schema: tls_certificates_and_hostnames_mtls_management_components_schemas_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/mtls_certificates/:mtls_certificate_id",
		alias: "m-tls-certificate-management-get-m-tls-certificate",
		description: `Fetches a single mTLS certificate.`,
		requestFormat: "json",
		parameters: [
			{
				name: "mtls_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_mtls_management_components_schemas_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Get mTLS certificate response failure`,
				schema: tls_certificates_and_hostnames_mtls_management_components_schemas_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/mtls_certificates/:mtls_certificate_id/associations",
		alias: "m-tls-certificate-management-list-m-tls-certificate-associations",
		description: `Lists all active associations between the certificate and Cloudflare services.`,
		requestFormat: "json",
		parameters: [
			{
				name: "mtls_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_association_response_collection,
		errors: [
			{
				status: NaN,
				description: `List mTLS certificate associations response failure`,
				schema: tls_certificates_and_hostnames_association_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/pages/projects",
		alias: "pages-project-get-projects",
		description: `Fetch a list of all user projects.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_projects_response,
		errors: [
			{
				status: NaN,
				description: `Get projects response failure.`,
				schema: pages_projects_response.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/pages/projects",
		alias: "pages-project-create-project",
		description: `Create a new project.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: pages_projects
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_new_project_response,
		errors: [
			{
				status: NaN,
				description: `Create project response failure.`,
				schema: pages_new_project_response.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/pages/projects/:project_name",
		alias: "pages-project-delete-project",
		description: `Delete a project by name.`,
		requestFormat: "json",
		parameters: [
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.unknown(),
		errors: [
			{
				status: NaN,
				description: `Delete project response failure.`,
				schema: z.unknown().and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/pages/projects/:project_name",
		alias: "pages-project-get-project",
		description: `Fetch a project by name.`,
		requestFormat: "json",
		parameters: [
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_project_response,
		errors: [
			{
				status: NaN,
				description: `Get project response failure.`,
				schema: pages_project_response.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/pages/projects/:project_name",
		alias: "pages-project-update-project",
		description: `Set new attributes for an existing project. Modify environment variables. To delete an environment variable, set the key to null.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_new_project_response,
		errors: [
			{
				status: NaN,
				description: `Update project response failure.`,
				schema: pages_new_project_response.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/pages/projects/:project_name/deployments",
		alias: "pages-deployment-get-deployments",
		description: `Fetch a list of project deployments.`,
		requestFormat: "json",
		parameters: [
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_deployment_list_response,
		errors: [
			{
				status: NaN,
				description: `Get deployments response failure.`,
				schema: pages_deployment_list_response.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/pages/projects/:project_name/deployments",
		alias: "pages-deployment-create-deployment",
		description: `Start a new deployment from production. The repository and account must have already been authorized on the Cloudflare Pages dashboard.`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ branch: z.string() }).partial().passthrough()
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_deployment_new_deployment,
		errors: [
			{
				status: NaN,
				description: `Create deployment response failure.`,
				schema: pages_deployment_new_deployment.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/pages/projects/:project_name/deployments/:deployment_id",
		alias: "pages-deployment-delete-deployment",
		description: `Delete a deployment.`,
		requestFormat: "json",
		parameters: [
			{
				name: "deployment_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.unknown(),
		errors: [
			{
				status: NaN,
				description: `Delete deployment response failure.`,
				schema: z.unknown().and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/pages/projects/:project_name/deployments/:deployment_id",
		alias: "pages-deployment-get-deployment-info",
		description: `Fetch information about a deployment.`,
		requestFormat: "json",
		parameters: [
			{
				name: "deployment_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_deployment_response_details,
		errors: [
			{
				status: NaN,
				description: `Get deployment info response failure.`,
				schema: pages_deployment_response_details.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/pages/projects/:project_name/deployments/:deployment_id/history/logs",
		alias: "pages-deployment-get-deployment-logs",
		description: `Fetch deployment logs for a project.`,
		requestFormat: "json",
		parameters: [
			{
				name: "deployment_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_deployment_response_logs,
		errors: [
			{
				status: NaN,
				description: `Get deployment logs response failure.`,
				schema: pages_deployment_response_logs.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/pages/projects/:project_name/deployments/:deployment_id/retry",
		alias: "pages-deployment-retry-deployment",
		description: `Retry a previous deployment.`,
		requestFormat: "json",
		parameters: [
			{
				name: "deployment_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_deployment_new_deployment,
		errors: [
			{
				status: NaN,
				description: `Retry deployment response failure.`,
				schema: pages_deployment_new_deployment.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/pages/projects/:project_name/deployments/:deployment_id/rollback",
		alias: "pages-deployment-rollback-deployment",
		description: `Rollback the production deployment to a previous deployment. You can only rollback to succesful builds on production.`,
		requestFormat: "json",
		parameters: [
			{
				name: "deployment_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_deployment_response_details,
		errors: [
			{
				status: NaN,
				description: `Rollback deployment response failure.`,
				schema: pages_deployment_response_details.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/pages/projects/:project_name/domains",
		alias: "pages-domains-get-domains",
		description: `Fetch a list of all domains associated with a Pages project.`,
		requestFormat: "json",
		parameters: [
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_domain_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get domains response failure.`,
				schema: pages_domain_response_collection.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/pages/projects/:project_name/domains",
		alias: "pages-domains-add-domain",
		description: `Add a new domain for the Pages project.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_domain_response_single,
		errors: [
			{
				status: NaN,
				description: `Add domain response failure.`,
				schema: pages_domain_response_single.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/pages/projects/:project_name/domains/:domain_name",
		alias: "pages-domains-delete-domain",
		description: `Delete a Pages project&#x27;s domain.`,
		requestFormat: "json",
		parameters: [
			{
				name: "domain_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.unknown(),
		errors: [
			{
				status: NaN,
				description: `Delete domain response failure.`,
				schema: z.unknown().and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/pages/projects/:project_name/domains/:domain_name",
		alias: "pages-domains-get-domain",
		description: `Fetch a single domain.`,
		requestFormat: "json",
		parameters: [
			{
				name: "domain_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_domain_response_single,
		errors: [
			{
				status: NaN,
				description: `Get domain response failure.`,
				schema: pages_domain_response_single.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/pages/projects/:project_name/domains/:domain_name",
		alias: "pages-domains-patch-domain",
		description: `Retry the validation status of a single domain.`,
		requestFormat: "json",
		parameters: [
			{
				name: "domain_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: pages_domain_response_single,
		errors: [
			{
				status: NaN,
				description: `Patch domain response failure.`,
				schema: pages_domain_response_single.and(pages_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/pages/projects/:project_name/purge_build_cache",
		alias: "pages-purge-build-cache",
		description: `Purge all cached build artifacts for a Pages project`,
		requestFormat: "json",
		parameters: [
			{
				name: "project_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9][a-z0-9-]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.unknown(),
		errors: [
			{
				status: NaN,
				description: `Purge build cache failure.`,
				schema: pages_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/pcaps",
		alias: "magic-pcap-collection-list-packet-capture-requests",
		description: `Lists all packet capture requests for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_visibility_pcaps_collection_response,
	},
	{
		method: "post",
		path: "/accounts/:account_id/pcaps",
		alias: "magic-pcap-collection-create-pcap-request",
		description: `Create new PCAP request for account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_visibility_pcaps_request_pcap
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_visibility_pcaps_single_response,
	},
	{
		method: "get",
		path: "/accounts/:account_id/pcaps/:pcap_id",
		alias: "magic-pcap-collection-get-pcap-request",
		description: `Get information for a PCAP request by id.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pcap_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_visibility_pcaps_single_response,
	},
	{
		method: "get",
		path: "/accounts/:account_id/pcaps/:pcap_id/download",
		alias: "magic-pcap-collection-download-simple-pcap",
		description: `Download PCAP information into a file. Response is a binary PCAP file.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pcap_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.void(),
	},
	{
		method: "get",
		path: "/accounts/:account_id/pcaps/ownership",
		alias: "magic-pcap-collection-list-pca-ps-bucket-ownership",
		description: `List all buckets configured for use with PCAPs API.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_visibility_pcaps_ownership_collection,
	},
	{
		method: "post",
		path: "/accounts/:account_id/pcaps/ownership",
		alias: "magic-pcap-collection-add-buckets-for-full-packet-captures",
		description: `Adds an AWS or GCP bucket to use with full packet captures.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_visibility_pcaps_ownership_request
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_visibility_pcaps_ownership_single_response,
	},
	{
		method: "delete",
		path: "/accounts/:account_id/pcaps/ownership/:ownership_id",
		alias: "magic-pcap-collection-delete-buckets-for-full-packet-captures",
		description: `Deletes buckets added to the packet captures API.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ownership_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.void(),
	},
	{
		method: "post",
		path: "/accounts/:account_id/pcaps/ownership/validate",
		alias: "magic-pcap-collection-validate-buckets-for-full-packet-captures",
		description: `Validates buckets added to the packet captures API.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_visibility_pcaps_ownership_validate_request
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_visibility_pcaps_ownership_single_response,
	},
	{
		method: "get",
		path: "/accounts/:account_id/r2/buckets",
		alias: "r2-list-buckets",
		description: `Lists all R2 buckets on your account`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "name_contains",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "start_after",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(1000).optional().default(20)
			},
			{
				name: "order",
				type: "Query",
				schema: z.literal("name").optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
			{
				name: "cursor",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: r2_v4_response_list.and(z.object({ result: z.array(r2_bucket) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Buckets response failure`,
				schema: r2_v4_response_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/r2/buckets",
		alias: "r2-create-bucket",
		description: `Creates a new R2 bucket.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: r2_create_bucket_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: r2_v4_response.and(z.object({ result: r2_bucket }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create Bucket response failure`,
				schema: r2_v4_response_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/r2/buckets/:bucket_name",
		alias: "r2-delete-bucket",
		description: `Deletes an existing R2 bucket.`,
		requestFormat: "json",
		parameters: [
			{
				name: "bucket_name",
				type: "Path",
				schema: z.string().min(3).max(64).regex(/^[a-z0-9][a-z0-9-]*[a-z0-9]/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: r2_v4_response,
		errors: [
			{
				status: NaN,
				description: `Delete Bucket response failure`,
				schema: r2_v4_response_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/r2/buckets/:bucket_name",
		alias: "r2-get-bucket",
		description: `Gets metadata for an existing R2 bucket.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "bucket_name",
				type: "Path",
				schema: z.string().min(3).max(64).regex(/^[a-z0-9][a-z0-9-]*[a-z0-9]/)
			},
		],
		response: r2_v4_response.and(z.object({ result: r2_bucket }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Bucket response failure`,
				schema: r2_v4_response_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/r2/buckets/:bucket_name/sippy",
		alias: "r2-delete-bucket-sippy-config",
		description: `Disables Sippy on this bucket`,
		requestFormat: "json",
		parameters: [
			{
				name: "bucket_name",
				type: "Path",
				schema: z.string().min(3).max(64).regex(/^[a-z0-9][a-z0-9-]*[a-z0-9]/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: r2_v4_response.and(z.object({ result: z.object({ enabled: z.literal(false) }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Sippy Configuration response failure`,
				schema: r2_v4_response_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/r2/buckets/:bucket_name/sippy",
		alias: "r2-get-bucket-sippy-config",
		description: `Gets configuration for Sippy for an existing R2 bucket.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "bucket_name",
				type: "Path",
				schema: z.string().min(3).max(64).regex(/^[a-z0-9][a-z0-9-]*[a-z0-9]/)
			},
		],
		response: r2_v4_response.and(z.object({ result: r2_sippy }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Sippy Configuration response failure`,
				schema: r2_v4_response_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/r2/buckets/:bucket_name/sippy",
		alias: "r2-put-bucket-sippy-config",
		description: `Sets configuration for Sippy for an existing R2 bucket.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: r2_put_bucket_sippy_config_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "bucket_name",
				type: "Path",
				schema: z.string().min(3).max(64).regex(/^[a-z0-9][a-z0-9-]*[a-z0-9]/)
			},
		],
		response: r2_v4_response.and(z.object({ result: r2_sippy }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Sippy Configuration response failure`,
				schema: r2_v4_response_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/registrar/domains",
		alias: "registrar-domains-list-domains",
		description: `List domains handled by Registrar.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: registrar_api_domain_response_collection,
		errors: [
			{
				status: NaN,
				description: `List domains response failure`,
				schema: registrar_api_domain_response_collection.and(registrar_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/registrar/domains/:domain_name",
		alias: "registrar-domains-get-domain",
		description: `Show individual domain.`,
		requestFormat: "json",
		parameters: [
			{
				name: "domain_name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: registrar_api_domain_response_single,
		errors: [
			{
				status: NaN,
				description: `Get domain response failure`,
				schema: registrar_api_domain_response_single.and(registrar_api_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/registrar/domains/:domain_name",
		alias: "registrar-domains-update-domain",
		description: `Update individual domain.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: registrar_domains_update_domain_Body
			},
			{
				name: "domain_name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: registrar_api_domain_response_single,
		errors: [
			{
				status: NaN,
				description: `Update domain response failure`,
				schema: registrar_api_domain_response_single.and(registrar_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/roles",
		alias: "account-roles-list-roles",
		description: `Get all available roles for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_collection_role_response,
		errors: [
			{
				status: NaN,
				description: `List Roles response failure`,
				schema: iam_response_collection.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/roles/:role_id",
		alias: "account-roles-role-details",
		description: `Get information about a specific role for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "role_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_single_role_response,
		errors: [
			{
				status: NaN,
				description: `Role Details response failure`,
				schema: iam_response_single.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rules/lists",
		alias: "lists-get-lists",
		description: `Fetches all lists in the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: lists_lists_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get lists response failure`,
				schema: lists_lists_response_collection.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/rules/lists",
		alias: "lists-create-a-list",
		description: `Creates a new list of the specified type.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: lists_create_a_list_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: lists_list_response_collection,
		errors: [
			{
				status: NaN,
				description: `Create a list response failure`,
				schema: lists_list_response_collection.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/rules/lists/:list_id",
		alias: "lists-delete-a-list",
		description: `Deletes a specific list and all its items.`,
		requestFormat: "json",
		parameters: [
			{
				name: "list_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: lists_list_delete_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete a list response failure`,
				schema: lists_list_delete_response_collection.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rules/lists/:list_id",
		alias: "lists-get-a-list",
		description: `Fetches the details of a list.`,
		requestFormat: "json",
		parameters: [
			{
				name: "list_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: lists_list_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get a list response failure`,
				schema: lists_list_response_collection.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/rules/lists/:list_id",
		alias: "lists-update-a-list",
		description: `Updates the description of a list.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: lists_update_a_list_Body
			},
			{
				name: "list_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: lists_list_response_collection,
		errors: [
			{
				status: NaN,
				description: `Update a list response failure`,
				schema: lists_list_response_collection.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/rules/lists/:list_id/items",
		alias: "lists-delete-list-items",
		description: `Removes one or more items from a list.

This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](/operations/lists-get-bulk-operation-status) endpoint with the returned &#x60;operation_id&#x60;.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ items: z.array(z.object({ id: lists_item_id }).partial().passthrough()).min(1) }).partial().passthrough()
			},
			{
				name: "list_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: lists_lists_async_response,
		errors: [
			{
				status: NaN,
				description: `Delete list items response failure`,
				schema: lists_lists_async_response.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rules/lists/:list_id/items",
		alias: "lists-get-list-items",
		description: `Fetches all the items in the list.`,
		requestFormat: "json",
		parameters: [
			{
				name: "list_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "cursor",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().int().gte(1).lte(500).optional()
			},
			{
				name: "search",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: lists_items_list_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get list items response failure`,
				schema: lists_items_list_response_collection.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/rules/lists/:list_id/items",
		alias: "lists-create-list-items",
		description: `Appends new items to the list.

This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](/operations/lists-get-bulk-operation-status) endpoint with the returned &#x60;operation_id&#x60;.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: lists_items_update_request_collection
			},
			{
				name: "list_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: lists_lists_async_response,
		errors: [
			{
				status: NaN,
				description: `Create list items response failure`,
				schema: lists_lists_async_response.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/rules/lists/:list_id/items",
		alias: "lists-update-all-list-items",
		description: `Removes all existing items from the list and adds the provided items to the list.

This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](/operations/lists-get-bulk-operation-status) endpoint with the returned &#x60;operation_id&#x60;.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: lists_items_update_request_collection
			},
			{
				name: "list_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: lists_lists_async_response,
		errors: [
			{
				status: NaN,
				description: `Update all list items response failure`,
				schema: lists_lists_async_response.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rulesets",
		alias: "listAccountRulesets",
		description: `Fetches all rulesets at the account level.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetsResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List account rulesets failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/rulesets",
		alias: "createAccountRuleset",
		description: `Creates a ruleset at the account level.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_CreateRulesetRequest
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create an account ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/rulesets/:ruleset_id",
		alias: "deleteAccountRuleset",
		description: `Deletes all versions of an existing account ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Delete an account ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rulesets/:ruleset_id",
		alias: "getAccountRuleset",
		description: `Fetches the latest version of an account ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get an account ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/rulesets/:ruleset_id",
		alias: "updateAccountRuleset",
		description: `Updates an account ruleset, creating a new version.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_UpdateRulesetRequest
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update an account ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/rulesets/:ruleset_id/rules",
		alias: "createAccountRulesetRule",
		description: `Adds a new rule to an account ruleset. The rule will be added to the end of the existing list of rules in the ruleset by default.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_CreateOrUpdateRuleRequest
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create an account ruleset rule failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/rulesets/:ruleset_id/rules/:rule_id",
		alias: "deleteAccountRulesetRule",
		description: `Deletes an existing rule from an account ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete an account ruleset rule failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/rulesets/:ruleset_id/rules/:rule_id",
		alias: "updateAccountRulesetRule",
		description: `Updates an existing rule in an account ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_CreateOrUpdateRuleRequest
			},
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update an account ruleset rule failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rulesets/:ruleset_id/versions",
		alias: "listAccountRulesetVersions",
		description: `Fetches the versions of an account ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetsResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List an account ruleset&#x27;s versions failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/rulesets/:ruleset_id/versions/:ruleset_version",
		alias: "deleteAccountRulesetVersion",
		description: `Deletes an existing version of an account ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_version",
				type: "Path",
				schema: z.string().regex(/^[0-9]+$/)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Delete an account ruleset version failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rulesets/:ruleset_id/versions/:ruleset_version",
		alias: "getAccountRulesetVersion",
		description: `Fetches a specific version of an account ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_version",
				type: "Path",
				schema: z.string().regex(/^[0-9]+$/)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get an account ruleset version failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rulesets/:ruleset_id/versions/:ruleset_version/by_tag/:rule_tag",
		alias: "listAccountRulesetVersionRulesByTag",
		description: `Fetches the rules of a managed account ruleset version for a given tag.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_tag",
				type: "Path",
				schema: z.string().min(1)
			},
			{
				name: "ruleset_version",
				type: "Path",
				schema: z.string().regex(/^[0-9]+$/)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List an account ruleset version&#x27;s rules by tag failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rulesets/phases/:ruleset_phase/entrypoint",
		alias: "getAccountEntrypointRuleset",
		description: `Fetches the latest version of the account entry point ruleset for a given phase.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_phase",
				type: "Path",
				schema: z.enum(["ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_select_configuration", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed"])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get an account entry point ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/rulesets/phases/:ruleset_phase/entrypoint",
		alias: "updateAccountEntrypointRuleset",
		description: `Updates an account entry point ruleset, creating a new version.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_UpdateRulesetRequest
			},
			{
				name: "ruleset_phase",
				type: "Path",
				schema: z.enum(["ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_select_configuration", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed"])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update an account entry point ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rulesets/phases/:ruleset_phase/entrypoint/versions",
		alias: "listAccountEntrypointRulesetVersions",
		description: `Fetches the versions of an account entry point ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_phase",
				type: "Path",
				schema: z.enum(["ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_select_configuration", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed"])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetsResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List an account entry point ruleset&#x27;s versions failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rulesets/phases/:ruleset_phase/entrypoint/versions/:ruleset_version",
		alias: "getAccountEntrypointRulesetVersion",
		description: `Fetches a specific version of an account entry point ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_version",
				type: "Path",
				schema: z.string().regex(/^[0-9]+$/)
			},
			{
				name: "ruleset_phase",
				type: "Path",
				schema: z.enum(["ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_select_configuration", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed"])
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get an account entry point ruleset version failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/rum/site_info",
		alias: "web-analytics-create-site",
		description: `Creates a new Web Analytics site.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rum_create_site_request
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: rum_site_response_single,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: rum_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/rum/site_info/:site_id",
		alias: "web-analytics-delete-site",
		description: `Deletes an existing Web Analytics site.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "site_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: rum_site_tag_response_single,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: rum_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rum/site_info/:site_id",
		alias: "web-analytics-get-site",
		description: `Retrieves a Web Analytics site.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "site_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: rum_site_response_single,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: rum_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/rum/site_info/:site_id",
		alias: "web-analytics-update-site",
		description: `Updates an existing Web Analytics site.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rum_create_site_request
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "site_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: rum_site_response_single,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: rum_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rum/site_info/list",
		alias: "web-analytics-list-sites",
		description: `Lists all Web Analytics sites of an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "order_by",
				type: "Query",
				schema: z.enum(["host", "created"]).optional()
			},
		],
		response: rum_sites_response_collection,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: rum_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/rum/v2/:ruleset_id/rule",
		alias: "web-analytics-create-rule",
		description: `Creates a new rule in a Web Analytics ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rum_create_rule_request
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: rum_rule_response_single,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: rum_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/rum/v2/:ruleset_id/rule/:rule_id",
		alias: "web-analytics-delete-rule",
		description: `Deletes an existing rule from a Web Analytics ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "rule_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: rum_rule_id_response_single,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: rum_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/rum/v2/:ruleset_id/rule/:rule_id",
		alias: "web-analytics-update-rule",
		description: `Updates a rule in a Web Analytics ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rum_create_rule_request
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "rule_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: rum_rule_response_single,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: rum_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/rum/v2/:ruleset_id/rules",
		alias: "web-analytics-list-rules",
		description: `Lists all the rules in a Web Analytics ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: rum_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: rum_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/rum/v2/:ruleset_id/rules",
		alias: "web-analytics-modify-rules",
		description: `Modifies one or more rules in a Web Analytics ruleset with a single request.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rum_modify_rules_request
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: rum_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: rum_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/secondary_dns/acls",
		alias: "secondary-dns-(-acl)-list-ac-ls",
		description: `List ACLs.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List ACLs response failure`,
				schema: secondary_dns_components_schemas_response_collection.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/secondary_dns/acls",
		alias: "secondary-dns-(-acl)-create-acl",
		description: `Create ACL.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create ACL response failure`,
				schema: secondary_dns_components_schemas_single_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/secondary_dns/acls/:acl_id",
		alias: "secondary-dns-(-acl)-delete-acl",
		description: `Delete ACL.`,
		requestFormat: "json",
		parameters: [
			{
				name: "acl_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_components_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete ACL response failure`,
				schema: secondary_dns_components_schemas_id_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/secondary_dns/acls/:acl_id",
		alias: "secondary-dns-(-acl)-acl-details",
		description: `Get ACL.`,
		requestFormat: "json",
		parameters: [
			{
				name: "acl_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `ACL Details response failure`,
				schema: secondary_dns_components_schemas_single_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/secondary_dns/acls/:acl_id",
		alias: "secondary-dns-(-acl)-update-acl",
		description: `Modify ACL.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: secondary_dns_acl
			},
			{
				name: "acl_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update ACL response failure`,
				schema: secondary_dns_components_schemas_single_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/secondary_dns/peers",
		alias: "secondary-dns-(-peer)-list-peers",
		description: `List Peers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Peers response failure`,
				schema: secondary_dns_schemas_response_collection.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/secondary_dns/peers",
		alias: "secondary-dns-(-peer)-create-peer",
		description: `Create Peer.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create Peer response failure`,
				schema: secondary_dns_schemas_single_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/secondary_dns/peers/:peer_id",
		alias: "secondary-dns-(-peer)-delete-peer",
		description: `Delete Peer.`,
		requestFormat: "json",
		parameters: [
			{
				name: "peer_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_components_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Peer response failure`,
				schema: secondary_dns_components_schemas_id_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/secondary_dns/peers/:peer_id",
		alias: "secondary-dns-(-peer)-peer-details",
		description: `Get Peer.`,
		requestFormat: "json",
		parameters: [
			{
				name: "peer_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Peer Details response failure`,
				schema: secondary_dns_schemas_single_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/secondary_dns/peers/:peer_id",
		alias: "secondary-dns-(-peer)-update-peer",
		description: `Modify Peer.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: secondary_dns_peer
			},
			{
				name: "peer_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Peer response failure`,
				schema: secondary_dns_schemas_single_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/secondary_dns/tsigs",
		alias: "secondary-dns-(-tsig)-list-tsi-gs",
		description: `List TSIGs.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_response_collection,
		errors: [
			{
				status: NaN,
				description: `List TSIGs response failure`,
				schema: secondary_dns_response_collection.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/secondary_dns/tsigs",
		alias: "secondary-dns-(-tsig)-create-tsig",
		description: `Create TSIG.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: secondary_dns_tsig
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_single_response,
		errors: [
			{
				status: NaN,
				description: `Create TSIG response failure`,
				schema: secondary_dns_single_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/secondary_dns/tsigs/:tsig_id",
		alias: "secondary-dns-(-tsig)-delete-tsig",
		description: `Delete TSIG.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tsig_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete TSIG response failure`,
				schema: secondary_dns_schemas_id_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/secondary_dns/tsigs/:tsig_id",
		alias: "secondary-dns-(-tsig)-tsig-details",
		description: `Get TSIG.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tsig_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_single_response,
		errors: [
			{
				status: NaN,
				description: `TSIG Details response failure`,
				schema: secondary_dns_single_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/secondary_dns/tsigs/:tsig_id",
		alias: "secondary-dns-(-tsig)-update-tsig",
		description: `Modify TSIG.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: secondary_dns_tsig
			},
			{
				name: "tsig_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_single_response,
		errors: [
			{
				status: NaN,
				description: `Update TSIG response failure`,
				schema: secondary_dns_single_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/storage/analytics",
		alias: "workers-kv-request-analytics-query-request-analytics",
		description: `Retrieves Workers KV request metrics for the given account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "query",
				type: "Query",
				schema: query
			},
		],
		response: workers_kv_api_response_single.and(z.object({ result: workers_kv_schemas_result }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Query Request Analytics response failure`,
				schema: workers_kv_api_response_single.and(z.object({ result: workers_kv_result }).partial().passthrough()).and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/storage/analytics/stored",
		alias: "workers-kv-stored-data-analytics-query-stored-data-analytics",
		description: `Retrieves Workers KV stored data metrics for the given account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "query",
				type: "Query",
				schema: query__2
			},
		],
		response: workers_kv_api_response_single.and(z.object({ result: workers_kv_components_schemas_result }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Query Stored Data Analytics response failure`,
				schema: workers_kv_api_response_single.and(z.object({ result: workers_kv_result }).partial().passthrough()).and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/storage/kv/namespaces",
		alias: "workers-kv-namespace-list-namespaces",
		description: `Returns the namespaces owned by an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(100).optional().default(20)
			},
			{
				name: "order",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: workers_kv_api_response_collection.and(z.object({ result: z.array(workers_kv_namespace) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Namespaces response failure`,
				schema: workers_kv_api_response_collection.and(z.object({ result: z.array(workers_kv_namespace) }).partial().passthrough()).and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/storage/kv/namespaces",
		alias: "workers-kv-namespace-create-a-namespace",
		description: `Creates a namespace under the given title. A &#x60;400&#x60; is returned if the account already owns a namespace with this title. A namespace must be explicitly deleted to be replaced.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_kv_create_rename_namespace_body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_kv_api_response_single.and(z.object({ result: workers_kv_namespace }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create a Namespace response failure`,
				schema: workers_kv_api_response_single.and(z.object({ result: workers_kv_namespace }).partial().passthrough()).and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/storage/kv/namespaces/:namespace_id",
		alias: "workers-kv-namespace-remove-a-namespace",
		description: `Deletes the namespace corresponding to the given ID.`,
		requestFormat: "json",
		parameters: [
			{
				name: "namespace_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_kv_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Remove a Namespace response failure`,
				schema: workers_kv_api_response_single.and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/storage/kv/namespaces/:namespace_id",
		alias: "workers-kv-namespace-rename-a-namespace",
		description: `Modifies a namespace&#x27;s title.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_kv_create_rename_namespace_body
			},
			{
				name: "namespace_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_kv_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Rename a Namespace response failure`,
				schema: workers_kv_api_response_single.and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/storage/kv/namespaces/:namespace_id/bulk",
		alias: "workers-kv-namespace-delete-multiple-key-value-pairs",
		description: `Remove multiple KV pairs from the namespace. Body should be an array of up to 10,000 keys to be removed.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(workers_kv_key_name_bulk)
			},
			{
				name: "namespace_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_kv_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete multiple key-value pairs response failure`,
				schema: workers_kv_api_response_single.and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/storage/kv/namespaces/:namespace_id/bulk",
		alias: "workers-kv-namespace-write-multiple-key-value-pairs",
		description: `Write multiple keys and values at once. Body should be an array of up to 10,000 key-value pairs to be stored, along with optional expiration information. Existing values and expirations will be overwritten. If neither &#x60;expiration&#x60; nor &#x60;expiration_ttl&#x60; is specified, the key-value pair will never expire. If both are set, &#x60;expiration_ttl&#x60; is used and &#x60;expiration&#x60; is ignored. The entire request size must be 100 megabytes or less.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_kv_bulk_write
			},
			{
				name: "namespace_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_kv_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Write multiple key-value pairs response failure`,
				schema: workers_kv_api_response_single.and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/storage/kv/namespaces/:namespace_id/keys",
		alias: "workers-kv-namespace-list-a-namespace&#x27;-s-keys",
		description: `Lists a namespace&#x27;s keys.`,
		requestFormat: "json",
		parameters: [
			{
				name: "namespace_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().gte(10).lte(1000).optional().default(1000)
			},
			{
				name: "prefix",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "cursor",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: workers_kv_api_response_common.and(z.object({ result: z.array(workers_kv_key), result_info: z.object({ count: z.number(), cursor: workers_kv_cursor }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List a Namespace&#x27;s Keys response failure`,
				schema: workers_kv_api_response_common.and(z.object({ result: z.array(workers_kv_key), result_info: z.object({ count: z.number(), cursor: workers_kv_cursor }).partial().passthrough() }).partial().passthrough()).and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/storage/kv/namespaces/:namespace_id/metadata/:key_name",
		alias: "workers-kv-namespace-read-the-metadata-for-a-key",
		description: `Returns the metadata associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, &#x60;:&#x60;, &#x60;!&#x60;, &#x60;%&#x60;) in the key name.`,
		requestFormat: "json",
		parameters: [
			{
				name: "key_name",
				type: "Path",
				schema: z.string().max(512)
			},
			{
				name: "namespace_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_kv_api_response_single.and(z.object({ result: workers_kv_list_metadata }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Read the metadata for a key response failure`,
				schema: workers_kv_api_response_single.and(z.object({ result: workers_kv_list_metadata }).partial().passthrough()).and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/storage/kv/namespaces/:namespace_id/values/:key_name",
		alias: "workers-kv-namespace-delete-key-value-pair",
		description: `Remove a KV pair from the namespace. Use URL-encoding to use special characters (for example, &#x60;:&#x60;, &#x60;!&#x60;, &#x60;%&#x60;) in the key name.`,
		requestFormat: "json",
		parameters: [
			{
				name: "key_name",
				type: "Path",
				schema: z.string().max(512)
			},
			{
				name: "namespace_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_kv_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete key-value pair response failure`,
				schema: workers_kv_api_response_single.and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/storage/kv/namespaces/:namespace_id/values/:key_name",
		alias: "workers-kv-namespace-read-key-value-pair",
		description: `Returns the value associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, &#x60;:&#x60;, &#x60;!&#x60;, &#x60;%&#x60;) in the key name. If the KV-pair is set to expire at some point, the expiration time as measured in seconds since the UNIX epoch will be returned in the &#x60;expiration&#x60; response header.`,
		requestFormat: "json",
		parameters: [
			{
				name: "key_name",
				type: "Path",
				schema: z.string().max(512)
			},
			{
				name: "namespace_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.string(),
		errors: [
			{
				status: NaN,
				description: `Read key-value pair response failure`,
				schema: workers_kv_value.and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/storage/kv/namespaces/:namespace_id/values/:key_name",
		alias: "workers-kv-namespace-write-key-value-pair-with-metadata",
		description: `Write a value identified by a key. Use URL-encoding to use special characters (for example, &#x60;:&#x60;, &#x60;!&#x60;, &#x60;%&#x60;) in the key name. Body should be the value to be stored along with JSON metadata to be associated with the key/value pair. Existing values, expirations, and metadata will be overwritten. If neither &#x60;expiration&#x60; nor &#x60;expiration_ttl&#x60; is specified, the key-value pair will never expire. If both are set, &#x60;expiration_ttl&#x60; is used and &#x60;expiration&#x60; is ignored.`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_kv_namespace_write_key_value_pair_with_metadata_Body
			},
			{
				name: "key_name",
				type: "Path",
				schema: z.string().max(512)
			},
			{
				name: "namespace_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_kv_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Write key-value pair with metadata response failure`,
				schema: workers_kv_api_response_single.and(workers_kv_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream",
		alias: "stream-videos-list-videos",
		description: `Lists up to 1000 videos from a single request. For a specific range, refer to the optional parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "status",
				type: "Query",
				schema: z.enum(["pendingupload", "downloading", "queued", "inprogress", "ready", "error"]).optional()
			},
			{
				name: "creator",
				type: "Query",
				schema: z.string().max(64).optional()
			},
			{
				name: "type",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "asc",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "search",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "start",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "end",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "include_counts",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: stream_video_response_collection,
		errors: [
			{
				status: NaN,
				description: `List videos response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream",
		alias: "stream-videos-initiate-video-uploads-using-tus",
		description: `Initiates a video upload using the TUS protocol. On success, the server responds with a status code 201 (created) and includes a &#x60;location&#x60; header to indicate where the content should be uploaded. Refer to https://tus.io for protocol details.`,
		requestFormat: "json",
		parameters: [
			{
				name: "Tus-Resumable",
				type: "Header",
				schema: z.literal("1.0.0")
			},
			{
				name: "Upload-Creator",
				type: "Header",
				schema: z.string().max(64).optional()
			},
			{
				name: "Upload-Length",
				type: "Header",
				schema: z.number().int().gte(0)
			},
			{
				name: "Upload-Metadata",
				type: "Header",
				schema: z.string().optional()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.void(),
	},
	{
		method: "delete",
		path: "/accounts/:account_id/stream/:identifier",
		alias: "stream-videos-delete-video",
		description: `Deletes a video and its copies from Cloudflare Stream.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.void(),
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/:identifier",
		alias: "stream-videos-retrieve-video-details",
		description: `Fetches details for a single video.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_video_response_single,
		errors: [
			{
				status: NaN,
				description: `Retrieve video details response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/:identifier",
		alias: "stream-videos-update-video-details",
		description: `Edit details for a single video.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: stream_video_update
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_video_response_single,
		errors: [
			{
				status: NaN,
				description: `Edit video details response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/:identifier/audio",
		alias: "list-audio-tracks",
		description: `Lists additional audio tracks on a video. Note this API will not return information for audio attached to the video upload.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_listAudioTrackResponse,
		errors: [
			{
				status: NaN,
				description: `Lists additional audio tracks on a video response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/stream/:identifier/audio/:audio_identifier",
		alias: "delete-audio-tracks",
		description: `Deletes additional audio tracks on a video. Deleting a default audio track is not allowed. You must assign another audio track as default prior to deletion.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "audio_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Deletes additional audio tracks on a video response failure`,
				schema: stream_deleted_response
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/stream/:identifier/audio/:audio_identifier",
		alias: "edit-audio-tracks",
		description: `Edits additional audio tracks on a video. Editing the default status of an audio track to &#x60;true&#x60; will mark all other audio tracks on the video default status to &#x60;false&#x60;.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: stream_editAudioTrack
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "audio_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_addAudioTrackResponse,
		errors: [
			{
				status: NaN,
				description: `Edits additional audio tracks on a video response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/:identifier/audio/copy",
		alias: "add-audio-track",
		description: `Adds an additional audio track to a video using the provided audio track URL.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: stream_copyAudioTrack
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_addAudioTrackResponse,
		errors: [
			{
				status: NaN,
				description: `Add audio tracks to a video response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/:identifier/captions",
		alias: "stream-subtitles/-captions-list-captions-or-subtitles",
		description: `Lists the available captions or subtitles for a specific video.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_language_response_collection,
		errors: [
			{
				status: NaN,
				description: `List captions or subtitles response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/stream/:identifier/captions/:language",
		alias: "stream-subtitles/-captions-delete-captions-or-subtitles",
		description: `Removes the captions or subtitles from a video.`,
		requestFormat: "json",
		parameters: [
			{
				name: "language",
				type: "Path",
				schema: z.string()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_api_response_common.and(z.object({ result: z.string() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete captions or subtitles response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/stream/:identifier/captions/:language",
		alias: "stream-subtitles/-captions-upload-captions-or-subtitles",
		description: `Uploads the caption or subtitle file to the endpoint for a specific BCP47 language. One caption or subtitle file per language is allowed.`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ file: z.string() }).passthrough()
			},
			{
				name: "language",
				type: "Path",
				schema: z.string()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_language_response_single,
		errors: [
			{
				status: NaN,
				description: `Upload captions or subtitles response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/stream/:identifier/downloads",
		alias: "stream-m-p-4-downloads-delete-downloads",
		description: `Delete the downloads for a video.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete downloads response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/:identifier/downloads",
		alias: "stream-m-p-4-downloads-list-downloads",
		description: `Lists the downloads created for a video.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_downloads_response,
		errors: [
			{
				status: NaN,
				description: `List downloads response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/:identifier/downloads",
		alias: "stream-m-p-4-downloads-create-downloads",
		description: `Creates a download for a video when a video is ready to view.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_downloads_response,
		errors: [
			{
				status: NaN,
				description: `Create downloads response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/:identifier/embed",
		alias: "stream-videos-retreieve-embed-code-html",
		description: `Fetches an HTML code snippet to embed a video in a web page delivered through Cloudflare. On success, returns an HTML fragment for use on web pages to display a video. On failure, returns a JSON response body.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.unknown(),
		errors: [
			{
				status: NaN,
				description: `Retreieve embed Code HTML response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/:identifier/token",
		alias: "stream-videos-create-signed-url-tokens-for-videos",
		description: `Creates a signed URL token for a video. If a body is not provided in the request, a token is created with default values.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: stream_signed_token_request
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_signed_token_response,
		errors: [
			{
				status: NaN,
				description: `Create signed URL tokens for videos response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/clip",
		alias: "stream-video-clipping-clip-videos-given-a-start-and-end-time",
		description: `Clips a video based on the specified start and end times provided in seconds.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: stream_videoClipStandard
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_clipResponseSingle,
		errors: [
			{
				status: NaN,
				description: `Clip videos given a start and end time response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/copy",
		alias: "stream-videos-upload-videos-from-a-url",
		description: `Uploads a video to Stream from a provided URL.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ allowedOrigins: stream_allowedOrigins.optional(), creator: stream_creator.max(64).optional(), meta: stream_media_metadata.optional(), requireSignedURLs: stream_requireSignedURLs.optional(), scheduledDeletion: stream_scheduledDeletion.datetime({ offset: true }).optional(), thumbnailTimestampPct: stream_thumbnailTimestampPct.gte(0).lte(1).optional(), url: z.string().url(), watermark: stream_watermark_at_upload.optional() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "Upload-Creator",
				type: "Header",
				schema: z.string().max(64).optional()
			},
			{
				name: "Upload-Metadata",
				type: "Header",
				schema: z.string().optional()
			},
		],
		response: stream_video_response_single,
		errors: [
			{
				status: NaN,
				description: `Upload videos from a URL response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/direct_upload",
		alias: "stream-videos-upload-videos-via-direct-upload-ur-ls",
		description: `Creates a direct upload that allows video uploads without an API key.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: stream_direct_upload_request
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "Upload-Creator",
				type: "Header",
				schema: z.string().max(64).optional()
			},
		],
		response: stream_direct_upload_response,
		errors: [
			{
				status: NaN,
				description: `Upload videos via direct upload URLs response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/keys",
		alias: "stream-signing-keys-list-signing-keys",
		description: `Lists the video ID and creation date and time when a signing key was created.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_key_response_collection,
		errors: [
			{
				status: NaN,
				description: `List signing keys response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/keys",
		alias: "stream-signing-keys-create-signing-keys",
		description: `Creates an RSA private key in PEM and JWK formats. Key files are only displayed once after creation. Keys are created, used, and deleted independently of videos, and every key can sign any video.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_key_generation_response,
		errors: [
			{
				status: NaN,
				description: `Create signing keys response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/stream/keys/:identifier",
		alias: "stream-signing-keys-delete-signing-keys",
		description: `Deletes signing keys and revokes all signed URLs generated with the key.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete signing keys response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/live_inputs",
		alias: "stream-live-inputs-list-live-inputs",
		description: `Lists the live inputs created for an account. To get the credentials needed to stream to a specific live input, request a single live input.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "include_counts",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: stream_live_input_response_collection,
		errors: [
			{
				status: NaN,
				description: `List live inputs response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/live_inputs",
		alias: "stream-live-inputs-create-a-live-input",
		description: `Creates a live input, and returns credentials that you or your users can use to stream live video to Cloudflare Stream.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ defaultCreator: stream_live_input_default_creator, deleteRecordingAfterDays: stream_live_input_recording_deletion.gte(30), meta: stream_live_input_metadata, recording: stream_live_input_recording_settings }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_live_input_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a live input response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/stream/live_inputs/:live_input_identifier",
		alias: "stream-live-inputs-delete-a-live-input",
		description: `Prevents a live input from being streamed to and makes the live input inaccessible to any future API calls.`,
		requestFormat: "json",
		parameters: [
			{
				name: "live_input_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.void(),
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/live_inputs/:live_input_identifier",
		alias: "stream-live-inputs-retrieve-a-live-input",
		description: `Retrieves details of an existing live input.`,
		requestFormat: "json",
		parameters: [
			{
				name: "live_input_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_live_input_response_single,
		errors: [
			{
				status: NaN,
				description: `Retrieve a live input response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/stream/live_inputs/:live_input_identifier",
		alias: "stream-live-inputs-update-a-live-input",
		description: `Updates a specified live input.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ defaultCreator: stream_live_input_default_creator, deleteRecordingAfterDays: stream_live_input_recording_deletion.gte(30), meta: stream_live_input_metadata, recording: stream_live_input_recording_settings }).partial().passthrough()
			},
			{
				name: "live_input_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_live_input_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a live input response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/live_inputs/:live_input_identifier/outputs",
		alias: "stream-live-inputs-list-all-outputs-associated-with-a-specified-live-input",
		description: `Retrieves all outputs associated with a specified live input.`,
		requestFormat: "json",
		parameters: [
			{
				name: "live_input_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_output_response_collection,
		errors: [
			{
				status: NaN,
				description: `List all outputs associated with a specified live input response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/live_inputs/:live_input_identifier/outputs",
		alias: "stream-live-inputs-create-a-new-output,-connected-to-a-live-input",
		description: `Creates a new output that can be used to simulcast or restream live video to other RTMP or SRT destinations. Outputs are always linked to a specific live input — one live input can have many outputs.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ enabled: stream_output_enabled.optional().default(true), streamKey: stream_output_streamKey, url: stream_output_url }).passthrough()
			},
			{
				name: "live_input_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_output_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a new output, connected to a live input response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/stream/live_inputs/:live_input_identifier/outputs/:output_identifier",
		alias: "stream-live-inputs-delete-an-output",
		description: `Deletes an output and removes it from the associated live input.`,
		requestFormat: "json",
		parameters: [
			{
				name: "output_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "live_input_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.void(),
	},
	{
		method: "put",
		path: "/accounts/:account_id/stream/live_inputs/:live_input_identifier/outputs/:output_identifier",
		alias: "stream-live-inputs-update-an-output",
		description: `Updates the state of an output.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ enabled: stream_output_enabled.default(true) }).passthrough()
			},
			{
				name: "output_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "live_input_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_output_response_single,
		errors: [
			{
				status: NaN,
				description: `Update an output response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/storage-usage",
		alias: "stream-videos-storage-usage",
		description: `Returns information about an account&#x27;s storage use.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "creator",
				type: "Query",
				schema: z.string().max(64).optional()
			},
		],
		response: stream_storage_use_response,
		errors: [
			{
				status: NaN,
				description: `Returns information about an account&#x27;s storage use response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/watermarks",
		alias: "stream-watermark-profile-list-watermark-profiles",
		description: `Lists all watermark profiles for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_watermark_response_collection,
		errors: [
			{
				status: NaN,
				description: `List watermark profiles response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/stream/watermarks",
		alias: "stream-watermark-profile-create-watermark-profiles-via-basic-upload",
		description: `Creates watermark profiles using a single &#x60;HTTP POST multipart/form-data&#x60; request.`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: stream_watermark_basic_upload
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_watermark_response_single,
		errors: [
			{
				status: NaN,
				description: `Create watermark profiles via basic upload response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/stream/watermarks/:identifier",
		alias: "stream-watermark-profile-delete-watermark-profiles",
		description: `Deletes a watermark profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_api_response_single.and(z.object({ result: z.string() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete watermark profiles response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/watermarks/:identifier",
		alias: "stream-watermark-profile-watermark-profile-details",
		description: `Retrieves details for a single watermark profile.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_watermark_response_single,
		errors: [
			{
				status: NaN,
				description: `Watermark profile details response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/stream/webhook",
		alias: "stream-webhook-delete-webhooks",
		description: `Deletes a webhook.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete webhooks response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/stream/webhook",
		alias: "stream-webhook-view-webhooks",
		description: `Retrieves a list of webhooks.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_webhook_response_single,
		errors: [
			{
				status: NaN,
				description: `View webhooks response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/stream/webhook",
		alias: "stream-webhook-create-webhooks",
		description: `Creates a webhook notification.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ notificationUrl: stream_notificationUrl.url() }).passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: stream_webhook_response_single,
		errors: [
			{
				status: NaN,
				description: `Create webhooks response failure`,
				schema: stream_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/teamnet/routes",
		alias: "tunnel-route-list-tunnel-routes",
		description: `Lists and filters private network routes in an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "comment",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "is_deleted",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "network_subset",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "network_superset",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "existed_at",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "tunnel_id",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "route_id",
				type: "Query",
				schema: z.string().max(36).optional()
			},
			{
				name: "tun_types",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "virtual_network_id",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
		],
		response: tunnel_teamnet_response_collection,
		errors: [
			{
				status: NaN,
				description: `List tunnel routes response failure`,
				schema: tunnel_teamnet_response_collection.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/teamnet/routes",
		alias: "tunnel-route-create-a-tunnel-route",
		description: `Routes a private network through a Cloudflare Tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: tunnel_route_create_a_tunnel_route_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_route_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a tunnel route response failure`,
				schema: tunnel_route_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/teamnet/routes/:route_id",
		alias: "tunnel-route-delete-a-tunnel-route",
		description: `Deletes a private network route from an account.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "route_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_route_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete a tunnel route response failure`,
				schema: tunnel_route_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/teamnet/routes/:route_id",
		alias: "tunnel-route-update-a-tunnel-route",
		description: `Updates an existing private network route in an account. The fields that are meant to be updated should be provided in the body of the request.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: tunnel_route_update_a_tunnel_route_Body
			},
			{
				name: "route_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_route_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a tunnel route response failure`,
				schema: tunnel_route_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/teamnet/routes/ip/:ip",
		alias: "tunnel-route-get-tunnel-route-by-ip",
		description: `Fetches routes that contain the given IP address.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ip",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "virtual_network_id",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: tunnel_teamnet_response_single,
		errors: [
			{
				status: NaN,
				description: `Get tunnel route by IP response failure`,
				schema: tunnel_teamnet_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/teamnet/virtual_networks",
		alias: "tunnel-virtual-network-list-virtual-networks",
		description: `Lists and filters virtual networks in an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "is_default",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "is_deleted",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "vnet_name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "vnet_id",
				type: "Query",
				schema: z.string().max(36).optional()
			},
		],
		response: tunnel_vnet_response_collection,
		errors: [
			{
				status: NaN,
				description: `List virtual networks response failure`,
				schema: tunnel_vnet_response_collection.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/teamnet/virtual_networks",
		alias: "tunnel-virtual-network-create-a-virtual-network",
		description: `Adds a new virtual network to an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: tunnel_virtual_network_create_a_virtual_network_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_vnet_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a virtual network response failure`,
				schema: tunnel_vnet_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/teamnet/virtual_networks/:virtual_network_id",
		alias: "tunnel-virtual-network-delete-a-virtual-network",
		description: `Deletes an existing virtual network.`,
		requestFormat: "json",
		parameters: [
			{
				name: "virtual_network_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_vnet_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete a virtual network response failure`,
				schema: tunnel_vnet_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/teamnet/virtual_networks/:virtual_network_id",
		alias: "tunnel-virtual-network-update-a-virtual-network",
		description: `Updates an existing virtual network.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: tunnel_virtual_network_update_a_virtual_network_Body
			},
			{
				name: "virtual_network_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_vnet_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a virtual network response failure`,
				schema: tunnel_vnet_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/tunnels",
		alias: "cloudflare-tunnel-list-all-tunnels",
		description: `Lists and filters all types of Tunnels in an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "is_deleted",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "existed_at",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "uuid",
				type: "Query",
				schema: z.string().max(36).optional()
			},
			{
				name: "was_active_at",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "was_inactive_at",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "include_prefix",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "exclude_prefix",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "tun_types",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
		],
		response: tunnel_tunnel_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Tunnels response failure`,
				schema: tunnel_tunnel_response_collection.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/warp_connector",
		alias: "cloudflare-tunnel-list-warp-connector-tunnels",
		description: `Lists and filters Warp Connector Tunnels in an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "is_deleted",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "existed_at",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "uuid",
				type: "Query",
				schema: z.string().max(36).optional()
			},
			{
				name: "was_active_at",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "was_inactive_at",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "include_prefix",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "exclude_prefix",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
		],
		response: tunnel_tunnel_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Warp Connector Tunnels response failure`,
				schema: tunnel_tunnel_response_collection.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/warp_connector",
		alias: "cloudflare-tunnel-create-a-warp-connector-tunnel",
		description: `Creates a new Warp Connector Tunnel in an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudflare_tunnel_create_a_warp_connector_tunnel_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a Warp Connector Tunnel response failure`,
				schema: tunnel_tunnel_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/warp_connector/:tunnel_id",
		alias: "cloudflare-tunnel-delete-a-warp-connector-tunnel",
		description: `Deletes a Warp Connector Tunnel from an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({}).partial().passthrough()
			},
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete a Warp Connector Tunnel response failure`,
				schema: tunnel_tunnel_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/warp_connector/:tunnel_id",
		alias: "cloudflare-tunnel-get-a-warp-connector-tunnel",
		description: `Fetches a single Warp Connector Tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a Warp Connector Tunnel response failure`,
				schema: tunnel_tunnel_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/warp_connector/:tunnel_id",
		alias: "cloudflare-tunnel-update-a-warp-connector-tunnel",
		description: `Updates an existing Warp Connector Tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudflare_tunnel_update_a_cloudflare_tunnel_Body
			},
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a Warp Connector Tunnel response failure`,
				schema: tunnel_tunnel_response_single.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/warp_connector/:tunnel_id/token",
		alias: "cloudflare-tunnel-get-a-warp-connector-tunnel-token",
		description: `Gets the token used to associate warp device with a specific Warp Connector tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_tunnel_response_token,
		errors: [
			{
				status: NaN,
				description: `Get a Warp Connector Tunnel token response failure`,
				schema: tunnel_tunnel_response_token.and(tunnel_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/account-settings",
		alias: "worker-account-settings-fetch-worker-account-settings",
		description: `Fetches Worker account settings for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_account_settings_response,
		errors: [
			{
				status: NaN,
				description: `Fetch Worker Account Settings response failure`,
				schema: workers_account_settings_response.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/account-settings",
		alias: "worker-account-settings-create-worker-account-settings",
		description: `Creates Worker account settings for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_account_settings_response,
		errors: [
			{
				status: NaN,
				description: `Create Worker Account Settings response failure`,
				schema: workers_account_settings_response.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/deployments/by-script/:script_id",
		alias: "worker-deployments-list-deployments",
		requestFormat: "json",
		parameters: [
			{
				name: "script_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_deployments_list_response,
		errors: [
			{
				status: NaN,
				description: `List Deployments response failure`,
				schema: workers_deployments_list_response.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/deployments/by-script/:script_id/detail/:deployment_id",
		alias: "worker-deployments-get-deployment-detail",
		requestFormat: "json",
		parameters: [
			{
				name: "deployment_id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "script_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_deployments_single_response,
		errors: [
			{
				status: NaN,
				description: `Get Deployment Detail response failure`,
				schema: workers_deployments_single_response.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/dispatch/namespaces",
		alias: "namespace-worker-list",
		description: `Fetch a list of Workers for Platforms namespaces.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_namespace_list_response,
		errors: [
			{
				status: NaN,
				description: `Failure to get list of Workers for Platforms namespaces.`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/workers/dispatch/namespaces",
		alias: "namespace-worker-create",
		description: `Create a new Workers for Platforms namespace.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ name: z.string() }).partial().passthrough()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_namespace_single_response,
		errors: [
			{
				status: NaN,
				description: `Failure to get list of Workers for Platforms namespaces.`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/workers/dispatch/namespaces/:dispatch_namespace",
		alias: "namespace-worker-delete-namespace",
		description: `Delete a Workers for Platforms namespace.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dispatch_namespace",
				type: "Path",
				schema: z.string().regex(/^.+$/)
			},
		],
		response: workers_namespace_delete_response,
		errors: [
			{
				status: NaN,
				description: `Failure to delete Workers for Platforms namespace.`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/dispatch/namespaces/:dispatch_namespace",
		alias: "namespace-worker-get-namespace",
		description: `Fetch a Workers for Platforms namespace.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dispatch_namespace",
				type: "Path",
				schema: z.string().regex(/^.+$/)
			},
		],
		response: workers_namespace_single_response,
		errors: [
			{
				status: NaN,
				description: `Failure to get Workers for Platforms namespace.`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/workers/dispatch/namespaces/:dispatch_namespace/scripts/:script_name",
		alias: "namespace-worker-script-delete-worker",
		description: `Delete a worker from a Workers for Platforms namespace. This call has no response body on a successful delete.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dispatch_namespace",
				type: "Path",
				schema: z.string().regex(/^.+$/)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "force",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: z.void(),
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/dispatch/namespaces/:dispatch_namespace/scripts/:script_name",
		alias: "namespace-worker-script-worker-details",
		description: `Fetch information about a script uploaded to a Workers for Platforms namespace.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dispatch_namespace",
				type: "Path",
				schema: z.string().regex(/^.+$/)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
		],
		response: workers_namespace_script_response_single,
		errors: [
			{
				status: NaN,
				description: `Worker Details Failure (Workers for Platforms)`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/dispatch/namespaces/:dispatch_namespace/scripts/:script_name",
		alias: "namespace-worker-script-upload-worker-module",
		description: `Upload a worker module to a Workers for Platforms namespace.`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: namespace_worker_script_upload_worker_module_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dispatch_namespace",
				type: "Path",
				schema: z.string().regex(/^.+$/)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
		],
		response: workers_script_response_single.and(z.unknown()),
		errors: [
			{
				status: NaN,
				description: `Upload Worker Module response failure`,
				schema: z.unknown().and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/dispatch/namespaces/:dispatch_namespace/scripts/:script_name/bindings",
		alias: "namespace-worker-get-script-bindings",
		description: `Fetch script bindings from a script uploaded to a Workers for Platforms namespace.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dispatch_namespace",
				type: "Path",
				schema: z.string().regex(/^.+$/)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
		],
		response: workers_binding,
		errors: [
			{
				status: NaN,
				description: `Fetch script bindings failure (Workers for Platforms)`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/dispatch/namespaces/:dispatch_namespace/scripts/:script_name/content",
		alias: "namespace-worker-get-script-content",
		description: `Fetch script content from a script uploaded to a Workers for Platforms namespace.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dispatch_namespace",
				type: "Path",
				schema: z.string().regex(/^.+$/)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Fetch script content failure (Workers for Platforms)`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/dispatch/namespaces/:dispatch_namespace/scripts/:script_name/content",
		alias: "namespace-worker-put-script-content",
		description: `Put script content for a script uploaded to a Workers for Platforms namespace.`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: namespace_worker_put_script_content_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dispatch_namespace",
				type: "Path",
				schema: z.string().regex(/^.+$/)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "CF-WORKER-BODY-PART",
				type: "Header",
				schema: z.string().optional()
			},
			{
				name: "CF-WORKER-MAIN-MODULE-PART",
				type: "Header",
				schema: z.string().optional()
			},
		],
		response: workers_script_response_single,
		errors: [
			{
				status: NaN,
				description: `Put script content failure (Workers for Platforms)`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/dispatch/namespaces/:dispatch_namespace/scripts/:script_name/settings",
		alias: "namespace-worker-get-script-settings",
		description: `Get script settings from a script uploaded to a Workers for Platforms namespace.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dispatch_namespace",
				type: "Path",
				schema: z.string().regex(/^.+$/)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
		],
		response: workers_script_settings_response,
		errors: [
			{
				status: NaN,
				description: `Fetch script settings failure`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/workers/dispatch/namespaces/:dispatch_namespace/scripts/:script_name/settings",
		alias: "namespace-worker-patch-script-settings",
		description: `Patch script metadata, such as bindings`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_script_settings_response
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dispatch_namespace",
				type: "Path",
				schema: z.string().regex(/^.+$/)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
		],
		response: workers_script_settings_response,
		errors: [
			{
				status: NaN,
				description: `Patch script settings failure`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/domains",
		alias: "worker-domain-list-domains",
		description: `Lists all Worker Domains for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "service",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "zone_id",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "hostname",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "environment",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: workers_domain_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Domains response failure`,
				schema: workers_domain_response_collection.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/domains",
		alias: "worker-domain-attach-to-domain",
		description: `Attaches a Worker to a zone and hostname.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: worker_domain_attach_to_domain_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: workers_domain_response_single,
		errors: [
			{
				status: NaN,
				description: `Attach to Domain response failure`,
				schema: workers_domain_response_single.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/workers/domains/:domain_id",
		alias: "worker-domain-detach-from-domain",
		description: `Detaches a Worker from a zone and hostname.`,
		requestFormat: "json",
		parameters: [
			{
				name: "domain_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: z.void(),
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/domains/:domain_id",
		alias: "worker-domain-get-a-domain",
		description: `Gets a Worker domain.`,
		requestFormat: "json",
		parameters: [
			{
				name: "domain_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: workers_domain_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a Domain response failure`,
				schema: workers_domain_response_single.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/durable_objects/namespaces",
		alias: "durable-objects-namespace-list-namespaces",
		description: `Returns the Durable Object namespaces owned by an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_collection.and(z.object({ result: z.array(workers_namespace) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Namespaces response failure`,
				schema: workers_api_response_collection.and(z.object({ result: z.array(workers_namespace) }).partial().passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/durable_objects/namespaces/:id/objects",
		alias: "durable-objects-namespace-list-objects",
		description: `Returns the Durable Objects in a given namespace.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().gte(10).lte(10000).optional().default(1000)
			},
			{
				name: "cursor",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: workers_api_response_collection.and(z.object({ result: z.array(workers_object), result_info: z.object({ count: z.number(), cursor: workers_cursor }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Objects response failure`,
				schema: workers_api_response_collection.and(z.object({ result: z.array(workers_object), result_info: z.object({ count: z.number(), cursor: workers_cursor }).partial().passthrough() }).partial().passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/queues",
		alias: "queue-list-queues",
		description: `Returns the queues owned by an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_collection.and(z.object({ errors: z.array(z.unknown()).nullable() }).partial().passthrough()).and(z.object({ messages: z.array(z.unknown()).nullable() }).partial().passthrough()).and(z.object({ result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown(), total_pages: z.unknown() }).partial().passthrough() }).partial().passthrough()).and(z.object({ result: z.array(workers_queue).optional() }).passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Queues response failure`,
				schema: workers_api_response_collection.and(z.object({ errors: z.array(z.unknown()).nullable() }).partial().passthrough()).and(z.object({ messages: z.array(z.unknown()).nullable() }).partial().passthrough()).and(z.object({ result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown(), total_pages: z.unknown() }).partial().passthrough() }).partial().passthrough()).and(z.object({ result: z.array(workers_queue).optional() }).passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/workers/queues",
		alias: "queue-create-queue",
		description: `Creates a new queue.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_collection.and(z.object({ result: workers_queue_created.optional() }).passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create Queue response failure`,
				schema: workers_api_response_collection.and(z.object({ result: workers_queue_created.optional() }).passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/workers/queues/:name",
		alias: "queue-delete-queue",
		description: `Deletes a queue.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_collection.and(z.object({ result: z.array(z.unknown()).nullable() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Queue response failure`,
				schema: workers_api_response_collection.and(z.object({ result: z.array(z.unknown()).nullable() }).partial().passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/queues/:name",
		alias: "queue-queue-details",
		description: `Get information about a specific queue.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_collection.and(z.object({ result: workers_queue.optional() }).passthrough()),
		errors: [
			{
				status: NaN,
				description: `Queue Details response failure`,
				schema: workers_api_response_collection.and(z.object({ result: workers_queue.optional() }).passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/queues/:name",
		alias: "queue-update-queue",
		description: `Updates a queue.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_collection.and(z.object({ result: workers_queue_updated.optional() }).passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update Queue response failure`,
				schema: workers_api_response_collection.and(z.object({ result: workers_queue_updated.optional() }).passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/queues/:name/consumers",
		alias: "queue-list-queue-consumers",
		description: `Returns the consumers for a queue.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_collection.and(z.object({ errors: z.array(z.unknown()).nullable() }).partial().passthrough()).and(z.object({ messages: z.array(z.unknown()).nullable() }).partial().passthrough()).and(z.object({ result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown(), total_pages: z.unknown() }).partial().passthrough() }).partial().passthrough()).and(z.object({ result: z.array(workers_consumer).optional() }).passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Queue Consumers response failure`,
				schema: workers_api_response_collection.and(z.object({ errors: z.array(z.unknown()).nullable() }).partial().passthrough()).and(z.object({ messages: z.array(z.unknown()).nullable() }).partial().passthrough()).and(z.object({ result_info: z.object({ count: z.unknown(), page: z.unknown(), per_page: z.unknown(), total_count: z.unknown(), total_pages: z.unknown() }).partial().passthrough() }).partial().passthrough()).and(z.object({ result: z.array(workers_consumer).optional() }).passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/workers/queues/:name/consumers",
		alias: "queue-create-queue-consumer",
		description: `Creates a new consumer for a queue.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_collection.and(z.object({ result: workers_consumer_created.optional() }).passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create Queue Consumer response failure`,
				schema: workers_api_response_collection.and(z.object({ result: workers_consumer_created.optional() }).passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/workers/queues/:name/consumers/:consumer_name",
		alias: "queue-delete-queue-consumer",
		description: `Deletes the consumer for a queue.`,
		requestFormat: "json",
		parameters: [
			{
				name: "consumer_name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_collection.and(z.object({ result: z.array(z.unknown()).nullable() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Queue Consumer response failure`,
				schema: workers_api_response_collection.and(z.object({ result: z.array(z.unknown()).nullable() }).partial().passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/queues/:name/consumers/:consumer_name",
		alias: "queue-update-queue-consumer",
		description: `Updates the consumer for a queue, or creates one if it does not exist.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "consumer_name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_collection.and(z.object({ result: workers_consumer_updated.optional() }).passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update Queue Consumer response failure`,
				schema: workers_api_response_collection.and(z.object({ result: workers_consumer_updated.optional() }).passthrough()).and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/scripts",
		alias: "worker-script-list-workers",
		description: `Fetch a list of uploaded workers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_script_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Workers response failure`,
				schema: workers_script_response_collection.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/workers/scripts/:script_name",
		alias: "worker-script-delete-worker",
		description: `Delete your worker. This call has no response body on a successful delete.`,
		requestFormat: "json",
		parameters: [
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "force",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: z.void(),
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/scripts/:script_name",
		alias: "worker-script-download-worker",
		description: `Fetch raw script content for your worker. Note this is the original script content, not JSON encoded.`,
		requestFormat: "json",
		parameters: [
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Download Worker response failure`,
				schema: z.void()
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/scripts/:script_name",
		alias: "worker-script-upload-worker-module",
		description: `Upload a worker module.`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: namespace_worker_script_upload_worker_module_Body
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "rollback_to",
				type: "Query",
				schema: z.string().max(36).optional()
			},
		],
		response: workers_script_response_single.and(z.unknown()),
		errors: [
			{
				status: NaN,
				description: `Upload Worker Module response failure`,
				schema: z.unknown().and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/scripts/:script_name/content",
		alias: "worker-script-put-content",
		description: `Put script content without touching config or metadata`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: namespace_worker_put_script_content_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "CF-WORKER-BODY-PART",
				type: "Header",
				schema: z.string().optional()
			},
			{
				name: "CF-WORKER-MAIN-MODULE-PART",
				type: "Header",
				schema: z.string().optional()
			},
		],
		response: workers_script_response_single,
		errors: [
			{
				status: NaN,
				description: `Put script content failure`,
				schema: workers_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/scripts/:script_name/content/v2",
		alias: "worker-script-get-content",
		description: `Fetch script content only`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Fetch script content failure`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/scripts/:script_name/schedules",
		alias: "worker-cron-trigger-get-cron-triggers",
		description: `Fetches Cron Triggers for a Worker.`,
		requestFormat: "json",
		parameters: [
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_cron_trigger_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get Cron Triggers response failure`,
				schema: workers_cron_trigger_response_collection.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/scripts/:script_name/schedules",
		alias: "worker-cron-trigger-update-cron-triggers",
		description: `Updates Cron Triggers for a Worker.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_cron_trigger_response_collection,
		errors: [
			{
				status: NaN,
				description: `Update Cron Triggers response failure`,
				schema: workers_cron_trigger_response_collection.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/scripts/:script_name/settings",
		alias: "worker-script-get-settings",
		description: `Get script metadata and config, such as bindings or usage model`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
		],
		response: workers_script_settings_response,
		errors: [
			{
				status: NaN,
				description: `Fetch script settings failure`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/workers/scripts/:script_name/settings",
		alias: "worker-script-patch-settings",
		description: `Patch script metadata or config, such as bindings or usage model`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: worker_script_patch_settings_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
		],
		response: workers_script_settings_response,
		errors: [
			{
				status: NaN,
				description: `Patch script settings failure`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/scripts/:script_name/tails",
		alias: "worker-tail-logs-list-tails",
		description: `Get list of tails currently deployed on a Worker.`,
		requestFormat: "json",
		parameters: [
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_tail_response,
		errors: [
			{
				status: NaN,
				description: `List Tails response failure`,
				schema: workers_tail_response.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_id/workers/scripts/:script_name/tails",
		alias: "worker-tail-logs-start-tail",
		description: `Starts a tail that receives logs and exception from a Worker.`,
		requestFormat: "json",
		parameters: [
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_tail_response,
		errors: [
			{
				status: NaN,
				description: `Start Tail response failure`,
				schema: workers_tail_response.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_id/workers/scripts/:script_name/tails/:id",
		alias: "worker-tail-logs-delete-tail",
		description: `Deletes a tail from a Worker.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_common,
		errors: [
			{
				status: NaN,
				description: `Delete Tail response failure`,
				schema: workers_api_response_common.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/scripts/:script_name/usage-model",
		alias: "worker-script-fetch-usage-model",
		description: `Fetches the Usage Model for a given Worker.`,
		requestFormat: "json",
		parameters: [
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_usage_model_response,
		errors: [
			{
				status: NaN,
				description: `Fetch Usage Model response failure`,
				schema: workers_usage_model_response.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/scripts/:script_name/usage-model",
		alias: "worker-script-update-usage-model",
		description: `Updates the Usage Model for a given Worker. Requires a Workers Paid subscription.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "script_name",
				type: "Path",
				schema: z.string().regex(/^[a-z0-9_][a-z0-9-_]*$/)
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_usage_model_response,
		errors: [
			{
				status: NaN,
				description: `Update Usage Model response failure`,
				schema: workers_usage_model_response.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/services/:service_name/environments/:environment_name/content",
		alias: "worker-environment-get-script-content",
		description: `Get script content from a worker with an environment`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "service_name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "environment_name",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Get script content failure`,
				schema: workers_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/services/:service_name/environments/:environment_name/content",
		alias: "worker-environment-put-script-content",
		description: `Put script content from a worker with an environment`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: namespace_worker_put_script_content_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "service_name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "environment_name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "CF-WORKER-BODY-PART",
				type: "Header",
				schema: z.string().optional()
			},
			{
				name: "CF-WORKER-MAIN-MODULE-PART",
				type: "Header",
				schema: z.string().optional()
			},
		],
		response: workers_script_response_single,
		errors: [
			{
				status: NaN,
				description: `Put script content failure`,
				schema: workers_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/services/:service_name/environments/:environment_name/settings",
		alias: "worker-script-environment-get-settings",
		description: `Get script settings from a worker with an environment`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "service_name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "environment_name",
				type: "Path",
				schema: z.string()
			},
		],
		response: workers_script_settings_response,
		errors: [
			{
				status: NaN,
				description: `Fetch script settings failure`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/workers/services/:service_name/environments/:environment_name/settings",
		alias: "worker-script-environment-patch-settings",
		description: `Patch script metadata, such as bindings`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: workers_script_settings_response
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "service_name",
				type: "Path",
				schema: z.string()
			},
			{
				name: "environment_name",
				type: "Path",
				schema: z.string()
			},
		],
		response: workers_script_settings_response,
		errors: [
			{
				status: NaN,
				description: `Patch script settings failure`,
				schema: workers_api_response_common
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/workers/subdomain",
		alias: "worker-subdomain-get-subdomain",
		description: `Returns a Workers subdomain for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_subdomain_response,
		errors: [
			{
				status: NaN,
				description: `Get Subdomain response failure`,
				schema: workers_subdomain_response.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_id/workers/subdomain",
		alias: "worker-subdomain-create-subdomain",
		description: `Creates a Workers subdomain for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_subdomain_response,
		errors: [
			{
				status: NaN,
				description: `Create Subdomain response failure`,
				schema: workers_subdomain_response.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_id/zerotrust/connectivity_settings",
		alias: "zero-trust-accounts-get-connectivity-settings",
		description: `Gets the Zero Trust Connectivity Settings for the given account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_zero_trust_connectivity_settings_response,
		errors: [
			{
				status: NaN,
				description: `Get Zero Trust Connectivity Settings response failure`,
				schema: tunnel_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_id/zerotrust/connectivity_settings",
		alias: "zero-trust-accounts-patch-connectivity-settings",
		description: `Updates the Zero Trust Connectivity Settings for the given account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zero_trust_accounts_patch_connectivity_settings_Body
			},
			{
				name: "account_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tunnel_zero_trust_connectivity_settings_response,
		errors: [
			{
				status: NaN,
				description: `Update Zero Trust Connectivity Settings response failure`,
				schema: tunnel_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/challenges/widgets",
		alias: "accounts-turnstile-widgets-list",
		description: `Lists all turnstile widgets of an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(1000).optional().default(25)
			},
			{
				name: "order",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: nc_challenges_admin_api_response_common.and(z.object({ result_info: nc_challenges_admin_result_info }).partial().passthrough()).and(z.object({ result: z.array(nc_challenges_admin_widget_list) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Turnstile Widgets Error`,
				schema: nc_challenges_admin_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/challenges/widgets",
		alias: "accounts-turnstile-widget-create",
		description: `Lists challenge widgets.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ bot_fight_mode: nc_challenges_admin_bot_fight_mode.optional(), clearance_level: nc_challenges_admin_clearance_level.optional(), domains: nc_challenges_admin_domains, mode: nc_challenges_admin_mode, name: nc_challenges_admin_name.min(1).max(254), offlabel: nc_challenges_admin_offlabel.optional(), region: nc_challenges_admin_region.optional().default("world") }).passthrough()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(1000).optional().default(25)
			},
			{
				name: "order",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: nc_challenges_admin_api_response_common.and(z.object({ result_info: nc_challenges_admin_result_info }).partial().passthrough()).and(z.object({ result: nc_challenges_admin_widget_detail }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create Turnstile Widget Response Error`,
				schema: nc_challenges_admin_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/challenges/widgets/:sitekey",
		alias: "accounts-turnstile-widget-delete",
		description: `Destroy a Turnstile Widget.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "sitekey",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: nc_challenges_admin_api_response_common.and(z.object({ result: nc_challenges_admin_widget_detail }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Turnstile Widget Response`,
				schema: nc_challenges_admin_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/challenges/widgets/:sitekey",
		alias: "accounts-turnstile-widget-get",
		description: `Show a single challenge widget configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "sitekey",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: nc_challenges_admin_api_response_common.and(z.object({ result: nc_challenges_admin_widget_detail }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Turnstile Widget Details Response Error`,
				schema: nc_challenges_admin_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/challenges/widgets/:sitekey",
		alias: "accounts-turnstile-widget-update",
		description: `Update the configuration of a widget.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ bot_fight_mode: nc_challenges_admin_bot_fight_mode.optional(), clearance_level: nc_challenges_admin_clearance_level.optional(), domains: nc_challenges_admin_domains, mode: nc_challenges_admin_mode, name: nc_challenges_admin_name.min(1).max(254), offlabel: nc_challenges_admin_offlabel.optional() }).passthrough()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "sitekey",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: nc_challenges_admin_api_response_common.and(z.object({ result: nc_challenges_admin_widget_detail }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update Turnstile Widget Response Error`,
				schema: nc_challenges_admin_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/challenges/widgets/:sitekey/rotate_secret",
		alias: "accounts-turnstile-widget-rotate-secret",
		description: `Generate a new secret key for this widget. If &#x60;invalidate_immediately&#x60;
is set to &#x60;false&#x60;, the previous secret remains valid for 2 hours.

Note that secrets cannot be rotated again during the grace period.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ invalidate_immediately: nc_challenges_admin_invalidate_immediately }).partial().passthrough()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "sitekey",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: nc_challenges_admin_api_response_common.and(z.object({ result: nc_challenges_admin_widget_detail }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Rotate Secret Response Error`,
				schema: nc_challenges_admin_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/cloudforce-one/requests",
		alias: "cloudforce-one-request-list",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudforce_one_request_list
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: z.array(cloudforce_one_request_list_item) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/cloudforce-one/requests/:request_identifier",
		alias: "cloudforce-one-request-delete",
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "request_identifier",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: cloudforce_one_api_response_common,
		errors: [
			{
				status: NaN,
				description: `Create response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/cloudforce-one/requests/:request_identifier",
		alias: "cloudforce-one-request-get",
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "request_identifier",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_request_item }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get a request response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/cloudforce-one/requests/:request_identifier",
		alias: "cloudforce-one-request-update",
		description: `Updating a request alters the request in the Cloudforce One queue. This API may be used to update any attributes of the request after the initial submission. Only fields that you choose to update need to be add to the request body`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudforce_one_request_edit
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "request_identifier",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_request_item }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update request response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/cloudforce-one/requests/:request_identifier/message",
		alias: "cloudforce-one-request-message-list",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudforce_one_request_message_list
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "request_identifier",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: z.array(cloudforce_one_request_message_item) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List requests message response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/cloudforce-one/requests/:request_identifier/message/:message_identifer",
		alias: "cloudforce-one-request-message-delete",
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "request_identifier",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "message_identifer",
				type: "Path",
				schema: z.number().int()
			},
		],
		response: cloudforce_one_api_response_common,
		errors: [
			{
				status: NaN,
				description: `Delete request message response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/cloudforce-one/requests/:request_identifier/message/:message_identifer",
		alias: "cloudforce-one-request-message-update",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudforce_one_request_edit
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "request_identifier",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "message_identifer",
				type: "Path",
				schema: z.number().int()
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_request_message_item }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update request message response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/cloudforce-one/requests/:request_identifier/message/new",
		alias: "cloudforce-one-request-message-new",
		description: `Creating a request adds the request into the Cloudforce One queue for analysis. In addition to the content, a short title, type, priority, and releasability should be provided. If one is not provided a default will be assigned.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudforce_one_request_message_edit
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "request_identifier",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_request_message_item }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/cloudforce-one/requests/constants",
		alias: "cloudforce-one-request-constants",
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_request_constants }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get request constants response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/cloudforce-one/requests/new",
		alias: "cloudforce-one-request-new",
		description: `Creating a request adds the request into the Cloudforce One queue for analysis. In addition to the content, a short title, type, priority, and releasability should be provided. If one is not provided a default will be assigned.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudforce_one_request_edit
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_request_item }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/cloudforce-one/requests/priority",
		alias: "cloudforce-one-priority-list",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudforce_one_priority_list
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: z.array(cloudforce_one_priority_item) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List priorities response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/cloudforce-one/requests/priority/:priority_identifer",
		alias: "cloudforce-one-priority-delete",
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "priority_identifer",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: cloudforce_one_api_response_common,
		errors: [
			{
				status: NaN,
				description: `Delete a priority response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/cloudforce-one/requests/priority/:priority_identifer",
		alias: "cloudforce-one-priority-get",
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "priority_identifer",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_request_item }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get a priority response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/cloudforce-one/requests/priority/:priority_identifer",
		alias: "cloudforce-one-priority-update",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudforce_one_priority_edit
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "priority_identifer",
				type: "Path",
				schema: z.string().max(36)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_request_item }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update a priority response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/cloudforce-one/requests/priority/new",
		alias: "cloudforce-one-priority-new",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudforce_one_priority_edit
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_priority_item }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create priority response  failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/cloudforce-one/requests/priority/quota",
		alias: "cloudforce-one-priority-quota",
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_quota }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get priority quota response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/cloudforce-one/requests/quota",
		alias: "cloudforce-one-request-quota",
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_quota }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get request quota response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/cloudforce-one/requests/types",
		alias: "cloudforce-one-request-types",
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cloudforce_one_api_response_common.and(z.object({ result: cloudforce_one_request_types }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get request types response failure`,
				schema: cloudforce_one_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/custom_pages",
		alias: "custom-pages-for-an-account-list-custom-pages",
		description: `Fetches all the custom pages at the account level.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: custom_pages_custom_pages_response_collection,
		errors: [
			{
				status: NaN,
				description: `List custom pages response failure`,
				schema: custom_pages_custom_pages_response_collection.and(custom_pages_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/custom_pages/:identifier",
		alias: "custom-pages-for-an-account-get-a-custom-page",
		description: `Fetches the details of a custom page.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: custom_pages_custom_pages_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a custom page response failure`,
				schema: custom_pages_custom_pages_response_single.and(custom_pages_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/custom_pages/:identifier",
		alias: "custom-pages-for-an-account-update-a-custom-page",
		description: `Updates the configuration of an existing custom page.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ state: custom_pages_state, url: custom_pages_url.url() }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: custom_pages_custom_pages_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a custom page response failure`,
				schema: custom_pages_custom_pages_response_single.and(custom_pages_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/d1/database/:database_identifier",
		alias: "cloudflare-d1-delete-database",
		description: `Deletes the specified D1 database.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "database_identifier",
				type: "Path",
				schema: z.string()
			},
		],
		response: d1_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete D1 database response failure`,
				schema: d1_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(d1_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/d1/database/:database_identifier",
		alias: "cloudflare-d1-get-database",
		description: `Returns the specified D1 database.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "database_identifier",
				type: "Path",
				schema: z.string()
			},
		],
		response: d1_api_response_single.and(z.object({ result: d1_database_details_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Database details response failure`,
				schema: d1_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(d1_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/d1/database/:database_identifier/query",
		alias: "cloudflare-d1-query-database",
		description: `Returns the query result.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cloudflare_d1_query_database_Body
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "database_identifier",
				type: "Path",
				schema: z.string()
			},
		],
		response: d1_api_response_single.and(z.object({ result: z.array(d1_query_result_response) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Query response failure`,
				schema: d1_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(d1_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/dns_firewall/:identifier/dns_analytics/report",
		alias: "dns-firewall-analytics-table",
		description: `Retrieves a list of summarised aggregate metrics over a given time period.

See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "metrics",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "dimensions",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "since",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "until",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional().default(100000)
			},
			{
				name: "sort",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "filters",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: dns_dns_analytics_api_api_response_single.and(z.object({ result: dns_dns_analytics_api_report }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Table response failure`,
				schema: dns_dns_analytics_api_api_response_single.and(z.object({ result: dns_dns_analytics_api_report }).partial().passthrough()).and(dns_dns_analytics_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/dns_firewall/:identifier/dns_analytics/report/bytime",
		alias: "dns-firewall-analytics-by-time",
		description: `Retrieves a list of aggregate metrics grouped by time interval.

See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "metrics",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "dimensions",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "since",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "until",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional().default(100000)
			},
			{
				name: "sort",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "filters",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "time_delta",
				type: "Query",
				schema: z.enum(["all", "auto", "year", "quarter", "month", "week", "day", "hour", "dekaminute", "minute"]).optional()
			},
		],
		response: dns_dns_analytics_api_api_response_single.and(z.object({ result: dns_dns_analytics_api_report_bytime }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `By Time response failure`,
				schema: dns_dns_analytics_api_api_response_single.and(z.object({ result: dns_dns_analytics_api_report_bytime }).partial().passthrough()).and(dns_dns_analytics_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/email/routing/addresses",
		alias: "email-routing-destination-addresses-list-destination-addresses",
		description: `Lists existing destination addresses.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional().default("asc")
			},
			{
				name: "verified",
				type: "Query",
				schema: z.union([z.literal(true), z.literal(false)]).optional().default(true)
			},
		],
		response: email_destination_addresses_response_collection,
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/email/routing/addresses",
		alias: "email-routing-destination-addresses-create-a-destination-address",
		description: `Create a destination address to forward your emails to. Destination addresses need to be verified before they can be used.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: email_create_destination_address_properties
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_destination_address_response_single,
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/email/routing/addresses/:destination_address_identifier",
		alias: "email-routing-destination-addresses-delete-destination-address",
		description: `Deletes a specific destination address.`,
		requestFormat: "json",
		parameters: [
			{
				name: "destination_address_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_destination_address_response_single,
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/email/routing/addresses/:destination_address_identifier",
		alias: "email-routing-destination-addresses-get-a-destination-address",
		description: `Gets information for a specific destination email already created.`,
		requestFormat: "json",
		parameters: [
			{
				name: "destination_address_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_destination_address_response_single,
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/firewall/access_rules/rules",
		alias: "ip-access-rules-for-an-account-list-ip-access-rules",
		description: `Fetches IP Access rules of an account. These rules apply to all the zones in the account. You can filter the results using several optional parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "filters",
				type: "Query",
				schema: filters
			},
			{
				name: "egs-pagination.json",
				type: "Query",
				schema: egs_pagination_json
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["configuration.target", "configuration.value", "mode"]).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
		],
		response: legacy_jhs_response_collection,
		errors: [
			{
				status: NaN,
				description: `List IP Access rules response failure`,
				schema: legacy_jhs_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/firewall/access_rules/rules",
		alias: "ip-access-rules-for-an-account-create-an-ip-access-rule",
		description: `Creates a new IP Access rule for an account. The rule will apply to all zones in the account.

Note: To create an IP Access rule that applies to a single zone, refer to the [IP Access rules for a zone](#ip-access-rules-for-a-zone) endpoints.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ configuration: legacy_jhs_schemas_configuration, mode: legacy_jhs_schemas_mode, notes: legacy_jhs_notes.optional() }).passthrough()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: legacy_jhs_response_single,
		errors: [
			{
				status: NaN,
				description: `Create an IP Access rule response failure`,
				schema: legacy_jhs_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/firewall/access_rules/rules/:identifier",
		alias: "ip-access-rules-for-an-account-delete-an-ip-access-rule",
		description: `Deletes an existing IP Access rule defined at the account level.

Note: This operation will affect all zones in the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: legacy_jhs_api_response_single_id,
		errors: [
			{
				status: NaN,
				description: `Delete an IP Access rule response failure`,
				schema: legacy_jhs_api_response_single_id.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/firewall/access_rules/rules/:identifier",
		alias: "ip-access-rules-for-an-account-get-an-ip-access-rule",
		description: `Fetches the details of an IP Access rule defined at the account level.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: legacy_jhs_response_single,
		errors: [
			{
				status: NaN,
				description: `Get an IP Access rule response failure`,
				schema: legacy_jhs_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_identifier/firewall/access_rules/rules/:identifier",
		alias: "ip-access-rules-for-an-account-update-an-ip-access-rule",
		description: `Updates an IP Access rule defined at the account level.

Note: This operation will affect all zones in the account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: legacy_jhs_schemas_rule
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: legacy_jhs_response_single,
		errors: [
			{
				status: NaN,
				description: `Update an IP Access rule response failure`,
				schema: legacy_jhs_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/cf_interconnects",
		alias: "magic-interconnects-list-interconnects",
		description: `Lists interconnects associated with an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_components_schemas_tunnels_collection_response,
		errors: [
			{
				status: NaN,
				description: `List interconnects response failure`,
				schema: magic_components_schemas_tunnels_collection_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/cf_interconnects",
		alias: "magic-interconnects-update-multiple-interconnects",
		description: `Updates multiple interconnects associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_components_schemas_modified_tunnels_collection_response,
		errors: [
			{
				status: NaN,
				description: `Update multiple interconnects response failure`,
				schema: magic_components_schemas_modified_tunnels_collection_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/cf_interconnects/:tunnel_identifier",
		alias: "magic-interconnects-list-interconnect-details",
		description: `Lists details for a specific interconnect.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_components_schemas_tunnel_single_response,
		errors: [
			{
				status: NaN,
				description: `List interconnect Details response failure`,
				schema: magic_components_schemas_tunnel_single_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/cf_interconnects/:tunnel_identifier",
		alias: "magic-interconnects-update-interconnect",
		description: `Updates a specific interconnect associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_components_schemas_tunnel_update_request
			},
			{
				name: "tunnel_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_components_schemas_tunnel_modified_response,
		errors: [
			{
				status: NaN,
				description: `Update interconnect response failure`,
				schema: magic_components_schemas_tunnel_modified_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/gre_tunnels",
		alias: "magic-gre-tunnels-list-gre-tunnels",
		description: `Lists GRE tunnels associated with an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_tunnels_collection_response,
		errors: [
			{
				status: NaN,
				description: `List GRE tunnels response failure`,
				schema: magic_tunnels_collection_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/magic/gre_tunnels",
		alias: "magic-gre-tunnels-create-gre-tunnels",
		description: `Creates new GRE tunnels. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_tunnels_collection_response,
		errors: [
			{
				status: NaN,
				description: `Create GRE tunnels response failure`,
				schema: magic_tunnels_collection_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/gre_tunnels",
		alias: "magic-gre-tunnels-update-multiple-gre-tunnels",
		description: `Updates multiple GRE tunnels. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_modified_tunnels_collection_response,
		errors: [
			{
				status: NaN,
				description: `Update multiple GRE tunnels response failure`,
				schema: magic_modified_tunnels_collection_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/magic/gre_tunnels/:tunnel_identifier",
		alias: "magic-gre-tunnels-delete-gre-tunnel",
		description: `Disables and removes a specific static GRE tunnel. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_tunnel_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete GRE Tunnel response failure`,
				schema: magic_tunnel_deleted_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/gre_tunnels/:tunnel_identifier",
		alias: "magic-gre-tunnels-list-gre-tunnel-details",
		description: `Lists informtion for a specific GRE tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_tunnel_single_response,
		errors: [
			{
				status: NaN,
				description: `List GRE Tunnel Details response failure`,
				schema: magic_tunnel_single_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/gre_tunnels/:tunnel_identifier",
		alias: "magic-gre-tunnels-update-gre-tunnel",
		description: `Updates a specific GRE tunnel. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_tunnel_update_request
			},
			{
				name: "tunnel_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_tunnel_modified_response,
		errors: [
			{
				status: NaN,
				description: `Update GRE Tunnel response failure`,
				schema: magic_tunnel_modified_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/ipsec_tunnels",
		alias: "magic-ipsec-tunnels-list-ipsec-tunnels",
		description: `Lists IPsec tunnels associated with an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_schemas_tunnels_collection_response,
		errors: [
			{
				status: NaN,
				description: `List IPsec tunnels response failure`,
				schema: magic_schemas_tunnels_collection_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/magic/ipsec_tunnels",
		alias: "magic-ipsec-tunnels-create-ipsec-tunnels",
		description: `Creates new IPsec tunnels associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_schemas_tunnel_add_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_schemas_tunnels_collection_response,
		errors: [
			{
				status: NaN,
				description: `Create IPsec tunnels response failure`,
				schema: magic_schemas_tunnels_collection_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/ipsec_tunnels",
		alias: "magic-ipsec-tunnels-update-multiple-ipsec-tunnels",
		description: `Update multiple IPsec tunnels associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_schemas_modified_tunnels_collection_response,
		errors: [
			{
				status: NaN,
				description: `Update multiple IPsec tunnels response failure`,
				schema: magic_schemas_modified_tunnels_collection_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/magic/ipsec_tunnels/:tunnel_identifier",
		alias: "magic-ipsec-tunnels-delete-ipsec-tunnel",
		description: `Disables and removes a specific static IPsec Tunnel associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_schemas_tunnel_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete IPsec Tunnel response failure`,
				schema: magic_schemas_tunnel_deleted_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/ipsec_tunnels/:tunnel_identifier",
		alias: "magic-ipsec-tunnels-list-ipsec-tunnel-details",
		description: `Lists details for a specific IPsec tunnel.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_schemas_tunnel_single_response,
		errors: [
			{
				status: NaN,
				description: `List IPsec tunnel details response failure`,
				schema: magic_schemas_tunnel_single_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/ipsec_tunnels/:tunnel_identifier",
		alias: "magic-ipsec-tunnels-update-ipsec-tunnel",
		description: `Updates a specific IPsec tunnel associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_schemas_tunnel_update_request
			},
			{
				name: "tunnel_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_schemas_tunnel_modified_response,
		errors: [
			{
				status: NaN,
				description: `Update IPsec Tunnel response failure`,
				schema: magic_schemas_tunnel_modified_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/magic/ipsec_tunnels/:tunnel_identifier/psk_generate",
		alias: "magic-ipsec-tunnels-generate-pre-shared-key-(-psk)-for-ipsec-tunnels",
		description: `Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare&#x27;s edge and cannot be retrieved later. Note the PSK in a safe place.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tunnel_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_psk_generation_response,
		errors: [
			{
				status: NaN,
				description: `Generate Pre Shared Key (PSK) for IPsec tunnels response failure`,
				schema: magic_psk_generation_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/magic/routes",
		alias: "magic-static-routes-delete-many-routes",
		description: `Delete multiple Magic static routes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_route_delete_many_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_multiple_route_delete_response,
		errors: [
			{
				status: NaN,
				description: `Delete Many Routes response failure`,
				schema: magic_multiple_route_delete_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/routes",
		alias: "magic-static-routes-list-routes",
		description: `List all Magic static routes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_routes_collection_response,
		errors: [
			{
				status: NaN,
				description: `List Routes response failure`,
				schema: magic_routes_collection_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/magic/routes",
		alias: "magic-static-routes-create-routes",
		description: `Creates a new Magic static route. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to run validation only without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_routes_collection_response,
		errors: [
			{
				status: NaN,
				description: `Create Routes response failure`,
				schema: magic_routes_collection_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/routes",
		alias: "magic-static-routes-update-many-routes",
		description: `Update multiple Magic static routes. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to run validation only without persisting changes. Only fields for a route that need to be changed need be provided.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_route_update_many_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_multiple_route_modified_response,
		errors: [
			{
				status: NaN,
				description: `Update Many Routes response failure`,
				schema: magic_multiple_route_modified_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/magic/routes/:route_identifier",
		alias: "magic-static-routes-delete-route",
		description: `Disable and remove a specific Magic static route.`,
		requestFormat: "json",
		parameters: [
			{
				name: "route_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_route_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete Route response failure`,
				schema: magic_route_deleted_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/routes/:route_identifier",
		alias: "magic-static-routes-route-details",
		description: `Get a specific Magic static route.`,
		requestFormat: "json",
		parameters: [
			{
				name: "route_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_route_single_response,
		errors: [
			{
				status: NaN,
				description: `Route Details response failure`,
				schema: magic_route_single_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/routes/:route_identifier",
		alias: "magic-static-routes-update-route",
		description: `Update a specific Magic static route. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to run validation only without persisting changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_route_update_request
			},
			{
				name: "route_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_route_modified_response,
		errors: [
			{
				status: NaN,
				description: `Update Route response failure`,
				schema: magic_route_modified_response.and(magic_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/sites",
		alias: "magic-wan-sites-list-sites",
		description: `Lists Sites associated with an account. Use connector_identifier query param to return sites where connector_identifier matches either site.ConnectorID or site.SecondaryConnectorID.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "connector_identifier",
				type: "Query",
				schema: z.string().max(32).optional()
			},
		],
		response: magic_sites_collection_response,
		errors: [
			{
				status: NaN,
				description: `List Sites response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/magic/sites",
		alias: "magic-sites-create-site",
		description: `Creates a new Site`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_sites_add_single_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_site_single_response,
		errors: [
			{
				status: NaN,
				description: `Create Site response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier",
		alias: "magic-sites-delete-site",
		description: `Remove a specific Site.`,
		requestFormat: "json",
		parameters: [
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_site_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete Site response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier",
		alias: "magic-sites-site-details",
		description: `Get a specific Site.`,
		requestFormat: "json",
		parameters: [
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_site_single_response,
		errors: [
			{
				status: NaN,
				description: `Site Details response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier",
		alias: "magic-sites-update-site",
		description: `Update a specific Site.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_site_update_request
			},
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_site_modified_response,
		errors: [
			{
				status: NaN,
				description: `Update Site response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/acls",
		alias: "magic-site-acls-list-acls",
		description: `Lists Site ACLs associated with an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_acls_collection_response,
		errors: [
			{
				status: NaN,
				description: `List Site ACLs response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/acls",
		alias: "magic-site-acls-create-site-acl",
		description: `Creates a new Site ACL.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_acls_add_single_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_acls_collection_response,
		errors: [
			{
				status: NaN,
				description: `Create Site ACL response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/acls/:acl_identifier",
		alias: "magic-site-acls-delete-acl",
		description: `Remove a specific Site ACL.`,
		requestFormat: "json",
		parameters: [
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "acl_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_acl_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete Site ACL response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/acls/:acl_identifier",
		alias: "magic-site-acls-acl-details",
		description: `Get a specific Site ACL.`,
		requestFormat: "json",
		parameters: [
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "acl_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_acl_single_response,
		errors: [
			{
				status: NaN,
				description: `Site ACL Details response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/acls/:acl_identifier",
		alias: "magic-site-acls-update-acl",
		description: `Update a specific Site ACL.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_acl_update_request
			},
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "acl_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_acl_modified_response,
		errors: [
			{
				status: NaN,
				description: `Update Site ACL response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/lans",
		alias: "magic-wan-connectors-lans-list-lans",
		description: `Lists LANs associated with an account and site.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_lans_collection_response,
		errors: [
			{
				status: NaN,
				description: `List LANs response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/lans",
		alias: "magic-wan-connectors-lans-create-lan",
		description: `Creates a new LAN. If the site is in high availability mode, static_addressing is required along with secondary and virtual address.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_lans_add_single_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_lans_collection_response,
		errors: [
			{
				status: NaN,
				description: `Create LAN response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/lans/:lan_identifier",
		alias: "magic-wan-connectors-lans-delete-lan",
		description: `Remove a specific LAN.`,
		requestFormat: "json",
		parameters: [
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "lan_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_lan_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete LAN response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/lans/:lan_identifier",
		alias: "magic-wan-connectors-lans-lan-details",
		description: `Get a specific LAN.`,
		requestFormat: "json",
		parameters: [
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "lan_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_lan_single_response,
		errors: [
			{
				status: NaN,
				description: `LAN Details response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/lans/:lan_identifier",
		alias: "magic-wan-connectors-lans-update-lan",
		description: `Update a specific LAN.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_lan_update_request
			},
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "lan_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_lan_modified_response,
		errors: [
			{
				status: NaN,
				description: `Update LAN response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/wans",
		alias: "magic-wan-connectors-list-wans",
		description: `Lists WANs associated with an account and site.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_wans_collection_response,
		errors: [
			{
				status: NaN,
				description: `List WANs response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/wans",
		alias: "magic-wan-connectors-create-wan",
		description: `Creates a new WAN.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_wans_add_single_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_wans_collection_response,
		errors: [
			{
				status: NaN,
				description: `Create WAN response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/wans/:wan_identifier",
		alias: "magic-wan-connectors-delete-wan",
		description: `Remove a specific WAN.`,
		requestFormat: "json",
		parameters: [
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "wan_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_wan_deleted_response,
		errors: [
			{
				status: NaN,
				description: `Delete WAN response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/wans/:wan_identifier",
		alias: "magic-wan-connectors-wan-details",
		description: `Get a specific WAN.`,
		requestFormat: "json",
		parameters: [
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "wan_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_wan_single_response,
		errors: [
			{
				status: NaN,
				description: `WAN Details response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/magic/sites/:site_identifier/wans/:wan_identifier",
		alias: "magic-wan-connectors-update-wan",
		description: `Update a specific WAN.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: magic_wan_update_request
			},
			{
				name: "site_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "wan_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: magic_wan_modified_response,
		errors: [
			{
				status: NaN,
				description: `Update WAN response failure`,
				schema: magic_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/mnm/config",
		alias: "magic-network-monitoring-configuration-delete-account-configuration",
		description: `Delete an existing network monitoring configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_config_single_response,
		errors: [
			{
				status: NaN,
				description: `Delete account configuration response failure`,
				schema: magic_visibility_mnm_config_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/mnm/config",
		alias: "magic-network-monitoring-configuration-list-account-configuration",
		description: `Lists default sampling and router IPs for account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_config_single_response,
		errors: [
			{
				status: NaN,
				description: `List account configuration response failure`,
				schema: magic_visibility_mnm_config_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_identifier/mnm/config",
		alias: "magic-network-monitoring-configuration-update-account-configuration-fields",
		description: `Update fields in an existing network monitoring configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_config_single_response,
		errors: [
			{
				status: NaN,
				description: `Update account configuration fields response failure`,
				schema: magic_visibility_mnm_config_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/mnm/config",
		alias: "magic-network-monitoring-configuration-create-account-configuration",
		description: `Create a new network monitoring configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_config_single_response,
		errors: [
			{
				status: NaN,
				description: `Create account configuration response failure`,
				schema: magic_visibility_mnm_config_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/mnm/config",
		alias: "magic-network-monitoring-configuration-update-an-entire-account-configuration",
		description: `Update an existing network monitoring configuration, requires the entire configuration to be updated at once.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_config_single_response,
		errors: [
			{
				status: NaN,
				description: `Update an entire account configuration response failure`,
				schema: magic_visibility_mnm_config_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/mnm/config/full",
		alias: "magic-network-monitoring-configuration-list-rules-and-account-configuration",
		description: `Lists default sampling, router IPs, and rules for account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_config_single_response,
		errors: [
			{
				status: NaN,
				description: `List rules and account configuration response failure`,
				schema: magic_visibility_mnm_config_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/mnm/rules",
		alias: "magic-network-monitoring-rules-list-rules",
		description: `Lists network monitoring rules for account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_rules_collection_response,
		errors: [
			{
				status: NaN,
				description: `List rules response failure`,
				schema: magic_visibility_mnm_rules_collection_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/mnm/rules",
		alias: "magic-network-monitoring-rules-create-rules",
		description: `Create network monitoring rules for account. Currently only supports creating a single rule per API request.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_rules_single_response,
		errors: [
			{
				status: NaN,
				description: `Create rules response failure`,
				schema: magic_visibility_mnm_rules_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/mnm/rules",
		alias: "magic-network-monitoring-rules-update-rules",
		description: `Update network monitoring rules for account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_rules_single_response,
		errors: [
			{
				status: NaN,
				description: `Update rules response failure`,
				schema: magic_visibility_mnm_rules_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/mnm/rules/:rule_identifier",
		alias: "magic-network-monitoring-rules-delete-rule",
		description: `Delete a network monitoring rule for account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_identifier",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_rules_single_response,
		errors: [
			{
				status: NaN,
				description: `Delete rule response failure`,
				schema: magic_visibility_mnm_rules_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/mnm/rules/:rule_identifier",
		alias: "magic-network-monitoring-rules-get-rule",
		description: `List a single network monitoring rule for account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_identifier",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_rules_single_response,
		errors: [
			{
				status: NaN,
				description: `Get rule response failure`,
				schema: magic_visibility_mnm_rules_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_identifier/mnm/rules/:rule_identifier",
		alias: "magic-network-monitoring-rules-update-rule",
		description: `Update a network monitoring rule for account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_identifier",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_rules_single_response,
		errors: [
			{
				status: NaN,
				description: `Update rule response failure`,
				schema: magic_visibility_mnm_rules_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:account_identifier/mnm/rules/:rule_identifier/advertisement",
		alias: "magic-network-monitoring-rules-update-advertisement-for-rule",
		description: `Update advertisement for rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_identifier",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: magic_visibility_mnm_rule_advertisement_single_response,
		errors: [
			{
				status: NaN,
				description: `Update advertisement for rule response failure`,
				schema: magic_visibility_mnm_rule_advertisement_single_response.and(magic_visibility_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/request-tracer/trace",
		alias: "account-request-tracer-request-trace",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_request_tracer_request_trace_Body
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: request_tracer_api_response_common.and(z.object({ result: z.object({ status_code: z.number().int(), trace: request_tracer_trace }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Request Trace response failure`,
				schema: request_tracer_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/rules/lists/:list_id/items/:item_id",
		alias: "lists-get-a-list-item",
		description: `Fetches a list item in the list.`,
		requestFormat: "json",
		parameters: [
			{
				name: "item_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "list_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: lists_item_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get a list item response failure`,
				schema: lists_item_response_collection.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/rules/lists/bulk_operations/:operation_id",
		alias: "lists-get-bulk-operation-status",
		description: `Gets the current status of an asynchronous operation on a list.

The &#x60;status&#x60; property can have one of the following values: &#x60;pending&#x60;, &#x60;running&#x60;, &#x60;completed&#x60;, or &#x60;failed&#x60;. If the status is &#x60;failed&#x60;, the &#x60;error&#x60; property will contain a message describing the error.`,
		requestFormat: "json",
		parameters: [
			{
				name: "operation_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: lists_bulk_operation_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get bulk operation status response failure`,
				schema: lists_bulk_operation_response_collection.and(lists_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/subscriptions",
		alias: "account-subscriptions-list-subscriptions",
		description: `Lists all of an account&#x27;s subscriptions.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_account_subscription_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Subscriptions response failure`,
				schema: bill_subs_api_account_subscription_response_collection.and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/subscriptions",
		alias: "account-subscriptions-create-subscription",
		description: `Creates an account subscription.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: bill_subs_api_subscription_v2
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_account_subscription_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Subscription response failure`,
				schema: bill_subs_api_account_subscription_response_single.and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/subscriptions/:subscription_identifier",
		alias: "account-subscriptions-delete-subscription",
		description: `Deletes an account&#x27;s subscription.`,
		requestFormat: "json",
		parameters: [
			{
				name: "subscription_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_api_response_single.and(z.object({ result: z.object({ subscription_id: bill_subs_api_schemas_identifier.max(32) }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Subscription response failure`,
				schema: bill_subs_api_api_response_single.and(z.object({ result: z.object({ subscription_id: bill_subs_api_schemas_identifier.max(32) }).partial().passthrough() }).partial().passthrough()).and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/subscriptions/:subscription_identifier",
		alias: "account-subscriptions-update-subscription",
		description: `Updates an account subscription.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: bill_subs_api_subscription_v2
			},
			{
				name: "subscription_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_account_subscription_response_single,
		errors: [
			{
				status: NaN,
				description: `Update Subscription response failure`,
				schema: bill_subs_api_account_subscription_response_single.and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/vectorize/indexes",
		alias: "vectorize-list-vectorize-indexes",
		description: `Returns a list of Vectorize Indexes`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: vectorize_api_response_common.and(z.object({ result: z.array(vectorize_create_index_response) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Vectorize Index Failure Response`,
				schema: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(vectorize_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/vectorize/indexes",
		alias: "vectorize-create-vectorize-index",
		description: `Creates and returns a new Vectorize Index.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: vectorize_create_index_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: vectorize_api_response_single.and(z.object({ result: vectorize_create_index_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create Vectorize Index Failure Response`,
				schema: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(vectorize_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:account_identifier/vectorize/indexes/:index_name",
		alias: "vectorize-delete-vectorize-index",
		description: `Deletes the specified Vectorize Index.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "index_name",
				type: "Path",
				schema: z.string().regex(/^([a-z]+[a-z0-9_-]*[a-z0-9]+)$/)
			},
		],
		response: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Vectorize Index Failure`,
				schema: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(vectorize_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:account_identifier/vectorize/indexes/:index_name",
		alias: "vectorize-get-vectorize-index",
		description: `Returns the specified Vectorize Index.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "index_name",
				type: "Path",
				schema: z.string().regex(/^([a-z]+[a-z0-9_-]*[a-z0-9]+)$/)
			},
		],
		response: vectorize_api_response_single.and(z.object({ result: vectorize_create_index_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Vectorize Index Failure`,
				schema: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(vectorize_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:account_identifier/vectorize/indexes/:index_name",
		alias: "vectorize-update-vectorize-index",
		description: `Updates and returns the specified Vectorize Index.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: vectorize_update_index_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "index_name",
				type: "Path",
				schema: z.string().regex(/^([a-z]+[a-z0-9_-]*[a-z0-9]+)$/)
			},
		],
		response: vectorize_api_response_single.and(z.object({ result: vectorize_create_index_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update Vectorize Index Failure Response`,
				schema: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(vectorize_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/vectorize/indexes/:index_name/delete-by-ids",
		alias: "vectorize-delete-vectors-by-id",
		description: `Delete a set of vectors from an index by their vector identifiers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: vectorize_index_delete_vectors_by_id_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "index_name",
				type: "Path",
				schema: z.string().regex(/^([a-z]+[a-z0-9_-]*[a-z0-9]+)$/)
			},
		],
		response: vectorize_api_response_single.and(z.object({ result: vectorize_index_delete_vectors_by_id_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Vector Identifiers Failure Response`,
				schema: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(vectorize_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/vectorize/indexes/:index_name/get-by-ids",
		alias: "vectorize-get-vectors-by-id",
		description: `Get a set of vectors from an index by their vector identifiers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: vectorize_index_get_vectors_by_id_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "index_name",
				type: "Path",
				schema: z.string().regex(/^([a-z]+[a-z0-9_-]*[a-z0-9]+)$/)
			},
		],
		response: vectorize_api_response_single.and(z.object({ result: vectorize_index_get_vectors_by_id_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Vectors By Identifier Failure Response`,
				schema: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(vectorize_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/vectorize/indexes/:index_name/insert",
		alias: "vectorize-insert-vector",
		description: `Inserts vectors into the specified index and returns the count of the vectors successfully inserted.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.instanceof(File)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "index_name",
				type: "Path",
				schema: z.string().regex(/^([a-z]+[a-z0-9_-]*[a-z0-9]+)$/)
			},
		],
		response: vectorize_api_response_single.and(z.object({ result: vectorize_index_insert_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Insert Vectors Failure Response`,
				schema: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(vectorize_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/vectorize/indexes/:index_name/query",
		alias: "vectorize-query-vector",
		description: `Finds vectors closest to a given vector in an index.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: vectorize_index_query_request
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "index_name",
				type: "Path",
				schema: z.string().regex(/^([a-z]+[a-z0-9_-]*[a-z0-9]+)$/)
			},
		],
		response: vectorize_api_response_single.and(z.object({ result: vectorize_index_query_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Query Vectors Failure Response`,
				schema: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(vectorize_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:account_identifier/vectorize/indexes/:index_name/upsert",
		alias: "vectorize-upsert-vector",
		description: `Upserts vectors into the specified index, creating them if they do not exist and returns the count of values and ids successfully inserted.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.instanceof(File)
			},
			{
				name: "account_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "index_name",
				type: "Path",
				schema: z.string().regex(/^([a-z]+[a-z0-9_-]*[a-z0-9]+)$/)
			},
		],
		response: vectorize_api_response_single.and(z.object({ result: vectorize_index_upsert_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Insert Vectors Failure Response`,
				schema: vectorize_api_response_single.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(vectorize_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:accountId/urlscanner/scan",
		alias: "urlscanner-search-scans",
		description: `Search scans by date and webpages&#x27; requests, including full URL (after redirects), hostname, and path. &lt;br/&gt; A successful scan will appear in search results a few minutes after finishing but may take much longer if the system in under load. By default, only successfully completed scans will appear in search results, unless searching by &#x60;scanId&#x60;. Please take into account that older scans may be removed from the search index at an unspecified time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "accountId",
				type: "Path",
				schema: z.string()
			},
			{
				name: "scanId",
				type: "Query",
				schema: z.string().uuid().optional()
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "next_cursor",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "date_start",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "date_end",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "url",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "hostname",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "path",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "ip",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page_url",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page_hostname",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page_path",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page_ip",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "account_scans",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({ tasks: z.array(z.object({ country: z.string(), success: z.boolean(), time: z.string().datetime({ offset: true }), url: z.string(), uuid: z.string().uuid(), visibility: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Invalid params.`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:accountId/urlscanner/scan",
		alias: "urlscanner-create-scan",
		description: `Submit a URL to scan. You can also set some options, like the visibility level and custom headers. Accounts are limited to 1 new scan every 10 seconds and 8000 per month. If you need more, please reach out.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: urlscanner_create_scan_Body
			},
			{
				name: "accountId",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({ time: z.string().datetime({ offset: true }), url: z.string(), uuid: z.string().uuid(), visibility: z.string() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Invalid params.`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), success: z.boolean() }).passthrough()
			},
			{
				status: 409,
				description: `Scan request denied: hostname was recently scanned.`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({ tasks: z.array(z.object({ clientLocation: z.string(), clientType: z.enum(["Site", "Automatic", "Api"]), effectiveUrl: z.string(), errors: z.array(z.object({ message: z.string() }).passthrough()), scannedFrom: z.object({ colo: z.string() }).passthrough(), status: z.enum(["Queued", "InProgress", "InPostProcessing", "Finished"]), success: z.boolean(), time: z.string(), timeEnd: z.string(), url: z.string(), uuid: z.string(), visibility: z.enum(["Public", "Unlisted"]) }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough()
			},
			{
				status: 429,
				description: `Scan request denied: rate limited.`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:accountId/urlscanner/scan/:scanId",
		alias: "urlscanner-get-scan",
		description: `Get URL scan by uuid`,
		requestFormat: "json",
		parameters: [
			{
				name: "scanId",
				type: "Path",
				schema: z.string().uuid()
			},
			{
				name: "accountId",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({ scan: z.object({ asns: z.object({ asn: z.object({ asn: z.string(), description: z.string(), location_alpha2: z.string(), name: z.string(), org_name: z.string() }).passthrough() }).partial().passthrough().optional(), certificates: z.array(z.object({ issuer: z.string(), subjectName: z.string(), validFrom: z.number(), validTo: z.number() }).passthrough()), domains: z.object({ "example.com": z.object({ categories: z.object({ content: z.array(z.object({ id: z.number().int(), name: z.string(), super_category_id: z.number().int().optional() }).passthrough()).optional(), inherited: z.object({ content: z.array(z.object({ id: z.number().int(), name: z.string(), super_category_id: z.number().int().optional() }).passthrough()), from: z.string(), risks: z.array(z.object({ id: z.number().int(), name: z.string(), super_category_id: z.number().int().optional() }).passthrough()) }).partial().passthrough(), risks: z.array(z.object({ id: z.number().int(), name: z.string(), super_category_id: z.number().int().optional() }).passthrough()).optional() }).passthrough(), dns: z.array(z.object({ address: z.string(), dnssec_valid: z.boolean(), name: z.string(), type: z.string() }).passthrough()), name: z.string(), rank: z.object({ bucket: z.string(), name: z.string(), rank: z.number().int().optional() }).passthrough(), type: z.string() }).passthrough() }).partial().passthrough().optional(), geo: z.object({ continents: z.array(z.string()), locations: z.array(z.string()) }).passthrough(), ips: z.object({ ip: z.object({ asn: z.string(), asnDescription: z.string(), asnLocationAlpha2: z.string(), asnName: z.string(), asnOrgName: z.string(), continent: z.string(), geonameId: z.string(), ip: z.string(), ipVersion: z.string(), latitude: z.string(), locationAlpha2: z.string(), locationName: z.string(), longitude: z.string(), subdivision1Name: z.string(), subdivision2Name: z.string() }).passthrough() }).partial().passthrough().optional(), links: z.object({ link: z.object({ href: z.string(), text: z.string() }).passthrough() }).partial().passthrough().optional(), meta: z.object({ processors: z.object({ categories: z.object({ content: z.array(z.object({ id: z.number().int(), name: z.string(), super_category_id: z.number().int().optional() }).passthrough()), risks: z.array(z.object({ id: z.number().int(), name: z.string(), super_category_id: z.number().int() }).passthrough()) }).passthrough(), phishing: z.array(z.string()), rank: z.object({ bucket: z.string(), name: z.string(), rank: z.number().int().optional() }).passthrough(), tech: z.array(z.object({ categories: z.array(z.object({ groups: z.array(z.number()), id: z.number().int(), name: z.string(), priority: z.number().int(), slug: z.string() }).passthrough()), confidence: z.number().int(), description: z.string().optional(), evidence: z.object({ impliedBy: z.array(z.string()), patterns: z.array(z.object({ confidence: z.number().int(), excludes: z.array(z.string()), implies: z.array(z.string()), match: z.string(), name: z.string(), regex: z.string(), type: z.string(), value: z.string(), version: z.string() }).passthrough()) }).passthrough(), icon: z.string(), name: z.string(), slug: z.string(), website: z.string() }).passthrough()) }).passthrough() }).passthrough(), page: z.object({ asn: z.string(), asnLocationAlpha2: z.string(), asnname: z.string(), console: z.array(z.object({ category: z.string(), text: z.string(), type: z.string(), url: z.string().optional() }).passthrough()), cookies: z.array(z.object({ domain: z.string(), expires: z.number(), httpOnly: z.boolean(), name: z.string(), path: z.string(), priority: z.string().optional(), sameParty: z.boolean(), secure: z.boolean(), session: z.boolean(), size: z.number(), sourcePort: z.number(), sourceScheme: z.string(), value: z.string() }).passthrough()), country: z.string(), countryLocationAlpha2: z.string(), domain: z.string(), headers: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()), ip: z.string(), js: z.object({ variables: z.array(z.object({ name: z.string(), type: z.string() }).passthrough()) }).passthrough(), securityViolations: z.array(z.object({ category: z.string(), text: z.string(), url: z.string() }).passthrough()), status: z.number(), subdivision1Name: z.string(), subdivision2name: z.string(), url: z.string() }).passthrough(), performance: z.array(z.object({ connectEnd: z.number(), connectStart: z.number(), decodedBodySize: z.number(), domComplete: z.number(), domContentLoadedEventEnd: z.number(), domContentLoadedEventStart: z.number(), domInteractive: z.number(), domainLookupEnd: z.number(), domainLookupStart: z.number(), duration: z.number(), encodedBodySize: z.number(), entryType: z.string(), fetchStart: z.number(), initiatorType: z.string(), loadEventEnd: z.number(), loadEventStart: z.number(), name: z.string(), nextHopProtocol: z.string(), redirectCount: z.number(), redirectEnd: z.number(), redirectStart: z.number(), requestStart: z.number(), responseEnd: z.number(), responseStart: z.number(), secureConnectionStart: z.number(), startTime: z.number(), transferSize: z.number(), type: z.string(), unloadEventEnd: z.number(), unloadEventStart: z.number(), workerStart: z.number() }).passthrough()), task: z.object({ clientLocation: z.string(), clientType: z.enum(["Site", "Automatic", "Api"]), effectiveUrl: z.string(), errors: z.array(z.object({ message: z.string() }).passthrough()), scannedFrom: z.object({ colo: z.string() }).passthrough(), status: z.enum(["Queued", "InProgress", "InPostProcessing", "Finished"]), success: z.boolean(), time: z.string(), timeEnd: z.string(), url: z.string(), uuid: z.string(), visibility: z.enum(["Public", "Unlisted"]) }).passthrough(), verdicts: z.object({ overall: z.object({ categories: z.array(z.object({ id: z.number(), name: z.string(), super_category_id: z.number() }).passthrough()), malicious: z.boolean(), phishing: z.array(z.string()) }).passthrough() }).passthrough() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Invalid params.`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), success: z.boolean() }).passthrough()
			},
			{
				status: 404,
				description: `Scan not found.`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:accountId/urlscanner/scan/:scanId/har",
		alias: "urlscanner-get-scan-har",
		description: `Get a URL scan&#x27;s HAR file. See HAR spec at http://www.softwareishard.com/blog/har-12-spec/.`,
		requestFormat: "json",
		parameters: [
			{
				name: "scanId",
				type: "Path",
				schema: z.string().uuid()
			},
			{
				name: "accountId",
				type: "Path",
				schema: z.string()
			},
		],
		response: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({ har: z.object({ log: z.object({ creator: z.object({ comment: z.string(), name: z.string(), version: z.string() }).passthrough(), entries: z.array(z.object({ "_initialPriority": z.string(), "_initiator_type": z.string(), "_priority": z.string(), "_requestId": z.string(), "_requestTime": z.number(), "_resourceType": z.string(), cache: z.object({}).partial().passthrough(), connection: z.string(), pageref: z.string(), request: z.object({ bodySize: z.number(), headers: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()), headersSize: z.number(), httpVersion: z.string(), method: z.string(), url: z.string() }).passthrough(), response: z.object({ "_transferSize": z.number(), bodySize: z.number(), content: z.object({ compression: z.number().int().optional(), mimeType: z.string(), size: z.number() }).passthrough(), headers: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()), headersSize: z.number(), httpVersion: z.string(), redirectURL: z.string(), status: z.number(), statusText: z.string() }).passthrough(), serverIPAddress: z.string(), startedDateTime: z.string(), time: z.number() }).passthrough()), pages: z.array(z.object({ id: z.string(), pageTimings: z.object({ onContentLoad: z.number(), onLoad: z.number() }).passthrough(), startedDateTime: z.string(), title: z.string() }).passthrough()), version: z.string() }).passthrough() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Invalid params.`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), success: z.boolean() }).passthrough()
			},
			{
				status: 404,
				description: `Scan not found.`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:accountId/urlscanner/scan/:scanId/screenshot",
		alias: "urlscanner-get-scan-screenshot",
		description: `Get scan&#x27;s screenshot by resolution (desktop/mobile/tablet).`,
		requestFormat: "json",
		parameters: [
			{
				name: "scanId",
				type: "Path",
				schema: z.string().uuid()
			},
			{
				name: "accountId",
				type: "Path",
				schema: z.string()
			},
			{
				name: "resolution",
				type: "Query",
				schema: z.enum(["desktop", "mobile", "tablet"]).optional().default("desktop")
			},
		],
		response: z.void(),
		errors: [
			{
				status: 400,
				description: `Invalid params.`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), success: z.boolean() }).passthrough()
			},
			{
				status: 404,
				description: `Scan not found.`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), messages: z.array(z.object({ message: z.string() }).passthrough()), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/apps",
		alias: "access-applications-list-access-applications",
		description: `Lists all Access applications in an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_apps_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Access applications response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/apps",
		alias: "access-applications-add-an-application",
		description: `Adds a new application to Access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_apps
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_apps_components_schemas_single_response.and(z.object({ result: access_apps }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Add a Bookmark application response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:identifier/access/apps/:app_id",
		alias: "access-applications-delete-an-access-application",
		description: `Deletes an application from Access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: app_id
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an Access application response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/apps/:app_id",
		alias: "access-applications-get-an-access-application",
		description: `Fetches information about an Access application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: app_id
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_apps_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get an Access application response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/apps/:app_id",
		alias: "access-applications-update-a-bookmark-application",
		description: `Updates an Access application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_apps
			},
			{
				name: "app_id",
				type: "Path",
				schema: app_id
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_apps_components_schemas_single_response.and(z.object({ result: access_apps }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update an Access application response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/apps/:app_id/revoke_tokens",
		alias: "access-applications-revoke-service-tokens",
		description: `Revokes all tokens issued for an application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: app_id
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ result: z.object({}).partial().passthrough().nullable(), success: z.union([z.literal(true), z.literal(false)]) }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Revoke application tokens response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/apps/:app_id/user_policy_checks",
		alias: "access-applications-test-access-policies",
		description: `Tests if a specific user has permission to access an application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: app_id
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_policy_check_response,
		errors: [
			{
				status: NaN,
				description: `Test Access policies response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:identifier/access/apps/:uuid/ca",
		alias: "access-short-lived-certificate-c-as-delete-a-short-lived-certificate-ca",
		description: `Deletes a short-lived certificate CA.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete a short-lived certificate CA response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/apps/:uuid/ca",
		alias: "access-short-lived-certificate-c-as-get-a-short-lived-certificate-ca",
		description: `Fetches a short-lived certificate CA and its public key.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_ca_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get a short-lived certificate CA response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/apps/:uuid/ca",
		alias: "access-short-lived-certificate-c-as-create-a-short-lived-certificate-ca",
		description: `Generates a new short-lived certificate CA and public key.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_ca_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create a short-lived certificate CA response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/apps/:uuid/policies",
		alias: "access-policies-list-access-policies",
		description: `Lists Access policies configured for an application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_policies_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Access policies response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/apps/:uuid/policies",
		alias: "access-policies-create-an-access-policy",
		description: `Create a new Access policy for an application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ approval_groups: access_approval_groups.optional(), approval_required: access_approval_required.optional(), decision: access_decision, exclude: access_schemas_exclude.optional(), include: access_include, isolation_required: access_isolation_required.optional(), name: access_policies_components_schemas_name, precedence: access_precedence.int().optional(), purpose_justification_prompt: access_purpose_justification_prompt.optional(), purpose_justification_required: access_purpose_justification_required.optional(), require: access_schemas_require.optional(), session_duration: access_components_schemas_session_duration.optional().default("24h") }).passthrough()
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_policies_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create an Access policy response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:identifier/access/apps/:uuid1/policies/:uuid",
		alias: "access-policies-delete-an-access-policy",
		description: `Delete an Access policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "uuid1",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an Access policy response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/apps/:uuid1/policies/:uuid",
		alias: "access-policies-get-an-access-policy",
		description: `Fetches a single Access policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "uuid1",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_policies_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get an Access policy response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/apps/:uuid1/policies/:uuid",
		alias: "access-policies-update-an-access-policy",
		description: `Update a configured Access policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ approval_groups: access_approval_groups.optional(), approval_required: access_approval_required.optional(), decision: access_decision, exclude: access_schemas_exclude.optional(), include: access_include, isolation_required: access_isolation_required.optional(), name: access_policies_components_schemas_name, precedence: access_precedence.int().optional(), purpose_justification_prompt: access_purpose_justification_prompt.optional(), purpose_justification_required: access_purpose_justification_required.optional(), require: access_schemas_require.optional(), session_duration: access_components_schemas_session_duration.optional().default("24h") }).passthrough()
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "uuid1",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_policies_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update an Access policy response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/apps/ca",
		alias: "access-short-lived-certificate-c-as-list-short-lived-certificate-c-as",
		description: `Lists short-lived certificate CAs and their public keys.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_ca_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List short-lived certificate CAs response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/certificates",
		alias: "access-mtls-authentication-list-mtls-certificates",
		description: `Lists all mTLS root certificates.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_certificates_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List mTLS certificates response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/certificates",
		alias: "access-mtls-authentication-add-an-mtls-certificate",
		description: `Adds a new mTLS root certificate to Access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ associated_hostnames: access_associated_hostnames.optional(), certificate: z.string(), name: access_certificates_components_schemas_name }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_certificates_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Add an mTLS certificate response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:identifier/access/certificates/:uuid",
		alias: "access-mtls-authentication-delete-an-mtls-certificate",
		description: `Deletes an mTLS certificate.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_components_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an mTLS certificate response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/certificates/:uuid",
		alias: "access-mtls-authentication-get-an-mtls-certificate",
		description: `Fetches a single mTLS certificate.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_certificates_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get an mTLS certificate response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/certificates/:uuid",
		alias: "access-mtls-authentication-update-an-mtls-certificate",
		description: `Updates a configured mTLS certificate.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ associated_hostnames: access_associated_hostnames, name: access_certificates_components_schemas_name.optional() }).passthrough()
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_certificates_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update an mTLS certificate response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/certificates/settings",
		alias: "access-mtls-authentication-list-mtls-certificates-hostname-settings",
		description: `List all mTLS hostname settings for this account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_response_collection_hostnames,
		errors: [
			{
				status: NaN,
				description: `List mTLS hostname settings response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/certificates/settings",
		alias: "access-mtls-authentication-update-an-mtls-certificate-settings",
		description: `Updates an mTLS certificate&#x27;s hostname settings.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_mtls_authentication_update_an_mtls_certificate_settings_Body
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_response_collection_hostnames,
		errors: [
			{
				status: NaN,
				description: `Update an mTLS certificates hostname settings failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/custom_pages",
		alias: "access-custom-pages-list-custom-pages",
		description: `List custom pages`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_custom_pages_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List custom pages response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/custom_pages",
		alias: "access-custom-pages-create-a-custom-page",
		description: `Create a custom page`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_custom_page
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_single_response_without_html,
		errors: [
			{
				status: NaN,
				description: `Create a custom page response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:identifier/access/custom_pages/:uuid",
		alias: "access-custom-pages-delete-a-custom-page",
		description: `Delete a custom page`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_components_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete a custom page response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/custom_pages/:uuid",
		alias: "access-custom-pages-get-a-custom-page",
		description: `Fetches a custom page and also returns its HTML.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_custom_pages_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get a custom page response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/custom_pages/:uuid",
		alias: "access-custom-pages-update-a-custom-page",
		description: `Update a custom page`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_custom_page
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_single_response_without_html,
		errors: [
			{
				status: NaN,
				description: `Update a custom page response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/groups",
		alias: "access-groups-list-access-groups",
		description: `Lists all Access groups.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Access groups response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/groups",
		alias: "access-groups-create-an-access-group",
		description: `Creates a new Access group.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ exclude: access_exclude.optional(), include: access_include, is_default: access_is_default.optional(), name: access_components_schemas_name, require: access_require.optional() }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create an Access group response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:identifier/access/groups/:uuid",
		alias: "access-groups-delete-an-access-group",
		description: `Deletes an Access group.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an Access group response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/groups/:uuid",
		alias: "access-groups-get-an-access-group",
		description: `Fetches a single Access group.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get an Access group response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/groups/:uuid",
		alias: "access-groups-update-an-access-group",
		description: `Updates a configured Access group.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ exclude: access_exclude.optional(), include: access_include, is_default: access_is_default.optional(), name: access_components_schemas_name, require: access_require.optional() }).passthrough()
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update an Access group response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/identity_providers",
		alias: "access-identity-providers-list-access-identity-providers",
		description: `Lists all configured identity providers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Access identity providers response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/identity_providers",
		alias: "access-identity-providers-add-an-access-identity-provider",
		description: `Adds a new identity provider to Access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_identity_providers
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Add an Access identity provider response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:identifier/access/identity_providers/:uuid",
		alias: "access-identity-providers-delete-an-access-identity-provider",
		description: `Deletes an identity provider from Access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an Access identity provider response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/identity_providers/:uuid",
		alias: "access-identity-providers-get-an-access-identity-provider",
		description: `Fetches a configured identity provider.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get an Access identity provider response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/identity_providers/:uuid",
		alias: "access-identity-providers-update-an-access-identity-provider",
		description: `Updates a configured identity provider.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_identity_providers
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update an Access identity provider response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/keys",
		alias: "access-key-configuration-get-the-access-key-configuration",
		description: `Gets the Access key rotation settings for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_keys_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get the Access key configuration response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/keys",
		alias: "access-key-configuration-update-the-access-key-configuration",
		description: `Updates the Access key rotation settings for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ key_rotation_interval_days: access_key_rotation_interval_days.gte(21).lte(365) }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_keys_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update the Access key configuration response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/keys/rotate",
		alias: "access-key-configuration-rotate-access-keys",
		description: `Perfoms a key rotation for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_keys_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Rotate Access keys response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/logs/access_requests",
		alias: "access-authentication-logs-get-access-authentication-logs",
		description: `Gets a list of Access authentication audit logs for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_access_requests_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get Access authentication logs response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/organizations",
		alias: "zero-trust-organization-get-your-zero-trust-organization",
		description: `Returns the configuration for your Zero Trust organization.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_single_response,
		errors: [
			{
				status: NaN,
				description: `Get your Zero Trust organization response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/organizations",
		alias: "zero-trust-organization-create-your-zero-trust-organization",
		description: `Sets up a Zero Trust organization for your account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ allow_authenticate_via_warp: access_allow_authenticate_via_warp.optional(), auth_domain: access_auth_domain, auto_redirect_to_identity: access_auto_redirect_to_identity.optional(), is_ui_read_only: access_is_ui_read_only.optional(), login_design: access_login_design.optional(), name: access_name, session_duration: access_session_duration.optional(), ui_read_only_toggle_reason: access_ui_read_only_toggle_reason.optional(), user_seat_expiration_inactive_time: access_user_seat_expiration_inactive_time.optional(), warp_auth_session_duration: access_warp_auth_session_duration.optional() }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_single_response,
		errors: [
			{
				status: NaN,
				description: `Create your Zero Trust organization response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/organizations",
		alias: "zero-trust-organization-update-your-zero-trust-organization",
		description: `Updates the configuration for your Zero Trust organization.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ allow_authenticate_via_warp: access_allow_authenticate_via_warp, auth_domain: access_auth_domain, auto_redirect_to_identity: access_auto_redirect_to_identity, custom_pages: access_custom_pages, is_ui_read_only: access_is_ui_read_only, login_design: access_login_design, name: access_name, session_duration: access_session_duration, ui_read_only_toggle_reason: access_ui_read_only_toggle_reason, user_seat_expiration_inactive_time: access_user_seat_expiration_inactive_time, warp_auth_session_duration: access_warp_auth_session_duration }).partial().passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_single_response,
		errors: [
			{
				status: NaN,
				description: `Update your Zero Trust organization response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/organizations/revoke_user",
		alias: "zero-trust-organization-revoke-all-access-tokens-for-a-user",
		description: `Revokes a user&#x27;s access across all applications.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ email: z.string() }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ result: z.union([z.literal(true), z.literal(false)]), success: z.union([z.literal(true), z.literal(false)]) }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Revoke all Access tokens for a user response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/accounts/:identifier/access/seats",
		alias: "zero-trust-seats-update-a-user-seat",
		description: `Removes a user from a Zero Trust seat when both &#x60;access_seat&#x60; and &#x60;gateway_seat&#x60; are set to false.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(access_seat)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_seats_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `Update a user seat response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/service_tokens",
		alias: "access-service-tokens-list-service-tokens",
		description: `Lists all service tokens.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List service tokens response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/service_tokens",
		alias: "access-service-tokens-create-a-service-token",
		description: `Generates a new service token. **Note:** This is the only time you can get the Client Secret. If you lose the Client Secret, you will have to rotate the Client Secret or create a new service token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ duration: access_duration.optional(), name: access_service_tokens_components_schemas_name }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_create_response,
		errors: [
			{
				status: NaN,
				description: `Create a service token response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:identifier/access/service_tokens/:uuid",
		alias: "access-service-tokens-delete-a-service-token",
		description: `Deletes a service token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_service_tokens_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Delete a service token response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/service_tokens/:uuid",
		alias: "access-service-tokens-update-a-service-token",
		description: `Updates a configured service token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ duration: access_duration, name: access_service_tokens_components_schemas_name }).partial().passthrough()
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_service_tokens_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update a service token response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/service_tokens/:uuid/refresh",
		alias: "access-service-tokens-refresh-a-service-token",
		description: `Refreshes the expiration of a service token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_service_tokens_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Refresh a service token response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/service_tokens/:uuid/rotate",
		alias: "access-service-tokens-rotate-a-service-token",
		description: `Generates a new Client Secret for a service token and revokes the old one.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_create_response,
		errors: [
			{
				status: NaN,
				description: `Rotate a service token response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/tags",
		alias: "access-tags-list-tags",
		description: `List tags`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_tags_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List tags response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/accounts/:identifier/access/tags",
		alias: "access-tags-create-tag",
		description: `Create a tag`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_tag_without_app_count
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_tags_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create a tag response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/accounts/:identifier/access/tags/:name",
		alias: "access-tags-delete-a-tag",
		description: `Delete a tag`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "name",
				type: "Path",
				schema: z.string()
			},
		],
		response: access_name_response,
		errors: [
			{
				status: NaN,
				description: `Delete a tag response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/tags/:name",
		alias: "access-tags-get-a-tag",
		description: `Get a tag`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "name",
				type: "Path",
				schema: z.string()
			},
		],
		response: access_tags_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get a tag response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/accounts/:identifier/access/tags/:name",
		alias: "access-tags-update-a-tag",
		description: `Update a tag`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_tag_without_app_count
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "name",
				type: "Path",
				schema: z.string()
			},
		],
		response: access_tags_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update a tag response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/users",
		alias: "zero-trust-users-get-users",
		description: `Gets a list of users for an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_users_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get users response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/users/:id/active_sessions",
		alias: "zero-trust-users-get-active-sessions",
		description: `Get active sessions for a single user.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_active_sessions_response,
		errors: [
			{
				status: NaN,
				description: `Get active sessions response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/users/:id/active_sessions/:nonce",
		alias: "zero-trust-users-get-active-session",
		description: `Get an active session for a single user.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "nonce",
				type: "Path",
				schema: z.string()
			},
		],
		response: access_active_session_response,
		errors: [
			{
				status: NaN,
				description: `Get active session response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/users/:id/failed_logins",
		alias: "zero-trust-users-get-failed-logins",
		description: `Get all failed login attempts for a single user.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_failed_login_response,
		errors: [
			{
				status: NaN,
				description: `Get failed logins response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/accounts/:identifier/access/users/:id/last_seen_identity",
		alias: "zero-trust-users-get-last-seen-identity",
		description: `Get last seen identity for a single user.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_last_seen_identity_response,
		errors: [
			{
				status: NaN,
				description: `Get active session response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/certificates",
		alias: "origin-ca-list-certificates",
		description: `List all existing Origin CA certificates for a given zone. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests)).`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Query",
				schema: z.string().max(32).optional()
			},
		],
		response: tls_certificates_and_hostnames_schemas_certificate_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Certificates response failure`,
				schema: tls_certificates_and_hostnames_schemas_certificate_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/certificates",
		alias: "origin-ca-create-certificate",
		description: `Create an Origin CA certificate. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests)).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: origin_ca_create_certificate_Body
			},
		],
		response: tls_certificates_and_hostnames_schemas_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Certificate response failure`,
				schema: tls_certificates_and_hostnames_schemas_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/certificates/:certificate_id",
		alias: "origin-ca-revoke-certificate",
		description: `Revoke an existing Origin CA certificate by its serial number. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests)).`,
		requestFormat: "json",
		parameters: [
			{
				name: "certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_single_id,
		errors: [
			{
				status: NaN,
				description: `Revoke Certificate response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_single_id.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/certificates/:certificate_id",
		alias: "origin-ca-get-certificate",
		description: `Get an existing Origin CA certificate by its serial number. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests)).`,
		requestFormat: "json",
		parameters: [
			{
				name: "certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_schemas_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Certificate response failure`,
				schema: tls_certificates_and_hostnames_schemas_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/ips",
		alias: "cloudflare-i-ps-cloudflare-ip-details",
		description: `Get IPs used on the Cloudflare/JD Cloud network, see https://www.cloudflare.com/ips for Cloudflare IPs or https://developers.cloudflare.com/china-network/reference/infrastructure/ for JD Cloud IPs.`,
		requestFormat: "json",
		parameters: [
			{
				name: "networks",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: addressing_api_response_single.and(z.object({ result: z.union([addressing_ips, addressing_ips_jdcloud]) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Cloudflare IP Details response failure`,
				schema: addressing_api_response_single.and(z.object({ result: z.union([addressing_ips, addressing_ips_jdcloud]) }).partial().passthrough()).and(addressing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/memberships",
		alias: "user&#x27;-s-account-memberships-list-memberships",
		description: `List memberships of accounts the user can access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "account.name",
				type: "Query",
				schema: z.string().max(100).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["id", "account.name", "status"]).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.string().max(100).optional()
			},
			{
				name: "status",
				type: "Query",
				schema: z.enum(["accepted", "pending", "rejected"]).optional()
			},
		],
		response: iam_collection_membership_response,
		errors: [
			{
				status: NaN,
				description: `List Memberships response failure`,
				schema: iam_collection_membership_response.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/memberships/:membership_id",
		alias: "user&#x27;-s-account-memberships-delete-membership",
		description: `Remove the associated member from an account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "membership_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: iam_api_response_single.and(z.object({ result: z.object({ id: iam_membership_components_schemas_identifier.max(32) }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Membership response failure`,
				schema: iam_api_response_single.and(z.object({ result: z.object({ id: iam_membership_components_schemas_identifier.max(32) }).partial().passthrough() }).partial().passthrough()).and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/memberships/:membership_id",
		alias: "user&#x27;-s-account-memberships-membership-details",
		description: `Get a specific membership.`,
		requestFormat: "json",
		parameters: [
			{
				name: "membership_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: iam_single_membership_response,
		errors: [
			{
				status: NaN,
				description: `Membership Details response failure`,
				schema: iam_single_membership_response.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/memberships/:membership_id",
		alias: "user&#x27;-s-account-memberships-update-membership",
		description: `Accept or reject this account invitation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ status: z.unknown() }).passthrough()
			},
			{
				name: "membership_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: iam_single_membership_response,
		errors: [
			{
				status: NaN,
				description: `Update Membership response failure`,
				schema: iam_single_membership_response.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/radar/annotations/outages",
		alias: "radar-get-annotations-outages",
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "offset",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"]).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ annotations: z.array(z.object({ asns: z.array(z.number()), asnsDetails: z.array(z.object({ asn: z.string(), locations: z.object({ code: z.string(), name: z.string() }).passthrough().optional(), name: z.string() }).passthrough()), dataSource: z.string(), description: z.string().optional(), endDate: z.string().optional(), eventType: z.string(), id: z.string(), linkedUrl: z.string().optional(), locations: z.array(z.string()), locationsDetails: z.array(z.object({ code: z.string(), name: z.string() }).passthrough()), outage: z.object({ outageCause: z.string(), outageType: z.string() }).passthrough(), scope: z.string().optional(), startDate: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/annotations/outages/locations",
		alias: "radar-get-annotations-outages-top",
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"]).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ annotations: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/summary/dnssec",
		alias: "radar-get-dns-as112-timeseries-by-dnssec",
		description: `Percentage distribution of DNS queries to AS112 by DNSSEC support.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ NOT_SUPPORTED: z.string(), SUPPORTED: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/summary/edns",
		alias: "radar-get-dns-as112-timeseries-by-edns",
		description: `Percentage distribution of DNS queries, to AS112, by EDNS support.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ NOT_SUPPORTED: z.string(), SUPPORTED: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/summary/ip_version",
		alias: "radar-get-dns-as112-timeseries-by-ip-version",
		description: `Percentage distribution of DNS queries to AS112 per IP Version.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ IPv4: z.string(), IPv6: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/summary/protocol",
		alias: "radar-get-dns-as112-timeseries-by-protocol",
		description: `Percentage distribution of DNS queries to AS112 per protocol.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ tcp: z.string(), udp: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/summary/query_type",
		alias: "radar-get-dns-as112-timeseries-by-query-type",
		description: `Percentage distribution of DNS queries to AS112 by Query Type.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ A: z.string(), AAAA: z.string(), PTR: z.string(), SOA: z.string(), SRV: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/summary/response_codes",
		alias: "radar-get-dns-as112-timeseries-by-response-codes",
		description: `Percentage distribution of AS112 dns requests classified per Response Codes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ NOERROR: z.string(), NXDOMAIN: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/timeseries",
		alias: "radar-get-dns-as112-timeseries",
		description: `Get AS112 queries change over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ aggInterval: z.string(), confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string().datetime({ offset: true }) }).passthrough(), serie_0: z.object({ timestamps: z.array(z.string()), values: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/timeseries_groups/dnssec",
		alias: "radar-get-dns-as112-timeseries-group-by-dnssec",
		description: `Percentage distribution of DNS AS112 queries by DNSSEC support over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ NOT_SUPPORTED: z.array(z.string()), SUPPORTED: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/timeseries_groups/edns",
		alias: "radar-get-dns-as112-timeseries-group-by-edns",
		description: `Percentage distribution of AS112 DNS queries by EDNS support over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ NOT_SUPPORTED: z.array(z.string()), SUPPORTED: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/timeseries_groups/ip_version",
		alias: "radar-get-dns-as112-timeseries-group-by-ip-version",
		description: `Percentage distribution of AS112 DNS queries by IP Version over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ IPv4: z.array(z.string()), IPv6: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/timeseries_groups/protocol",
		alias: "radar-get-dns-as112-timeseries-group-by-protocol",
		description: `Percentage distribution of AS112 dns requests classified per Protocol over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ tcp: z.array(z.string()), udp: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/timeseries_groups/query_type",
		alias: "radar-get-dns-as112-timeseries-group-by-query-type",
		description: `Percentage distribution of AS112 DNS queries by Query Type over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ A: z.array(z.string()), AAAA: z.array(z.string()), PTR: z.array(z.string()), SOA: z.array(z.string()), SRV: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/timeseries_groups/response_codes",
		alias: "radar-get-dns-as112-timeseries-group-by-response-codes",
		description: `Percentage distribution of AS112 dns requests classified per Response Codes over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ NOERROR: z.array(z.string()), NXDOMAIN: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/top/locations",
		alias: "radar-get-dns-as112-top-locations",
		description: `Get the top locations by AS112 DNS queries. Values are a percentage out of the total queries.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/top/locations/dnssec/:dnssec",
		alias: "radar-get-dns-as112-top-locations-by-dnssec",
		description: `Get the top locations by DNS queries DNSSEC support to AS112.`,
		requestFormat: "json",
		parameters: [
			{
				name: "dnssec",
				type: "Path",
				schema: z.enum(["SUPPORTED", "NOT_SUPPORTED"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/top/locations/edns/:edns",
		alias: "radar-get-dns-as112-top-locations-by-edns",
		description: `Get the top locations, by DNS queries EDNS support to AS112.`,
		requestFormat: "json",
		parameters: [
			{
				name: "edns",
				type: "Path",
				schema: z.enum(["SUPPORTED", "NOT_SUPPORTED"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/as112/top/locations/ip_version/:ip_version",
		alias: "radar-get-dns-as112-top-locations-by-ip-version",
		description: `Get the top locations by DNS queries IP version to AS112.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ip_version",
				type: "Path",
				schema: z.enum(["IPv4", "IPv6"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/summary/bitrate",
		alias: "radar-get-attacks-layer3-summary-by-bitrate",
		description: `Percentage distribution of attacks by bitrate.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ OVER_100_GBPS: z.string(), UNDER_500_MBPS: z.string(), "_10_GBPS_TO_100_GBPS": z.string(), "_1_GBPS_TO_10_GBPS": z.string(), "_500_MBPS_TO_1_GBPS": z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/summary/duration",
		alias: "radar-get-attacks-layer3-summary-by-duration",
		description: `Percentage distribution of attacks by duration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ OVER_3_HOURS: z.string(), UNDER_10_MINS: z.string(), "_10_MINS_TO_20_MINS": z.string(), "_1_HOUR_TO_3_HOURS": z.string(), "_20_MINS_TO_40_MINS": z.string(), "_40_MINS_TO_1_HOUR": z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/summary/ip_version",
		alias: "radar-get-attacks-layer3-summary-by-ip-version",
		description: `Percentage distribution of attacks by ip version used.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ IPv4: z.string(), IPv6: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/summary/protocol",
		alias: "radar-get-attacks-layer3-summary-by-protocol",
		description: `Percentage distribution of attacks by protocol used.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ GRE: z.string(), ICMP: z.string(), TCP: z.string(), UDP: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/summary/vector",
		alias: "radar-get-attacks-layer3-summary-by-vector",
		description: `Percentage distribution of attacks by vector.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.record(z.array(z.string())) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/timeseries",
		alias: "radar-get-attacks-layer3-timeseries-by-bytes",
		description: `Get attacks change over time by bytes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE_CHANGE", "MIN0_MAX"]).optional()
			},
			{
				name: "metric",
				type: "Query",
				schema: z.enum(["BYTES", "BYTES_OLD"]).optional().default("bytes")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ timestamps: z.array(z.string()), values: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/timeseries_groups/bitrate",
		alias: "radar-get-attacks-layer3-timeseries-group-by-bitrate",
		description: `Percentage distribution of attacks by bitrate over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ OVER_100_GBPS: z.array(z.string()), UNDER_500_MBPS: z.array(z.string()), "_10_GBPS_TO_100_GBPS": z.array(z.string()), "_1_GBPS_TO_10_GBPS": z.array(z.string()), "_500_MBPS_TO_1_GBPS": z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/timeseries_groups/duration",
		alias: "radar-get-attacks-layer3-timeseries-group-by-duration",
		description: `Percentage distribution of attacks by duration over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ OVER_3_HOURS: z.array(z.string()), UNDER_10_MINS: z.array(z.string()), "_10_MINS_TO_20_MINS": z.array(z.string()), "_1_HOUR_TO_3_HOURS": z.array(z.string()), "_20_MINS_TO_40_MINS": z.array(z.string()), "_40_MINS_TO_1_HOUR": z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/timeseries_groups/industry",
		alias: "radar-get-attacks-layer3-timeseries-group-by-industry",
		description: `Percentage distribution of attacks by industry used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "limitPerGroup",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.record(z.array(z.string())) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/timeseries_groups/ip_version",
		alias: "radar-get-attacks-layer3-timeseries-group-by-ip-version",
		description: `Percentage distribution of attacks by ip version used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ IPv4: z.array(z.string()), IPv6: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/timeseries_groups/protocol",
		alias: "radar-get-attacks-layer3-timeseries-group-by-protocol",
		description: `Percentage distribution of attacks by protocol used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ GRE: z.array(z.string()), ICMP: z.array(z.string()), TCP: z.array(z.string()), UDP: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/timeseries_groups/vector",
		alias: "radar-get-attacks-layer3-timeseries-group-by-vector",
		description: `Percentage distribution of attacks by vector used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "limitPerGroup",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.record(z.array(z.string())) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/timeseries_groups/vertical",
		alias: "radar-get-attacks-layer3-timeseries-group-by-vertical",
		description: `Percentage distribution of attacks by vertical used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "limitPerGroup",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.record(z.array(z.string())) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/top/attacks",
		alias: "radar-get-attacks-layer3-top-attacks",
		description: `Get the top attacks from origin to target location. Values are a percentage out of the total layer 3 attacks (with billing country). You can optionally limit the number of attacks per origin/target location (useful if all the top attacks are from or to the same location).`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "limitDirection",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "limitPerLocation",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ originCountryAlpha2: z.string(), originCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/top/industry",
		alias: "radar-get-attacks-layer3-top-industries",
		description: `Get the Industry of attacks.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/top/locations/origin",
		alias: "radar-get-attacks-layer3-top-origin-locations",
		description: `Get the origin locations of attacks.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ originCountryAlpha2: z.string(), originCountryName: z.string(), rank: z.number(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/top/locations/target",
		alias: "radar-get-attacks-layer3-top-target-locations",
		description: `Get the target locations of attacks.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ rank: z.number(), targetCountryAlpha2: z.string(), targetCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer3/top/vertical",
		alias: "radar-get-attacks-layer3-top-verticals",
		description: `Get the Verticals of attacks.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "protocol",
				type: "Query",
				schema: z.array(z.enum(["UDP", "TCP", "ICMP", "GRE"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/summary/http_method",
		alias: "radar-get-attacks-layer7-summary-by-http-method",
		description: `Percentage distribution of attacks by http method used.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "mitigationProduct",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ GET: z.string(), POST: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/summary/http_version",
		alias: "radar-get-attacks-layer7-summary-by-http-version",
		description: `Percentage distribution of attacks by http version used.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "httpMethod",
				type: "Query",
				schema: z.array(z.enum(["GET", "POST", "DELETE", "PUT", "HEAD", "PURGE", "OPTIONS", "PROPFIND", "MKCOL", "PATCH", "ACL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKWORKSPACE", "MOVE", "NOTIFY", "ORDERPATCH", "POLL", "PROPPATCH", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSIONCONTROL", "BASELINECONTROL", "XMSENUMATTS", "RPC_OUT_DATA", "RPC_IN_DATA", "JSON", "COOK", "TRACK"])).optional()
			},
			{
				name: "mitigationProduct",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ "HTTP/1.x": z.string(), "HTTP/2": z.string(), "HTTP/3": z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/summary/ip_version",
		alias: "radar-get-attacks-layer7-summary-by-ip-version",
		description: `Percentage distribution of attacks by ip version used.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "httpMethod",
				type: "Query",
				schema: z.array(z.enum(["GET", "POST", "DELETE", "PUT", "HEAD", "PURGE", "OPTIONS", "PROPFIND", "MKCOL", "PATCH", "ACL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKWORKSPACE", "MOVE", "NOTIFY", "ORDERPATCH", "POLL", "PROPPATCH", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSIONCONTROL", "BASELINECONTROL", "XMSENUMATTS", "RPC_OUT_DATA", "RPC_IN_DATA", "JSON", "COOK", "TRACK"])).optional()
			},
			{
				name: "mitigationProduct",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ IPv4: z.string(), IPv6: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/summary/managed_rules",
		alias: "radar-get-attacks-layer7-summary-by-managed-rules",
		description: `Percentage distribution of attacks by managed rules used.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "httpMethod",
				type: "Query",
				schema: z.array(z.enum(["GET", "POST", "DELETE", "PUT", "HEAD", "PURGE", "OPTIONS", "PROPFIND", "MKCOL", "PATCH", "ACL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKWORKSPACE", "MOVE", "NOTIFY", "ORDERPATCH", "POLL", "PROPPATCH", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSIONCONTROL", "BASELINECONTROL", "XMSENUMATTS", "RPC_OUT_DATA", "RPC_IN_DATA", "JSON", "COOK", "TRACK"])).optional()
			},
			{
				name: "mitigationProduct",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ Bot: z.string(), "HTTP Anomaly": z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/summary/mitigation_product",
		alias: "radar-get-attacks-layer7-summary-by-mitigation-product",
		description: `Percentage distribution of attacks by mitigation product used.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "httpMethod",
				type: "Query",
				schema: z.array(z.enum(["GET", "POST", "DELETE", "PUT", "HEAD", "PURGE", "OPTIONS", "PROPFIND", "MKCOL", "PATCH", "ACL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKWORKSPACE", "MOVE", "NOTIFY", "ORDERPATCH", "POLL", "PROPPATCH", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSIONCONTROL", "BASELINECONTROL", "XMSENUMATTS", "RPC_OUT_DATA", "RPC_IN_DATA", "JSON", "COOK", "TRACK"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ DDOS: z.string(), WAF: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/timeseries",
		alias: "radar-get-attacks-layer7-timeseries",
		description: `Get a timeseries of Layer 7 attacks. Values represent HTTP requests and are normalized using min-max by default.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "attack",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE_CHANGE", "MIN0_MAX"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ aggInterval: z.string(), confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string().datetime({ offset: true }) }).passthrough(), serie_0: z.object({ timestamps: z.array(z.string()), values: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/timeseries_groups/http_method",
		alias: "radar-get-attacks-layer7-timeseries-group-by-http-method",
		description: `Percentage distribution of attacks by http method used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "mitigationProduct",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ GET: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/timeseries_groups/http_version",
		alias: "radar-get-attacks-layer7-timeseries-group-by-http-version",
		description: `Percentage distribution of attacks by http version used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "httpMethod",
				type: "Query",
				schema: z.array(z.enum(["GET", "POST", "DELETE", "PUT", "HEAD", "PURGE", "OPTIONS", "PROPFIND", "MKCOL", "PATCH", "ACL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKWORKSPACE", "MOVE", "NOTIFY", "ORDERPATCH", "POLL", "PROPPATCH", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSIONCONTROL", "BASELINECONTROL", "XMSENUMATTS", "RPC_OUT_DATA", "RPC_IN_DATA", "JSON", "COOK", "TRACK"])).optional()
			},
			{
				name: "mitigationProduct",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ "HTTP/1.x": z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/timeseries_groups/industry",
		alias: "radar-get-attacks-layer7-timeseries-group-by-industry",
		description: `Percentage distribution of attacks by industry used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "httpMethod",
				type: "Query",
				schema: z.array(z.enum(["GET", "POST", "DELETE", "PUT", "HEAD", "PURGE", "OPTIONS", "PROPFIND", "MKCOL", "PATCH", "ACL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKWORKSPACE", "MOVE", "NOTIFY", "ORDERPATCH", "POLL", "PROPPATCH", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSIONCONTROL", "BASELINECONTROL", "XMSENUMATTS", "RPC_OUT_DATA", "RPC_IN_DATA", "JSON", "COOK", "TRACK"])).optional()
			},
			{
				name: "mitigationProduct",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "limitPerGroup",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.record(z.array(z.string())) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/timeseries_groups/ip_version",
		alias: "radar-get-attacks-layer7-timeseries-group-by-ip-version",
		description: `Percentage distribution of attacks by ip version used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "httpMethod",
				type: "Query",
				schema: z.array(z.enum(["GET", "POST", "DELETE", "PUT", "HEAD", "PURGE", "OPTIONS", "PROPFIND", "MKCOL", "PATCH", "ACL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKWORKSPACE", "MOVE", "NOTIFY", "ORDERPATCH", "POLL", "PROPPATCH", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSIONCONTROL", "BASELINECONTROL", "XMSENUMATTS", "RPC_OUT_DATA", "RPC_IN_DATA", "JSON", "COOK", "TRACK"])).optional()
			},
			{
				name: "mitigationProduct",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ IPv4: z.array(z.string()), IPv6: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/timeseries_groups/managed_rules",
		alias: "radar-get-attacks-layer7-timeseries-group-by-managed-rules",
		description: `Percentage distribution of attacks by managed rules used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "httpMethod",
				type: "Query",
				schema: z.array(z.enum(["GET", "POST", "DELETE", "PUT", "HEAD", "PURGE", "OPTIONS", "PROPFIND", "MKCOL", "PATCH", "ACL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKWORKSPACE", "MOVE", "NOTIFY", "ORDERPATCH", "POLL", "PROPPATCH", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSIONCONTROL", "BASELINECONTROL", "XMSENUMATTS", "RPC_OUT_DATA", "RPC_IN_DATA", "JSON", "COOK", "TRACK"])).optional()
			},
			{
				name: "mitigationProduct",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ Bot: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/timeseries_groups/mitigation_product",
		alias: "radar-get-attacks-layer7-timeseries-group-by-mitigation-product",
		description: `Percentage distribution of attacks by mitigation product used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "httpMethod",
				type: "Query",
				schema: z.array(z.enum(["GET", "POST", "DELETE", "PUT", "HEAD", "PURGE", "OPTIONS", "PROPFIND", "MKCOL", "PATCH", "ACL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKWORKSPACE", "MOVE", "NOTIFY", "ORDERPATCH", "POLL", "PROPPATCH", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSIONCONTROL", "BASELINECONTROL", "XMSENUMATTS", "RPC_OUT_DATA", "RPC_IN_DATA", "JSON", "COOK", "TRACK"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ DDOS: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/timeseries_groups/vertical",
		alias: "radar-get-attacks-layer7-timeseries-group-by-vertical",
		description: `Percentage distribution of attacks by vertical used over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "httpMethod",
				type: "Query",
				schema: z.array(z.enum(["GET", "POST", "DELETE", "PUT", "HEAD", "PURGE", "OPTIONS", "PROPFIND", "MKCOL", "PATCH", "ACL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKWORKSPACE", "MOVE", "NOTIFY", "ORDERPATCH", "POLL", "PROPPATCH", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSIONCONTROL", "BASELINECONTROL", "XMSENUMATTS", "RPC_OUT_DATA", "RPC_IN_DATA", "JSON", "COOK", "TRACK"])).optional()
			},
			{
				name: "mitigationProduct",
				type: "Query",
				schema: z.array(z.enum(["DDOS", "WAF", "BOT_MANAGEMENT", "ACCESS_RULES", "IP_REPUTATION", "API_SHIELD", "DATA_LOSS_PREVENTION"])).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE", "MIN0_MAX"]).optional().default("PERCENTAGE")
			},
			{
				name: "limitPerGroup",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.record(z.array(z.string())) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/top/ases/origin",
		alias: "radar-get-attacks-layer7-top-origin-as",
		description: `Get the top origin Autonomous Systems of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin Autonomous Systems is determined by the client IP.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ originAsn: z.string(), originAsnName: z.string(), rank: z.number(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/top/attacks",
		alias: "radar-get-attacks-layer7-top-attacks",
		description: `Get the top attacks from origin to target location. Values are a percentage out of the total layer 7 attacks (with billing country). The attack magnitude can be defined by the number of mitigated requests or by the number of zones affected. You can optionally limit the number of attacks per origin/target location (useful if all the top attacks are from or to the same location).`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "limitDirection",
				type: "Query",
				schema: z.enum(["ORIGIN", "TARGET"]).optional().default("ORIGIN")
			},
			{
				name: "limitPerLocation",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "magnitude",
				type: "Query",
				schema: z.enum(["AFFECTED_ZONES", "MITIGATED_REQUESTS"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ originCountryAlpha2: z.string(), originCountryName: z.string(), targetCountryAlpha2: z.string(), targetCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/top/industry",
		alias: "radar-get-attacks-layer7-top-industries",
		description: `Get the Industry of attacks.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/top/locations/origin",
		alias: "radar-get-attacks-layer7-top-origin-location",
		description: `Get the top origin locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ originCountryAlpha2: z.string(), originCountryName: z.string(), rank: z.number(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/top/locations/target",
		alias: "radar-get-attacks-layer7-top-target-location",
		description: `Get the top target locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The target location is determined by the attacked zone&#x27;s billing country, when available.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ rank: z.number(), targetCountryAlpha2: z.string(), targetCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/attacks/layer7/top/vertical",
		alias: "radar-get-attacks-layer7-top-verticals",
		description: `Get the Verticals of attacks.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/bgp/hijacks/events",
		alias: "radar-get-bgp-hijacks-events",
		description: `Get the BGP hijack events. (Beta)`,
		requestFormat: "json",
		parameters: [
			{
				name: "page",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "eventId",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "hijackerAsn",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "victimAsn",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "involvedAsn",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "involvedCountry",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "prefix",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "minConfidence",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "maxConfidence",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"]).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "sortBy",
				type: "Query",
				schema: z.enum(["ID", "TIME", "CONFIDENCE"]).optional()
			},
			{
				name: "sortOrder",
				type: "Query",
				schema: z.enum(["ASC", "DESC"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ asn_info: z.array(z.object({ asn: z.number().int(), country_code: z.string(), org_name: z.string() }).passthrough()), events: z.array(z.object({ confidence_score: z.number().int(), duration: z.number().int(), event_type: z.number().int(), hijack_msgs_count: z.number().int(), hijacker_asn: z.number().int(), hijacker_country: z.string(), id: z.number().int(), is_stale: z.boolean(), max_hijack_ts: z.string(), max_msg_ts: z.string(), min_hijack_ts: z.string(), on_going_count: z.number().int(), peer_asns: z.array(z.number()), peer_ip_count: z.number().int(), prefixes: z.array(z.string()), tags: z.array(z.object({ name: z.string(), score: z.number().int() }).passthrough()), victim_asns: z.array(z.number()), victim_countries: z.array(z.string()) }).passthrough()), total_monitors: z.number().int() }).passthrough(), result_info: z.object({ count: z.number().int(), page: z.number().int(), per_page: z.number().int(), total_count: z.number().int() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/bgp/leaks/events",
		alias: "radar-get-bgp-route-leak-events",
		description: `Get the BGP route leak events (Beta).`,
		requestFormat: "json",
		parameters: [
			{
				name: "page",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "eventId",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "leakAsn",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "involvedAsn",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "involvedCountry",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"]).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "sortBy",
				type: "Query",
				schema: z.enum(["ID", "LEAKS", "PEERS", "PREFIXES", "ORIGINS", "TIME"]).optional()
			},
			{
				name: "sortOrder",
				type: "Query",
				schema: z.enum(["ASC", "DESC"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ asn_info: z.array(z.object({ asn: z.number().int(), country_code: z.string(), org_name: z.string() }).passthrough()), events: z.array(z.object({ countries: z.array(z.string()), detected_ts: z.string(), finished: z.boolean(), id: z.number().int(), leak_asn: z.number().int(), leak_count: z.number().int(), leak_seg: z.array(z.number()), leak_type: z.number().int(), max_ts: z.string(), min_ts: z.string(), origin_count: z.number().int(), peer_count: z.number().int(), prefix_count: z.number().int() }).passthrough()) }).passthrough(), result_info: z.object({ count: z.number().int(), page: z.number().int(), per_page: z.number().int(), total_count: z.number().int() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/bgp/routes/moas",
		alias: "radar-get-bgp-pfx2as-moas",
		description: `List all Multi-origin AS (MOAS) prefixes on the global routing tables.`,
		requestFormat: "json",
		parameters: [
			{
				name: "origin",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "prefix",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "invalid_only",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ data_time: z.string(), query_time: z.string(), total_peers: z.number().int() }).passthrough(), moas: z.array(z.object({ origins: z.array(z.object({ origin: z.number().int(), peer_count: z.number().int(), rpki_validation: z.string() }).passthrough()), prefix: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/bgp/routes/pfx2as",
		alias: "radar-get-bgp-pfx2as",
		description: `Lookup prefix-to-origin mapping on global routing tables.`,
		requestFormat: "json",
		parameters: [
			{
				name: "origin",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "prefix",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "rpkiStatus",
				type: "Query",
				schema: z.enum(["VALID", "INVALID", "UNKNOWN"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ data_time: z.string(), query_time: z.string(), total_peers: z.number().int() }).passthrough(), prefix_origins: z.array(z.object({ origin: z.number().int(), peer_count: z.number().int(), prefix: z.string(), rpki_validation: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/bgp/routes/stats",
		alias: "radar-get-bgp-routes-stats",
		description: `Get the BGP routing table stats (Beta).`,
		requestFormat: "json",
		parameters: [
			{
				name: "asn",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ data_time: z.string(), query_time: z.string(), total_peers: z.number().int() }).passthrough(), stats: z.object({ distinct_origins: z.number().int(), distinct_origins_ipv4: z.number().int(), distinct_origins_ipv6: z.number().int(), distinct_prefixes: z.number().int(), distinct_prefixes_ipv4: z.number().int(), distinct_prefixes_ipv6: z.number().int(), routes_invalid: z.number().int(), routes_invalid_ipv4: z.number().int(), routes_invalid_ipv6: z.number().int(), routes_total: z.number().int(), routes_total_ipv4: z.number().int(), routes_total_ipv6: z.number().int(), routes_unknown: z.number().int(), routes_unknown_ipv4: z.number().int(), routes_unknown_ipv6: z.number().int(), routes_valid: z.number().int(), routes_valid_ipv4: z.number().int(), routes_valid_ipv6: z.number().int() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/bgp/routes/timeseries",
		alias: "radar-get-bgp-ip-space-timeseries",
		description: `Gets time-series data for the announced IP space count, represented as the number of IPv4 /24s and IPv6 /48s, for a given ASN.`,
		requestFormat: "json",
		parameters: [
			{
				name: "dateRange",
				type: "Query",
				schema: z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"]).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()) }).passthrough(), serie_ipv4_24s: z.object({ timestamps: z.array(z.string()), values: z.array(z.number()) }).passthrough(), serie_ipv6_48s: z.object({ timestamps: z.array(z.string()), values: z.array(z.number()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/bgp/timeseries",
		alias: "radar-get-bgp-timeseries",
		description: `Gets BGP updates change over time. Raw values are returned. When requesting updates of an autonomous system (AS), only BGP updates of type announcement are returned.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "prefix",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "updateType",
				type: "Query",
				schema: z.array(z.enum(["ANNOUNCEMENT", "WITHDRAWAL"])).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ aggInterval: z.string(), confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string().datetime({ offset: true }) }).passthrough(), serie_0: z.object({ timestamps: z.array(z.string()), values: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/bgp/top/ases",
		alias: "radar-get-bgp-top-ases",
		description: `Get the top autonomous systems (AS) by BGP updates (announcements only). Values are a percentage out of the total updates.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "prefix",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "updateType",
				type: "Query",
				schema: z.array(z.enum(["ANNOUNCEMENT", "WITHDRAWAL"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()) }).passthrough(), top_0: z.array(z.object({ ASName: z.string(), asn: z.number().int(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/bgp/top/ases/prefixes",
		alias: "radar-get-bgp-top-asns-by-prefixes",
		description: `Get the full list of autonomous systems on the global routing table ordered by announced prefixes count. The data comes from public BGP MRT data archives and updates every 2 hours.`,
		requestFormat: "json",
		parameters: [
			{
				name: "country",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ asns: z.array(z.object({ asn: z.number().int(), country: z.string(), name: z.string(), pfxs_count: z.number().int() }).passthrough()), meta: z.object({ data_time: z.string(), query_time: z.string(), total_peers: z.number().int() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/bgp/top/prefixes",
		alias: "radar-get-bgp-top-prefixes",
		description: `Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "updateType",
				type: "Query",
				schema: z.array(z.enum(["ANNOUNCEMENT", "WITHDRAWAL"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()) }).passthrough(), top_0: z.array(z.object({ prefix: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/connection_tampering/summary",
		alias: "radar-get-connection-tampering-summary",
		description: `Distribution of connection tampering types over a given time period.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()) }).passthrough(), summary_0: z.object({ later_in_flow: z.string(), no_match: z.string(), post_ack: z.string(), post_psh: z.string(), post_syn: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/connection_tampering/timeseries_groups",
		alias: "radar-get-connection-tampering-timeseries-group",
		description: `Distribution of connection tampering types over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ aggInterval: z.string(), confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string().datetime({ offset: true }) }).passthrough(), serie_0: z.object({ later_in_flow: z.array(z.string()), no_match: z.array(z.string()), post_ack: z.array(z.string()), post_psh: z.array(z.string()), post_syn: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/datasets",
		alias: "radar-get-reports-datasets",
		description: `Get a list of datasets.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "offset",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "datasetType",
				type: "Query",
				schema: z.enum(["RANKING_BUCKET", "REPORT"]).optional().default("RANKING_BUCKET")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ datasets: z.array(z.object({ description: z.string(), id: z.number().int(), meta: z.object({}).partial().passthrough(), tags: z.array(z.string()), title: z.string(), type: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/datasets/:alias",
		alias: "radar-get-reports-dataset-download",
		description: `Get the csv content of a given dataset by alias or id. When getting the content by alias the latest dataset is returned, optionally filtered by the latest available at a given date.`,
		requestFormat: "json",
		parameters: [
			{
				name: "alias",
				type: "Path",
				schema: z.string()
			},
			{
				name: "date",
				type: "Query",
				schema: z.string().nullish()
			},
		],
		response: z.void(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "post",
		path: "/radar/datasets/download",
		alias: "radar-post-reports-dataset-download-url",
		description: `Get a url to download a single dataset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ datasetId: z.number().int() }).passthrough()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ dataset: z.object({ url: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/dns/top/ases",
		alias: "radar-get-dns-top-ases",
		description: `Get top autonomous systems by DNS queries made to Cloudflare&#x27;s public DNS resolver.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "domain",
				type: "Query",
				schema: z.array(z.string())
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()) }).passthrough(), top_0: z.array(z.object({ clientASN: z.number().int(), clientASName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/dns/top/locations",
		alias: "radar-get-dns-top-locations",
		description: `Get top locations by DNS queries made to Cloudflare&#x27;s public DNS resolver.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "domain",
				type: "Query",
				schema: z.array(z.string())
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()) }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/summary/arc",
		alias: "radar-get-email-routing-summary-by-arc",
		description: `Percentage distribution of emails classified per ARC validation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "encrypted",
				type: "Query",
				schema: z.array(z.enum(["ENCRYPTED", "NOT_ENCRYPTED"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ FAIL: z.string(), NONE: z.string(), PASS: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/summary/dkim",
		alias: "radar-get-email-routing-summary-by-dkim",
		description: `Percentage distribution of emails classified per DKIM validation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "encrypted",
				type: "Query",
				schema: z.array(z.enum(["ENCRYPTED", "NOT_ENCRYPTED"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ FAIL: z.string(), NONE: z.string(), PASS: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/summary/dmarc",
		alias: "radar-get-email-routing-summary-by-dmarc",
		description: `Percentage distribution of emails classified per DMARC validation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "encrypted",
				type: "Query",
				schema: z.array(z.enum(["ENCRYPTED", "NOT_ENCRYPTED"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ FAIL: z.string(), NONE: z.string(), PASS: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/summary/encrypted",
		alias: "radar-get-email-routing-summary-by-encrypted",
		description: `Percentage distribution of emails by Encrypted`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ ENCRYPTED: z.string(), NOT_ENCRYPTED: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/summary/ip_version",
		alias: "radar-get-email-routing-summary-by-ip-version",
		description: `Percentage distribution of emails by Ip Version.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "encrypted",
				type: "Query",
				schema: z.array(z.enum(["ENCRYPTED", "NOT_ENCRYPTED"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ IPv4: z.string(), IPv6: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/summary/spf",
		alias: "radar-get-email-routing-summary-by-spf",
		description: `Percentage distribution of emails classified per SPF validation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "encrypted",
				type: "Query",
				schema: z.array(z.enum(["ENCRYPTED", "NOT_ENCRYPTED"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ FAIL: z.string(), NONE: z.string(), PASS: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/timeseries_groups/arc",
		alias: "radar-get-email-routing-timeseries-group-by-arc",
		description: `Percentage distribution of emails classified per Arc validation over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "encrypted",
				type: "Query",
				schema: z.array(z.enum(["ENCRYPTED", "NOT_ENCRYPTED"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ FAIL: z.array(z.string()), NONE: z.array(z.string()), PASS: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/timeseries_groups/dkim",
		alias: "radar-get-email-routing-timeseries-group-by-dkim",
		description: `Percentage distribution of emails classified per DKIM validation over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "encrypted",
				type: "Query",
				schema: z.array(z.enum(["ENCRYPTED", "NOT_ENCRYPTED"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ FAIL: z.array(z.string()), NONE: z.array(z.string()), PASS: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/timeseries_groups/dmarc",
		alias: "radar-get-email-routing-timeseries-group-by-dmarc",
		description: `Percentage distribution of emails classified per DMARC validation over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "encrypted",
				type: "Query",
				schema: z.array(z.enum(["ENCRYPTED", "NOT_ENCRYPTED"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ FAIL: z.array(z.string()), NONE: z.array(z.string()), PASS: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/timeseries_groups/encrypted",
		alias: "radar-get-email-routing-timeseries-group-by-encrypted",
		description: `Percentage distribution of emails by Encrypted over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ ENCRYPTED: z.array(z.string()), NOT_ENCRYPTED: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/timeseries_groups/ip_version",
		alias: "radar-get-email-routing-timeseries-group-by-ip-version",
		description: `Percentage distribution of emails by Ip Version over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "encrypted",
				type: "Query",
				schema: z.array(z.enum(["ENCRYPTED", "NOT_ENCRYPTED"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ IPv4: z.array(z.string()), IPv6: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/routing/timeseries_groups/spf",
		alias: "radar-get-email-routing-timeseries-group-by-spf",
		description: `Percentage distribution of emails classified per SPF validation over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "encrypted",
				type: "Query",
				schema: z.array(z.enum(["ENCRYPTED", "NOT_ENCRYPTED"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ FAIL: z.array(z.string()), NONE: z.array(z.string()), PASS: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/summary/arc",
		alias: "radar-get-email-security-summary-by-arc",
		description: `Percentage distribution of emails classified per ARC validation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ FAIL: z.string(), NONE: z.string(), PASS: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/summary/dkim",
		alias: "radar-get-email-security-summary-by-dkim",
		description: `Percentage distribution of emails classified per DKIM validation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ FAIL: z.string(), NONE: z.string(), PASS: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/summary/dmarc",
		alias: "radar-get-email-security-summary-by-dmarc",
		description: `Percentage distribution of emails classified per DMARC validation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ FAIL: z.string(), NONE: z.string(), PASS: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/summary/malicious",
		alias: "radar-get-email-security-summary-by-malicious",
		description: `Percentage distribution of emails classified as MALICIOUS.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ MALICIOUS: z.string(), NOT_MALICIOUS: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/summary/spam",
		alias: "radar-get-email-security-summary-by-spam",
		description: `Proportion of emails categorized as either spam or legitimate (non-spam).`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ NOT_SPAM: z.string(), SPAM: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/summary/spf",
		alias: "radar-get-email-security-summary-by-spf",
		description: `Percentage distribution of emails classified per SPF validation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ FAIL: z.string(), NONE: z.string(), PASS: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/summary/spoof",
		alias: "radar-get-email-security-summary-by-spoof",
		description: `Proportion of emails categorized as either spoof or legitimate (non-spoof).`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ NOT_SPOOF: z.string(), SPOOF: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/summary/threat_category",
		alias: "radar-get-email-security-summary-by-threat-category",
		description: `Percentage distribution of emails classified in Threat Categories.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ BrandImpersonation: z.string(), CredentialHarvester: z.string(), IdentityDeception: z.string(), Link: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/summary/tls_version",
		alias: "radar-get-email-security-summary-by-tls-version",
		description: `Percentage distribution of emails classified per TLS Version.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ "TLS 1.0": z.string(), "TLS 1.1": z.string(), "TLS 1.2": z.string(), "TLS 1.3": z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/timeseries_groups/arc",
		alias: "radar-get-email-security-timeseries-group-by-arc",
		description: `Percentage distribution of emails classified per Arc validation over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ FAIL: z.array(z.string()), NONE: z.array(z.string()), PASS: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/timeseries_groups/dkim",
		alias: "radar-get-email-security-timeseries-group-by-dkim",
		description: `Percentage distribution of emails classified per DKIM validation over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ FAIL: z.array(z.string()), NONE: z.array(z.string()), PASS: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/timeseries_groups/dmarc",
		alias: "radar-get-email-security-timeseries-group-by-dmarc",
		description: `Percentage distribution of emails classified per DMARC validation over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ FAIL: z.array(z.string()), NONE: z.array(z.string()), PASS: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/timeseries_groups/malicious",
		alias: "radar-get-email-security-timeseries-group-by-malicious",
		description: `Percentage distribution of emails classified as MALICIOUS over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ MALICIOUS: z.array(z.string()), NOT_MALICIOUS: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/timeseries_groups/spam",
		alias: "radar-get-email-security-timeseries-group-by-spam",
		description: `Percentage distribution of emails classified as SPAM over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ NOT_SPAM: z.array(z.string()), SPAM: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/timeseries_groups/spf",
		alias: "radar-get-email-security-timeseries-group-by-spf",
		description: `Percentage distribution of emails classified per SPF validation over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ FAIL: z.array(z.string()), NONE: z.array(z.string()), PASS: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/timeseries_groups/spoof",
		alias: "radar-get-email-security-timeseries-group-by-spoof",
		description: `Percentage distribution of emails classified as SPOOF over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ NOT_SPOOF: z.array(z.string()), SPOOF: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/timeseries_groups/threat_category",
		alias: "radar-get-email-security-timeseries-group-by-threat-category",
		description: `Percentage distribution of emails classified in Threat Categories over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ BrandImpersonation: z.array(z.string()), CredentialHarvester: z.array(z.string()), IdentityDeception: z.array(z.string()), Link: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/timeseries_groups/tls_version",
		alias: "radar-get-email-security-timeseries-group-by-tls-version",
		description: `Percentage distribution of emails classified per TLS Version over time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ "TLS 1.0": z.array(z.string()), "TLS 1.1": z.array(z.string()), "TLS 1.2": z.array(z.string()), "TLS 1.3": z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/top/tlds",
		alias: "radar-get-email-security-top-tlds-by-messages",
		description: `Get the top TLDs by email messages. Values are a percentage out of the total emails.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "tldCategory",
				type: "Query",
				schema: z.enum(["CLASSIC", "COUNTRY"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/top/tlds/malicious/:malicious",
		alias: "radar-get-email-security-top-tlds-by-malicious",
		description: `Get the TLDs by emails classified as malicious or not.`,
		requestFormat: "json",
		parameters: [
			{
				name: "malicious",
				type: "Path",
				schema: z.enum(["MALICIOUS", "NOT_MALICIOUS"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "tldCategory",
				type: "Query",
				schema: z.enum(["CLASSIC", "COUNTRY"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/top/tlds/spam/:spam",
		alias: "radar-get-email-security-top-tlds-by-spam",
		description: `Get the top TLDs by emails classified as Spam or not.`,
		requestFormat: "json",
		parameters: [
			{
				name: "spam",
				type: "Path",
				schema: z.enum(["SPAM", "NOT_SPAM"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "tldCategory",
				type: "Query",
				schema: z.enum(["CLASSIC", "COUNTRY"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/email/security/top/tlds/spoof/:spoof",
		alias: "radar-get-email-security-top-tlds-by-spoof",
		description: `Get the TLDs by emails classified as spoof or not.`,
		requestFormat: "json",
		parameters: [
			{
				name: "spoof",
				type: "Path",
				schema: z.enum(["SPOOF", "NOT_SPOOF"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "arc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dkim",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "dmarc",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "spf",
				type: "Query",
				schema: z.array(z.enum(["PASS", "NONE", "FAIL"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3"])).optional()
			},
			{
				name: "tldCategory",
				type: "Query",
				schema: z.enum(["CLASSIC", "COUNTRY"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/entities/asns",
		alias: "radar-get-entities-asn-list",
		description: `Gets a list of autonomous systems (AS).`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "offset",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "orderBy",
				type: "Query",
				schema: z.enum(["ASN", "POPULATION"]).optional().default("ASN")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ asns: z.array(z.object({ aka: z.string().optional(), asn: z.number().int(), country: z.string(), countryName: z.string(), name: z.string(), nameLong: z.string().optional(), orgName: z.string().optional(), website: z.string().optional() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/entities/asns/:asn",
		alias: "radar-get-entities-asn-by-id",
		description: `Get the requested autonomous system information. A confidence level below &#x60;5&#x60; indicates a low level of confidence in the traffic data - normally this happens because Cloudflare has a small amount of traffic from/to this AS). Population estimates come from APNIC (refer to https://labs.apnic.net/?p&#x3D;526).`,
		requestFormat: "json",
		parameters: [
			{
				name: "asn",
				type: "Path",
				schema: z.number().int()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ asn: z.object({ aka: z.string().optional(), asn: z.number().int(), confidenceLevel: z.number().int(), country: z.string(), countryName: z.string(), estimatedUsers: z.object({ estimatedUsers: z.number().int().optional(), locations: z.array(z.object({ estimatedUsers: z.number().int().optional(), locationAlpha2: z.string(), locationName: z.string() }).passthrough()) }).passthrough(), name: z.string(), nameLong: z.string().optional(), orgName: z.string(), related: z.array(z.object({ aka: z.string().optional(), asn: z.number().int(), estimatedUsers: z.number().int().optional(), name: z.string() }).passthrough()), source: z.string(), website: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/entities/asns/:asn/rel",
		alias: "radar-get-asns-rel",
		description: `Get AS-level relationship for given networks.`,
		requestFormat: "json",
		parameters: [
			{
				name: "asn",
				type: "Path",
				schema: z.number().int()
			},
			{
				name: "asn2",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ data_time: z.string(), query_time: z.string(), total_peers: z.number().int() }).passthrough(), rels: z.array(z.object({ asn1: z.number().int(), asn1_country: z.string(), asn1_name: z.string(), asn2: z.number().int(), asn2_country: z.string(), asn2_name: z.string(), rel: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/entities/asns/ip",
		alias: "radar-get-entities-asn-by-ip",
		description: `Get the requested autonomous system information based on IP address. Population estimates come from APNIC (refer to https://labs.apnic.net/?p&#x3D;526).`,
		requestFormat: "json",
		parameters: [
			{
				name: "ip",
				type: "Query",
				schema: z.string()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ asn: z.object({ aka: z.string().optional(), asn: z.number().int(), country: z.string(), countryName: z.string(), estimatedUsers: z.object({ estimatedUsers: z.number().int().optional(), locations: z.array(z.object({ estimatedUsers: z.number().int().optional(), locationAlpha2: z.string(), locationName: z.string() }).passthrough()) }).passthrough(), name: z.string(), nameLong: z.string().optional(), orgName: z.string(), related: z.array(z.object({ aka: z.string().optional(), asn: z.number().int(), estimatedUsers: z.number().int().optional(), name: z.string() }).passthrough()), source: z.string(), website: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/entities/ip",
		alias: "radar-get-entities-ip",
		description: `Get IP address information. `,
		requestFormat: "json",
		parameters: [
			{
				name: "ip",
				type: "Query",
				schema: z.string()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ ip: z.object({ asn: z.string(), asnLocation: z.string(), asnName: z.string(), asnOrgName: z.string(), ip: z.string(), ipVersion: z.string(), location: z.string(), locationName: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/entities/locations",
		alias: "radar-get-entities-locations",
		description: `Get a list of locations.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "offset",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ locations: z.array(z.object({ alpha2: z.string(), latitude: z.string(), longitude: z.string(), name: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/entities/locations/:location",
		alias: "radar-get-entities-location-by-alpha2",
		description: `Get the requested location information. A confidence level below &#x60;5&#x60; indicates a low level of confidence in the traffic data - normally this happens because Cloudflare has a small amount of traffic from/to this location).`,
		requestFormat: "json",
		parameters: [
			{
				name: "location",
				type: "Path",
				schema: z.string()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ location: z.object({ alpha2: z.string(), confidenceLevel: z.number().int(), latitude: z.string(), longitude: z.string(), name: z.string(), region: z.string(), subregion: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/summary/bot_class",
		alias: "radar-get-http-summary-by-bot-class",
		description: `Percentage distribution of bot-generated traffic to genuine human traffic, as classified by Cloudflare. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ bot: z.string(), human: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/summary/device_type",
		alias: "radar-get-http-summary-by-device-type",
		description: `Percentage of Internet traffic generated by mobile, desktop, and other types of devices, over a given time period.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ desktop: z.string(), mobile: z.string(), other: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/summary/http_protocol",
		alias: "radar-get-http-summary-by-http-protocol",
		description: `Percentage distribution of traffic per HTTP protocol over a given time period.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ http: z.string(), https: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/summary/http_version",
		alias: "radar-get-http-summary-by-http-version",
		description: `Percentage distribution of traffic per HTTP protocol version over a given time period.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ "HTTP/1.x": z.string(), "HTTP/2": z.string(), "HTTP/3": z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/summary/ip_version",
		alias: "radar-get-http-summary-by-ip-version",
		description: `Percentage distribution of Internet traffic based on IP protocol versions, such as IPv4 and IPv6, over a given time period.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ IPv4: z.string(), IPv6: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/summary/os",
		alias: "radar-get-http-summary-by-operating-system",
		description: `Percentage distribution of Internet traffic generated by different operating systems like Windows, macOS, Android, iOS, and others, over a given time period.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ ANDROID: z.string(), IOS: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/summary/tls_version",
		alias: "radar-get-http-summary-by-tls-version",
		description: `Percentage distribution of traffic per TLS protocol version, over a given time period.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ "TLS 1.0": z.string(), "TLS 1.1": z.string(), "TLS 1.2": z.string(), "TLS 1.3": z.string(), "TLS QUIC": z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/timeseries_groups/bot_class",
		alias: "radar-get-http-timeseries-group-by-bot-class",
		description: `Get a time series of the percentage distribution of traffic classified as automated or human. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ bot: z.array(z.string()), human: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/timeseries_groups/browser",
		alias: "radar-get-http-timeseries-group-by-browsers",
		description: `Get a time series of the percentage distribution of traffic of the top user agents.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "limitPerGroup",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.record(z.array(z.string())) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/timeseries_groups/browser_family",
		alias: "radar-get-http-timeseries-group-by-browser-families",
		description: `Get a time series of the percentage distribution of traffic of the top user agents aggregated in families.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.record(z.array(z.string())) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/timeseries_groups/device_type",
		alias: "radar-get-http-timeseries-group-by-device-type",
		description: `Get a time series of the percentage distribution of traffic per device type.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ desktop: z.array(z.string()), mobile: z.array(z.string()), other: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/timeseries_groups/http_protocol",
		alias: "radar-get-http-timeseries-group-by-http-protocol",
		description: `Get a time series of the percentage distribution of traffic per HTTP protocol.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ http: z.array(z.string()), https: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/timeseries_groups/http_version",
		alias: "radar-get-http-timeseries-group-by-http-version",
		description: `Get a time series of the percentage distribution of traffic per HTTP protocol version.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ "HTTP/1.x": z.array(z.string()), "HTTP/2": z.array(z.string()), "HTTP/3": z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/timeseries_groups/ip_version",
		alias: "radar-get-http-timeseries-group-by-ip-version",
		description: `Get a time series of the percentage distribution of traffic per IP protocol version.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ IPv4: z.array(z.string()), IPv6: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/timeseries_groups/os",
		alias: "radar-get-http-timeseries-group-by-operating-system",
		description: `Get a time series of the percentage distribution of traffic of the top operating systems.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.record(z.array(z.string())) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/timeseries_groups/tls_version",
		alias: "radar-get-http-timeseries-group-by-tls-version",
		description: `Get a time series of the percentage distribution of traffic per TLS protocol version.`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ "TLS 1.0": z.array(z.string()), "TLS 1.1": z.array(z.string()), "TLS 1.2": z.array(z.string()), "TLS 1.3": z.array(z.string()), "TLS QUIC": z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/ases",
		alias: "radar-get-http-top-ases-by-http-requests",
		description: `Get the top autonomous systems by HTTP traffic. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientASN: z.number().int(), clientASName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/ases/bot_class/:bot_class",
		alias: "radar-get-http-top-ases-by-bot-class",
		description: `Get the top autonomous systems (AS), by HTTP traffic, of the requested bot class. These two categories use Cloudflare&#x27;s bot score - refer to [Bot Scores](https://developers.cloudflare.com/bots/concepts/bot-score) for more information. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "bot_class",
				type: "Path",
				schema: z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientASN: z.number().int(), clientASName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/ases/device_type/:device_type",
		alias: "radar-get-http-top-ases-by-device-type",
		description: `Get the top autonomous systems (AS), by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "device_type",
				type: "Path",
				schema: z.enum(["DESKTOP", "MOBILE", "OTHER"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientASN: z.number().int(), clientASName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/ases/http_protocol/:http_protocol",
		alias: "radar-get-http-top-ases-by-http-protocol",
		description: `Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "http_protocol",
				type: "Path",
				schema: z.enum(["HTTP", "HTTPS"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientASN: z.number().int(), clientASName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/ases/http_version/:http_version",
		alias: "radar-get-http-top-ases-by-http-version",
		description: `Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol version. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "http_version",
				type: "Path",
				schema: z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientASN: z.number().int(), clientASName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/ases/ip_version/:ip_version",
		alias: "radar-get-http-top-ases-by-ip-version",
		description: `Get the top autonomous systems, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ip_version",
				type: "Path",
				schema: z.enum(["IPv4", "IPv6"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientASN: z.number().int(), clientASName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/ases/os/:os",
		alias: "radar-get-http-top-ases-by-operating-system",
		description: `Get the top autonomous systems, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "os",
				type: "Path",
				schema: z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientASN: z.number().int(), clientASName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/ases/tls_version/:tls_version",
		alias: "radar-get-http-top-ases-by-tls-version",
		description: `Get the top autonomous systems (AS), by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tls_version",
				type: "Path",
				schema: z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientASN: z.number().int(), clientASName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/browser_families",
		alias: "radar-get-http-top-browser-families",
		description: `Get the top user agents aggregated in families by HTTP traffic. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/browsers",
		alias: "radar-get-http-top-browsers",
		description: `Get the top user agents by HTTP traffic. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ name: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/locations",
		alias: "radar-get-http-top-locations-by-http-requests",
		description: `Get the top locations by HTTP traffic. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/locations/bot_class/:bot_class",
		alias: "radar-get-http-top-locations-by-bot-class",
		description: `Get the top locations, by HTTP traffic, of the requested bot class. These two categories use Cloudflare&#x27;s bot score - refer to [Bot scores])https://developers.cloudflare.com/bots/concepts/bot-score). Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "bot_class",
				type: "Path",
				schema: z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/locations/device_type/:device_type",
		alias: "radar-get-http-top-locations-by-device-type",
		description: `Get the top locations, by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "device_type",
				type: "Path",
				schema: z.enum(["DESKTOP", "MOBILE", "OTHER"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/locations/http_protocol/:http_protocol",
		alias: "radar-get-http-top-locations-by-http-protocol",
		description: `Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "http_protocol",
				type: "Path",
				schema: z.enum(["HTTP", "HTTPS"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/locations/http_version/:http_version",
		alias: "radar-get-http-top-locations-by-http-version",
		description: `Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "http_version",
				type: "Path",
				schema: z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/locations/ip_version/:ip_version",
		alias: "radar-get-http-top-locations-by-ip-version",
		description: `Get the top locations, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ip_version",
				type: "Path",
				schema: z.enum(["IPv4", "IPv6"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/locations/os/:os",
		alias: "radar-get-http-top-locations-by-operating-system",
		description: `Get the top locations, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "os",
				type: "Path",
				schema: z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "tlsVersion",
				type: "Query",
				schema: z.array(z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/http/top/locations/tls_version/:tls_version",
		alias: "radar-get-http-top-locations-by-tls-version",
		description: `Get the top locations, by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.`,
		requestFormat: "json",
		parameters: [
			{
				name: "tls_version",
				type: "Path",
				schema: z.enum(["TLSv1_0", "TLSv1_1", "TLSv1_2", "TLSv1_3", "TLSvQUIC"])
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "botClass",
				type: "Query",
				schema: z.array(z.enum(["LIKELY_AUTOMATED", "LIKELY_HUMAN"])).optional()
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.array(z.enum(["DESKTOP", "MOBILE", "OTHER"])).optional()
			},
			{
				name: "httpProtocol",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "HTTPS"])).optional()
			},
			{
				name: "httpVersion",
				type: "Query",
				schema: z.array(z.enum(["HTTPv1", "HTTPv2", "HTTPv3"])).optional()
			},
			{
				name: "ipVersion",
				type: "Query",
				schema: z.array(z.enum(["IPv4", "IPv6"])).optional()
			},
			{
				name: "os",
				type: "Query",
				schema: z.array(z.enum(["WINDOWS", "MACOSX", "IOS", "ANDROID", "CHROMEOS", "LINUX", "SMART_TV"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/netflows/timeseries",
		alias: "radar-get-netflows-timeseries",
		description: `Get network traffic change over time. Visit https://en.wikipedia.org/wiki/NetFlow for more information on NetFlows. `,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "product",
				type: "Query",
				schema: z.array(z.enum(["HTTP", "ALL"])).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "normalization",
				type: "Query",
				schema: z.enum(["PERCENTAGE_CHANGE", "MIN0_MAX"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ aggInterval: z.string(), confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string().datetime({ offset: true }) }).passthrough(), serie_0: z.object({ timestamps: z.array(z.string()), values: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/netflows/top/ases",
		alias: "radar-get-netflows-top-ases",
		description: `Get the top autonomous systems (AS) by network traffic (NetFlows) over a given time period. Visit https://en.wikipedia.org/wiki/NetFlow for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ top_0: z.array(z.object({ clientASN: z.number(), clientASName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/netflows/top/locations",
		alias: "radar-get-netflows-top-locations",
		description: `Get the top locations by network traffic (NetFlows) over a given time period. Visit https://en.wikipedia.org/wiki/NetFlow for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ top_0: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/quality/iqi/summary",
		alias: "radar-get-quality-index-summary",
		description: `Get a summary (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "metric",
				type: "Query",
				schema: z.enum(["BANDWIDTH", "DNS", "LATENCY"])
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ p25: z.string(), p50: z.string(), p75: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/quality/iqi/timeseries_groups",
		alias: "radar-get-quality-index-timeseries-group",
		description: `Get a time series (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).`,
		requestFormat: "json",
		parameters: [
			{
				name: "aggInterval",
				type: "Query",
				schema: z.enum(["15m", "1h", "1d", "1w"]).optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "interpolation",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "metric",
				type: "Query",
				schema: z.enum(["BANDWIDTH", "DNS", "LATENCY"])
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({}).partial().passthrough(), serie_0: z.object({ p25: z.array(z.string()), p50: z.array(z.string()), p75: z.array(z.string()), timestamps: z.array(z.string()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/quality/speed/histogram",
		alias: "radar-get-quality-speed-histogram",
		description: `Get an histogram from the previous 90 days of Cloudflare Speed Test data, split into fixed bandwidth (Mbps), latency (ms) or jitter (ms) buckets.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "bucketSize",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "metricGroup",
				type: "Query",
				schema: z.enum(["BANDWIDTH", "LATENCY", "JITTER"]).optional().default("bandwidth")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ histogram_0: z.object({ bandwidthDownload: z.array(z.string()), bandwidthUpload: z.array(z.string()), bucketMin: z.array(z.string()) }).passthrough(), meta: z.object({}).partial().passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/quality/speed/summary",
		alias: "radar-get-quality-speed-summary",
		description: `Get a summary of bandwidth, latency, jitter and packet loss, from the previous 90 days of Cloudflare Speed Test data.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string(), normalization: z.string() }).passthrough(), summary_0: z.object({ bandwidthDownload: z.string(), bandwidthUpload: z.string(), jitterIdle: z.string(), jitterLoaded: z.string(), latencyIdle: z.string(), latencyLoaded: z.string(), packetLoss: z.string() }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/quality/speed/top/ases",
		alias: "radar-get-quality-speed-top-ases",
		description: `Get the top autonomous systems by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "orderBy",
				type: "Query",
				schema: z.enum(["BANDWIDTH_DOWNLOAD", "BANDWIDTH_UPLOAD", "LATENCY_IDLE", "LATENCY_LOADED", "JITTER_IDLE", "JITTER_LOADED"]).optional().default("BANDWIDTH_DOWNLOAD")
			},
			{
				name: "reverse",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ bandwidthDownload: z.string(), bandwidthUpload: z.string(), clientASN: z.number(), clientASName: z.string(), jitterIdle: z.string(), jitterLoaded: z.string(), latencyIdle: z.string(), latencyLoaded: z.string(), numTests: z.number(), rankPower: z.number() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/quality/speed/top/locations",
		alias: "radar-get-quality-speed-top-locations",
		description: `Get the top locations by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "orderBy",
				type: "Query",
				schema: z.enum(["BANDWIDTH_DOWNLOAD", "BANDWIDTH_UPLOAD", "LATENCY_IDLE", "LATENCY_LOADED", "JITTER_IDLE", "JITTER_LOADED"]).optional().default("BANDWIDTH_DOWNLOAD")
			},
			{
				name: "reverse",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()), lastUpdated: z.string() }).passthrough(), top_0: z.array(z.object({ bandwidthDownload: z.string(), bandwidthUpload: z.string(), clientCountryAlpha2: z.string(), clientCountryName: z.string(), jitterIdle: z.string(), jitterLoaded: z.string(), latencyIdle: z.string(), latencyLoaded: z.string(), numTests: z.number(), rankPower: z.number() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 404,
				description: `Not found`,
				schema: z.object({ error: z.string() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/ranking/domain/:domain",
		alias: "radar-get-ranking-domain-details",
		description: `Gets Domains Rank details. 
    Cloudflare provides an ordered rank for the top 100 domains, but for the remainder it only provides ranking buckets
    like top 200 thousand, top one million, etc.. These are available through Radar datasets endpoints.`,
		requestFormat: "json",
		parameters: [
			{
				name: "domain",
				type: "Path",
				schema: z.string().regex(/^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9-]*[A-Za-z0-9])$/)
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "rankingType",
				type: "Query",
				schema: z.enum(["POPULAR", "TRENDING_RISE", "TRENDING_STEADY"]).optional().default("POPULAR")
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "date",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ details_0: z.object({ bucket: z.string().optional(), categories: z.array(z.object({ id: z.number(), name: z.string(), superCategoryId: z.number() }).passthrough()), rank: z.number().int().optional(), top_locations: z.array(z.object({ locationCode: z.string(), locationName: z.string(), rank: z.number().int() }).passthrough()) }).passthrough() }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/ranking/timeseries_groups",
		alias: "radar-get-ranking-domain-timeseries",
		description: `Gets Domains Rank updates change over time. Raw values are returned.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "rankingType",
				type: "Query",
				schema: z.enum(["POPULAR", "TRENDING_RISE", "TRENDING_STEADY"]).optional().default("POPULAR")
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "domains",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()) }).passthrough(), serie_0: z.record(z.array(z.union([z.string(), z.number()]))) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/ranking/top",
		alias: "radar-get-ranking-top-domains",
		description: `Get top or trending domains based on their rank. Popular domains are domains of broad appeal based on how people use the Internet. Trending domains are domains that are generating a surge in interest. For more information on top domains, see https://blog.cloudflare.com/radar-domain-rankings/.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "date",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "rankingType",
				type: "Query",
				schema: z.enum(["POPULAR", "TRENDING_RISE", "TRENDING_STEADY"]).optional().default("POPULAR")
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ top_0: z.object({ date: z.string() }).passthrough() }).passthrough(), top_0: z.array(z.object({ categories: z.array(z.object({ id: z.number(), name: z.string(), superCategoryId: z.number() }).passthrough()), domain: z.string(), pctRankChange: z.number().optional(), rank: z.number().int() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/search/global",
		alias: "radar-get-search-global",
		description: `Lets you search for locations, autonomous systems (AS) and reports.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "limitPerGroup",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "query",
				type: "Query",
				schema: z.string()
			},
			{
				name: "include",
				type: "Query",
				schema: z.array(z.enum(["SPECIAL_EVENTS", "NOTEBOOKS", "LOCATIONS", "ASNS"])).optional()
			},
			{
				name: "exclude",
				type: "Query",
				schema: z.array(z.enum(["SPECIAL_EVENTS", "NOTEBOOKS", "LOCATIONS", "ASNS"])).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ search: z.array(z.object({ code: z.string(), name: z.string(), type: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/traffic_anomalies",
		alias: "radar-get-traffic-anomalies",
		description: `Internet traffic anomalies are signals that might point to an outage,
        These alerts are automatically detected by Radar and then manually verified by our team.
        This endpoint returns the latest alerts.
        `,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "offset",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"]).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "status",
				type: "Query",
				schema: z.enum(["VERIFIED", "UNVERIFIED"]).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ trafficAnomalies: z.array(z.object({ asnDetails: z.object({ asn: z.string(), locations: z.object({ code: z.string(), name: z.string() }).passthrough().optional(), name: z.string() }).passthrough().optional(), endDate: z.string().optional(), locationDetails: z.object({ code: z.string(), name: z.string() }).passthrough().optional(), startDate: z.string(), status: z.string(), type: z.string(), uuid: z.string(), visibleInDataSources: z.array(z.string()).optional() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/traffic_anomalies/locations",
		alias: "radar-get-traffic-anomalies-top",
		description: `Internet traffic anomalies are signals that might point to an outage,
        These alerts are automatically detected by Radar and then manually verified by our team.
        This endpoint returns the sum of alerts grouped by location.
        `,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"]).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "status",
				type: "Query",
				schema: z.enum(["VERIFIED", "UNVERIFIED"]).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ trafficAnomalies: z.array(z.object({ clientCountryAlpha2: z.string(), clientCountryName: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/verified_bots/top/bots",
		alias: "radar-get-verified-bots-top-by-http-requests",
		description: `Get top verified bots by HTTP requests, with owner and category.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()) }).passthrough(), top_0: z.array(z.object({ botCategory: z.string(), botName: z.string(), botOwner: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/radar/verified_bots/top/categories",
		alias: "radar-get-verified-bots-top-categories-by-http-requests",
		description: `Get top verified bot categories by HTTP requests, along with their corresponding percentage, over the total verified bot HTTP requests.`,
		requestFormat: "json",
		parameters: [
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "name",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateRange",
				type: "Query",
				schema: z.array(z.enum(["1d", "2d", "7d", "14d", "28d", "12w", "24w", "52w", "1dControl", "2dControl", "7dControl", "14dControl", "28dControl", "12wControl", "24wControl"])).optional()
			},
			{
				name: "dateStart",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "dateEnd",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "asn",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "location",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "continent",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "format",
				type: "Query",
				schema: z.enum(["JSON", "CSV"]).optional()
			},
		],
		response: z.object({ result: z.object({ meta: z.object({ confidenceInfo: z.object({ annotations: z.array(z.object({ dataSource: z.string(), description: z.string(), endTime: z.string().datetime({ offset: true }).optional(), eventType: z.string(), isInstantaneous: z.object({}).partial().passthrough(), linkedUrl: z.string().optional(), startTime: z.string().datetime({ offset: true }).optional() }).passthrough()), level: z.number().int() }).partial().passthrough().optional(), dateRange: z.array(z.object({ endTime: z.string().datetime({ offset: true }), startTime: z.string().datetime({ offset: true }) }).passthrough()) }).passthrough(), top_0: z.array(z.object({ botCategory: z.string(), value: z.string() }).passthrough()) }).passthrough(), success: z.boolean() }).passthrough(),
		errors: [
			{
				status: 400,
				description: `Bad Request`,
				schema: z.object({ errors: z.array(z.object({ message: z.string() }).passthrough()), result: z.object({}).partial().passthrough(), success: z.boolean() }).passthrough()
			},
		]
	},
	{
		method: "get",
		path: "/user",
		alias: "user-user-details",
		requestFormat: "json",
		response: iam_single_user_response,
		errors: [
			{
				status: NaN,
				description: `User Details response failure`,
				schema: iam_single_user_response.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/user",
		alias: "user-edit-user",
		description: `Edit part of your user details.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ country: iam_country.max(30).nullable(), first_name: iam_first_name.max(60).nullable(), last_name: iam_last_name.max(60).nullable(), telephone: iam_telephone.max(20).nullable(), zipcode: iam_zipcode.max(20).nullable() }).partial().passthrough()
			},
		],
		response: iam_single_user_response,
		errors: [
			{
				status: NaN,
				description: `Edit User response failure`,
				schema: iam_single_user_response.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/audit_logs",
		alias: "audit-logs-get-user-audit-logs",
		description: `Gets a list of audit logs for a user account. Can be filtered by who made the change, on which zone, and the timeframe of the change.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "export",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "action.type",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "actor.ip",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "actor.email",
				type: "Query",
				schema: z.string().email().optional()
			},
			{
				name: "since",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "before",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "zone.name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["desc", "asc"]).optional().default("desc")
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(1000).optional().default(100)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "hide_user_logs",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: aaa_audit_logs_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get user audit logs response failure`,
				schema: aaa_audit_logs_response_collection.and(aaa_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/firewall/access_rules/rules",
		alias: "ip-access-rules-for-a-user-list-ip-access-rules",
		description: `Fetches IP Access rules of the user. You can filter the results using several optional parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "filters",
				type: "Query",
				schema: filters
			},
			{
				name: "egs-pagination.json",
				type: "Query",
				schema: egs_pagination_json
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["configuration.target", "configuration.value", "mode"]).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
		],
		response: legacy_jhs_rule_collection_response,
		errors: [
			{
				status: NaN,
				description: `List IP Access rules response failure`,
				schema: legacy_jhs_rule_collection_response.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/user/firewall/access_rules/rules",
		alias: "ip-access-rules-for-a-user-create-an-ip-access-rule",
		description: `Creates a new IP Access rule for all zones owned by the current user.

Note: To create an IP Access rule that applies to a specific zone, refer to the [IP Access rules for a zone](#ip-access-rules-for-a-zone) endpoints.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ configuration: legacy_jhs_schemas_configuration, mode: legacy_jhs_schemas_mode, notes: legacy_jhs_notes.optional() }).passthrough()
			},
		],
		response: legacy_jhs_rule_single_response,
		errors: [
			{
				status: NaN,
				description: `Create an IP Access rule response failure`,
				schema: legacy_jhs_rule_single_response.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/user/firewall/access_rules/rules/:identifier",
		alias: "ip-access-rules-for-a-user-delete-an-ip-access-rule",
		description: `Deletes an IP Access rule at the user level.

Note: Deleting a user-level rule will affect all zones owned by the user.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_rule_single_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an IP Access rule response failure`,
				schema: legacy_jhs_rule_single_id_response.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/user/firewall/access_rules/rules/:identifier",
		alias: "ip-access-rules-for-a-user-update-an-ip-access-rule",
		description: `Updates an IP Access rule defined at the user level. You can only update the rule action (&#x60;mode&#x60; parameter) and notes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ mode: legacy_jhs_schemas_mode, notes: legacy_jhs_notes }).partial().passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_rule_single_response,
		errors: [
			{
				status: NaN,
				description: `Update an IP Access rule response failure`,
				schema: legacy_jhs_rule_single_response.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/invites",
		alias: "user&#x27;-s-invites-list-invitations",
		description: `Lists all invitations associated with my user.`,
		requestFormat: "json",
		response: iam_schemas_collection_invite_response,
		errors: [
			{
				status: NaN,
				description: `List Invitations response failure`,
				schema: iam_schemas_collection_invite_response.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/invites/:invite_id",
		alias: "user&#x27;-s-invites-invitation-details",
		description: `Gets the details of an invitation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "invite_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: iam_single_invite_response,
		errors: [
			{
				status: NaN,
				description: `Invitation Details response failure`,
				schema: iam_single_invite_response.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/user/invites/:invite_id",
		alias: "user&#x27;-s-invites-respond-to-invitation",
		description: `Responds to an invitation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ status: z.unknown() }).passthrough()
			},
			{
				name: "invite_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: iam_single_invite_response,
		errors: [
			{
				status: NaN,
				description: `Respond to Invitation response failure`,
				schema: iam_single_invite_response.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/load_balancers/monitors",
		alias: "load-balancer-monitors-list-monitors",
		description: `List configured monitors for a user.`,
		requestFormat: "json",
		response: load_balancing_monitor_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Monitors response failure`,
				schema: load_balancing_monitor_response_collection.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/user/load_balancers/monitors",
		alias: "load-balancer-monitors-create-monitor",
		description: `Create a configured monitor.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_load_balancer_monitors_create_monitor_Body
			},
		],
		response: load_balancing_monitor_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Monitor response failure`,
				schema: load_balancing_monitor_response_single.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/user/load_balancers/monitors/:monitor_id",
		alias: "load-balancer-monitors-delete-monitor",
		description: `Delete a configured monitor.`,
		requestFormat: "json",
		parameters: [
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Monitor response failure`,
				schema: load_balancing_id_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/load_balancers/monitors/:monitor_id",
		alias: "load-balancer-monitors-monitor-details",
		description: `List a single configured monitor for a user.`,
		requestFormat: "json",
		parameters: [
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_monitor_response_single,
		errors: [
			{
				status: NaN,
				description: `Monitor Details response failure`,
				schema: load_balancing_monitor_response_single.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/user/load_balancers/monitors/:monitor_id",
		alias: "load-balancer-monitors-patch-monitor",
		description: `Apply changes to an existing monitor, overwriting the supplied properties.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_load_balancer_monitors_create_monitor_Body
			},
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_monitor_response_single,
		errors: [
			{
				status: NaN,
				description: `Patch Monitor response failure`,
				schema: load_balancing_monitor_response_single.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/user/load_balancers/monitors/:monitor_id",
		alias: "load-balancer-monitors-update-monitor",
		description: `Modify a configured monitor.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_load_balancer_monitors_create_monitor_Body
			},
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_monitor_response_single,
		errors: [
			{
				status: NaN,
				description: `Update Monitor response failure`,
				schema: load_balancing_monitor_response_single.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/user/load_balancers/monitors/:monitor_id/preview",
		alias: "load-balancer-monitors-preview-monitor",
		description: `Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_load_balancer_monitors_create_monitor_Body
			},
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_preview_response,
		errors: [
			{
				status: NaN,
				description: `Preview Monitor response failure`,
				schema: load_balancing_preview_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/load_balancers/monitors/:monitor_id/references",
		alias: "load-balancer-monitors-list-monitor-references",
		description: `Get the list of resources that reference the provided monitor.`,
		requestFormat: "json",
		parameters: [
			{
				name: "monitor_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_references_response,
		errors: [
			{
				status: NaN,
				description: `List Monitor References response failure`,
				schema: load_balancing_references_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/load_balancers/pools",
		alias: "load-balancer-pools-list-pools",
		description: `List configured pools.`,
		requestFormat: "json",
		parameters: [
			{
				name: "monitor",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: load_balancing_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Pools response failure`,
				schema: load_balancing_schemas_response_collection.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/user/load_balancers/pools",
		alias: "load-balancer-pools-patch-pools",
		description: `Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending &#x60;name&#x60;. Returns the list of affected pools. Supports the standard pagination query parameters, either &#x60;limit&#x60;/&#x60;offset&#x60; or &#x60;per_page&#x60;/&#x60;page&#x60;.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ notification_email: load_balancing_patch_pools_notification_email }).partial().passthrough()
			},
		],
		response: load_balancing_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `Patch Pools response failure`,
				schema: load_balancing_schemas_response_collection.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/user/load_balancers/pools",
		alias: "load-balancer-pools-create-pool",
		description: `Create a new pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ check_regions: load_balancing_check_regions.nullish(), description: load_balancing_schemas_description.optional(), enabled: load_balancing_enabled.optional().default(true), latitude: load_balancing_latitude.optional(), load_shedding: load_balancing_load_shedding.optional(), longitude: load_balancing_longitude.optional(), minimum_origins: load_balancing_minimum_origins.int().optional().default(1), monitor: load_balancing_monitor_id.optional(), name: load_balancing_name, notification_email: load_balancing_notification_email.optional(), notification_filter: load_balancing_notification_filter.nullish(), origin_steering: load_balancing_origin_steering.optional(), origins: load_balancing_origins }).passthrough()
			},
		],
		response: load_balancing_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create Pool response failure`,
				schema: load_balancing_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/user/load_balancers/pools/:pool_id",
		alias: "load-balancer-pools-delete-pool",
		description: `Delete a configured pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Pool response failure`,
				schema: load_balancing_schemas_id_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/load_balancers/pools/:pool_id",
		alias: "load-balancer-pools-pool-details",
		description: `Fetch a single configured pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Pool Details response failure`,
				schema: load_balancing_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/user/load_balancers/pools/:pool_id",
		alias: "load-balancer-pools-patch-pool",
		description: `Apply changes to an existing pool, overwriting the supplied properties.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ check_regions: load_balancing_check_regions.nullable(), description: load_balancing_schemas_description, disabled_at: load_balancing_schemas_disabled_at.datetime({ offset: true }), enabled: load_balancing_enabled.default(true), latitude: load_balancing_latitude, load_shedding: load_balancing_load_shedding, longitude: load_balancing_longitude, minimum_origins: load_balancing_minimum_origins.int().default(1), monitor: load_balancing_monitor_id, name: load_balancing_name, notification_email: load_balancing_notification_email, notification_filter: load_balancing_notification_filter.nullable(), origin_steering: load_balancing_origin_steering, origins: load_balancing_origins }).partial().passthrough()
			},
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Patch Pool response failure`,
				schema: load_balancing_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/user/load_balancers/pools/:pool_id",
		alias: "load-balancer-pools-update-pool",
		description: `Modify a configured pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ check_regions: load_balancing_check_regions.nullish(), description: load_balancing_schemas_description.optional(), disabled_at: load_balancing_schemas_disabled_at.datetime({ offset: true }).optional(), enabled: load_balancing_enabled.optional().default(true), latitude: load_balancing_latitude.optional(), load_shedding: load_balancing_load_shedding.optional(), longitude: load_balancing_longitude.optional(), minimum_origins: load_balancing_minimum_origins.int().optional().default(1), monitor: load_balancing_monitor_id.optional(), name: load_balancing_name, notification_email: load_balancing_notification_email.optional(), notification_filter: load_balancing_notification_filter.nullish(), origin_steering: load_balancing_origin_steering.optional(), origins: load_balancing_origins }).passthrough()
			},
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Pool response failure`,
				schema: load_balancing_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/load_balancers/pools/:pool_id/health",
		alias: "load-balancer-pools-pool-health-details",
		description: `Fetch the latest pool health status for a single pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_health_details,
		errors: [
			{
				status: NaN,
				description: `Pool Health Details response failure`,
				schema: load_balancing_health_details.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/user/load_balancers/pools/:pool_id/preview",
		alias: "load-balancer-pools-preview-pool",
		description: `Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: account_load_balancer_monitors_create_monitor_Body
			},
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_preview_response,
		errors: [
			{
				status: NaN,
				description: `Preview Pool response failure`,
				schema: load_balancing_preview_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/load_balancers/pools/:pool_id/references",
		alias: "load-balancer-pools-list-pool-references",
		description: `Get the list of resources that reference the provided pool.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pool_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_schemas_references_response,
		errors: [
			{
				status: NaN,
				description: `List Pool References response failure`,
				schema: load_balancing_schemas_references_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/load_balancers/preview/:preview_id",
		alias: "load-balancer-monitors-preview-result",
		description: `Get the result of a previous preview operation using the provided preview_id.`,
		requestFormat: "json",
		parameters: [
			{
				name: "preview_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: load_balancing_preview_result_response,
		errors: [
			{
				status: NaN,
				description: `Preview Result response failure`,
				schema: load_balancing_preview_result_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/load_balancing_analytics/events",
		alias: "load-balancer-healthcheck-events-list-healthcheck-events",
		description: `List origin health changes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "until",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "pool_name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "origin_healthy",
				type: "Query",
				schema: z.boolean().optional().default(true)
			},
			{
				name: "pool_id",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "since",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "origin_name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "pool_healthy",
				type: "Query",
				schema: z.boolean().optional().default(true)
			},
		],
		response: load_balancing_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Healthcheck Events response failure`,
				schema: load_balancing_components_schemas_response_collection.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/organizations",
		alias: "user&#x27;-s-organizations-list-organizations",
		description: `Lists organizations the user is associated with.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.string().max(100).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["id", "name", "status"]).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
			{
				name: "match",
				type: "Query",
				schema: z.enum(["any", "all"]).optional().default("all")
			},
			{
				name: "status",
				type: "Query",
				schema: z.enum(["member", "invited"]).optional()
			},
		],
		response: iam_collection_organization_response,
		errors: [
			{
				status: NaN,
				description: `List Organizations response failure`,
				schema: iam_collection_organization_response.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/user/organizations/:organization_id",
		alias: "user&#x27;-s-organizations-leave-organization",
		description: `Removes association to an organization.`,
		requestFormat: "json",
		parameters: [
			{
				name: "organization_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ id: iam_common_components_schemas_identifier.max(32) }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Leave Organization response failure`,
				schema: z.object({ id: iam_common_components_schemas_identifier.max(32) }).partial().passthrough().and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/organizations/:organization_id",
		alias: "user&#x27;-s-organizations-organization-details",
		description: `Gets a specific organization the user is associated with.`,
		requestFormat: "json",
		parameters: [
			{
				name: "organization_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: iam_single_organization_response,
		errors: [
			{
				status: NaN,
				description: `Organization Details response failure`,
				schema: iam_single_organization_response.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/subscriptions",
		alias: "user-subscription-get-user-subscriptions",
		description: `Lists all of a user&#x27;s subscriptions.`,
		requestFormat: "json",
		response: bill_subs_api_user_subscription_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get User Subscriptions response failure`,
				schema: bill_subs_api_user_subscription_response_collection.and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/user/subscriptions/:identifier",
		alias: "user-subscription-delete-user-subscription",
		description: `Deletes a user&#x27;s subscription.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ subscription_id: bill_subs_api_schemas_identifier.max(32) }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Delete User Subscription response failure`,
				schema: z.object({ subscription_id: bill_subs_api_schemas_identifier.max(32) }).partial().passthrough().and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/user/subscriptions/:identifier",
		alias: "user-subscription-update-user-subscription",
		description: `Updates a user&#x27;s subscriptions.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: bill_subs_api_subscription_v2
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_user_subscription_response_single,
		errors: [
			{
				status: NaN,
				description: `Update User Subscription response failure`,
				schema: bill_subs_api_user_subscription_response_single.and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/tokens",
		alias: "user-api-tokens-list-tokens",
		description: `List all access tokens you created.`,
		requestFormat: "json",
		parameters: [
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
		],
		response: iam_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Tokens response failure`,
				schema: iam_response_collection.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/user/tokens",
		alias: "user-api-tokens-create-token",
		description: `Create a new access token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: iam_create_payload
			},
		],
		response: iam_response_create,
		errors: [
			{
				status: NaN,
				description: `Create Token response failure`,
				schema: iam_response_create.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/user/tokens/:token_id",
		alias: "user-api-tokens-delete-token",
		description: `Destroy a token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "token_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_api_response_single_id,
		errors: [
			{
				status: NaN,
				description: `Delete Token response failure`,
				schema: iam_api_response_single_id.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/tokens/:token_id",
		alias: "user-api-tokens-token-details",
		description: `Get information about a specific token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "token_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_response_single,
		errors: [
			{
				status: NaN,
				description: `Token Details response failure`,
				schema: iam_response_single.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/user/tokens/:token_id",
		alias: "user-api-tokens-update-token",
		description: `Update an existing token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: iam_schemas_token
			},
			{
				name: "token_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_response_single,
		errors: [
			{
				status: NaN,
				description: `Update Token response failure`,
				schema: iam_response_single.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/user/tokens/:token_id/value",
		alias: "user-api-tokens-roll-token",
		description: `Roll the token secret.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({}).partial().passthrough()
			},
			{
				name: "token_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: iam_response_single_value,
		errors: [
			{
				status: NaN,
				description: `Roll Token response failure`,
				schema: iam_response_single_value.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/tokens/permission_groups",
		alias: "permission-groups-list-permission-groups",
		description: `Find all available permission groups.`,
		requestFormat: "json",
		response: iam_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Permission Groups response failure`,
				schema: iam_schemas_response_collection.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/user/tokens/verify",
		alias: "user-api-tokens-verify-token",
		description: `Test whether a token works.`,
		requestFormat: "json",
		response: iam_response_single_segment,
		errors: [
			{
				status: NaN,
				description: `Verify Token response failure`,
				schema: iam_response_single_segment.and(iam_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones",
		alias: "zones-get",
		description: `Lists, searches, sorts, and filters your zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "name",
				type: "Query",
				schema: z.string().max(253).optional()
			},
			{
				name: "status",
				type: "Query",
				schema: z.enum(["initializing", "pending", "active", "moved"]).optional()
			},
			{
				name: "account.id",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "account.name",
				type: "Query",
				schema: z.string().max(253).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["name", "status", "account.id", "account.name"]).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
			{
				name: "match",
				type: "Query",
				schema: z.enum(["any", "all"]).optional().default("all")
			},
		],
		response: zones_api_response_common.and(z.object({ result_info: zones_result_info }).partial().passthrough()).and(z.object({ result: z.array(zones_zone) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Zones response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones",
		alias: "zones-post",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zones_post_Body
			},
		],
		response: zones_api_response_common.and(z.object({ result: zones_zone }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create Zone response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/apps",
		alias: "zone-level-access-applications-list-access-applications",
		description: `List all Access Applications in a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_apps_components_schemas_response_collection_2,
		errors: [
			{
				status: NaN,
				description: `List Access Applications response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/access/apps",
		alias: "zone-level-access-applications-add-a-bookmark-application",
		description: `Adds a new application to Access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_schemas_apps
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_apps_components_schemas_single_response_2.and(z.object({ result: access_schemas_apps }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Add an Access application response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:identifier/access/apps/:app_id",
		alias: "zone-level-access-applications-delete-an-access-application",
		description: `Deletes an application from Access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: app_id
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an Access application response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/apps/:app_id",
		alias: "zone-level-access-applications-get-an-access-application",
		description: `Fetches information about an Access application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: app_id
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_apps_components_schemas_single_response_2,
		errors: [
			{
				status: NaN,
				description: `Get an Access application response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:identifier/access/apps/:app_id",
		alias: "zone-level-access-applications-update-a-bookmark-application",
		description: `Updates an Access application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_schemas_apps
			},
			{
				name: "app_id",
				type: "Path",
				schema: app_id
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_apps_components_schemas_single_response_2.and(z.object({ result: access_schemas_apps }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update an Access application response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/access/apps/:app_id/revoke_tokens",
		alias: "zone-level-access-applications-revoke-service-tokens",
		description: `Revokes all tokens issued for an application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: app_id
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ result: z.object({}).partial().passthrough().nullable(), success: z.union([z.literal(true), z.literal(false)]) }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Revoke application tokens response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/apps/:app_id/user_policy_checks",
		alias: "zone-level-access-applications-test-access-policies",
		description: `Tests if a specific user has permission to access an application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: app_id
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_policy_check_response,
		errors: [
			{
				status: NaN,
				description: `Test Access policies response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:identifier/access/apps/:uuid/ca",
		alias: "zone-level-access-short-lived-certificate-c-as-delete-a-short-lived-certificate-ca",
		description: `Deletes a short-lived certificate CA.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete a short-lived certificate CA response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/apps/:uuid/ca",
		alias: "zone-level-access-short-lived-certificate-c-as-get-a-short-lived-certificate-ca",
		description: `Fetches a short-lived certificate CA and its public key.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_ca_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get a short-lived certificate CA response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/access/apps/:uuid/ca",
		alias: "zone-level-access-short-lived-certificate-c-as-create-a-short-lived-certificate-ca",
		description: `Generates a new short-lived certificate CA and public key.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_ca_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create a short-lived certificate CA response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/apps/:uuid/policies",
		alias: "zone-level-access-policies-list-access-policies",
		description: `Lists Access policies configured for an application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_policies_components_schemas_response_collection_2,
		errors: [
			{
				status: NaN,
				description: `List Access policies response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/access/apps/:uuid/policies",
		alias: "zone-level-access-policies-create-an-access-policy",
		description: `Create a new Access policy for an application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ approval_groups: access_approval_groups.optional(), approval_required: access_approval_required.optional(), decision: access_decision, exclude: access_schemas_exclude.optional(), include: access_include, isolation_required: access_schemas_isolation_required.optional(), name: access_policies_components_schemas_name, precedence: access_precedence.int().optional(), purpose_justification_prompt: access_purpose_justification_prompt.optional(), purpose_justification_required: access_purpose_justification_required.optional(), require: access_schemas_require.optional() }).passthrough()
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_policies_components_schemas_single_response_2,
		errors: [
			{
				status: NaN,
				description: `Create an Access policy response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:identifier/access/apps/:uuid1/policies/:uuid",
		alias: "zone-level-access-policies-delete-an-access-policy",
		description: `Delete an Access policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "uuid1",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an Access policy response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/apps/:uuid1/policies/:uuid",
		alias: "zone-level-access-policies-get-an-access-policy",
		description: `Fetches a single Access policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "uuid1",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_policies_components_schemas_single_response_2,
		errors: [
			{
				status: NaN,
				description: `Get an Access policy response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:identifier/access/apps/:uuid1/policies/:uuid",
		alias: "zone-level-access-policies-update-an-access-policy",
		description: `Update a configured Access policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ approval_groups: access_approval_groups.optional(), approval_required: access_approval_required.optional(), decision: access_decision, exclude: access_schemas_exclude.optional(), include: access_include, isolation_required: access_schemas_isolation_required.optional(), name: access_policies_components_schemas_name, precedence: access_precedence.int().optional(), purpose_justification_prompt: access_purpose_justification_prompt.optional(), purpose_justification_required: access_purpose_justification_required.optional(), require: access_schemas_require.optional() }).passthrough()
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "uuid1",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_policies_components_schemas_single_response_2,
		errors: [
			{
				status: NaN,
				description: `Update an Access policy response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/apps/ca",
		alias: "zone-level-access-short-lived-certificate-c-as-list-short-lived-certificate-c-as",
		description: `Lists short-lived certificate CAs and their public keys.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_ca_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List short-lived certificate CAs response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/certificates",
		alias: "zone-level-access-mtls-authentication-list-mtls-certificates",
		description: `Lists all mTLS certificates.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_certificates_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List mTLS certificates response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/access/certificates",
		alias: "zone-level-access-mtls-authentication-add-an-mtls-certificate",
		description: `Adds a new mTLS root certificate to Access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ associated_hostnames: access_associated_hostnames.optional(), certificate: z.string(), name: access_certificates_components_schemas_name }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_certificates_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Add an mTLS certificate response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:identifier/access/certificates/:uuid",
		alias: "zone-level-access-mtls-authentication-delete-an-mtls-certificate",
		description: `Deletes an mTLS certificate.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_components_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an mTLS certificate response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/certificates/:uuid",
		alias: "zone-level-access-mtls-authentication-get-an-mtls-certificate",
		description: `Fetches a single mTLS certificate.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_certificates_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get an mTLS certificate response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:identifier/access/certificates/:uuid",
		alias: "zone-level-access-mtls-authentication-update-an-mtls-certificate",
		description: `Updates a configured mTLS certificate.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ associated_hostnames: access_associated_hostnames, name: access_certificates_components_schemas_name.optional() }).passthrough()
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_certificates_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update an mTLS certificate response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/certificates/settings",
		alias: "zone-level-access-mtls-authentication-list-mtls-certificates-hostname-settings",
		description: `List all mTLS hostname settings for this zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_response_collection_hostnames,
		errors: [
			{
				status: NaN,
				description: `List mTLS hostname settings response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:identifier/access/certificates/settings",
		alias: "zone-level-access-mtls-authentication-update-an-mtls-certificate-settings",
		description: `Updates an mTLS certificate&#x27;s hostname settings.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_mtls_authentication_update_an_mtls_certificate_settings_Body
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_response_collection_hostnames,
		errors: [
			{
				status: NaN,
				description: `Update an mTLS certificates hostname settings failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/groups",
		alias: "zone-level-access-groups-list-access-groups",
		description: `Lists all Access groups.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_groups_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Access groups response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/access/groups",
		alias: "zone-level-access-groups-create-an-access-group",
		description: `Creates a new Access group.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ exclude: access_exclude.optional(), include: access_include, name: access_components_schemas_name, require: access_require.optional() }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_groups_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create an Access group response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:identifier/access/groups/:uuid",
		alias: "zone-level-access-groups-delete-an-access-group",
		description: `Deletes an Access group.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an Access group response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/groups/:uuid",
		alias: "zone-level-access-groups-get-an-access-group",
		description: `Fetches a single Access group.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_groups_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get an Access group response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:identifier/access/groups/:uuid",
		alias: "zone-level-access-groups-update-an-access-group",
		description: `Updates a configured Access group.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ exclude: access_exclude.optional(), include: access_include, name: access_components_schemas_name, require: access_require.optional() }).passthrough()
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_groups_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update an Access group response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/identity_providers",
		alias: "zone-level-access-identity-providers-list-access-identity-providers",
		description: `Lists all configured identity providers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_identity_providers_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Access identity providers response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/access/identity_providers",
		alias: "zone-level-access-identity-providers-add-an-access-identity-provider",
		description: `Adds a new identity provider to Access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_schemas_identity_providers
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_identity_providers_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Add an Access identity provider response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:identifier/access/identity_providers/:uuid",
		alias: "zone-level-access-identity-providers-delete-an-access-identity-provider",
		description: `Deletes an identity provider from Access.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an Access identity provider response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/identity_providers/:uuid",
		alias: "zone-level-access-identity-providers-get-an-access-identity-provider",
		description: `Fetches a configured identity provider.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_identity_providers_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get an Access identity provider response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:identifier/access/identity_providers/:uuid",
		alias: "zone-level-access-identity-providers-update-an-access-identity-provider",
		description: `Updates a configured identity provider.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: access_schemas_identity_providers
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_identity_providers_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update an Access identity provider response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/organizations",
		alias: "zone-level-zero-trust-organization-get-your-zero-trust-organization",
		description: `Returns the configuration for your Zero Trust organization.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: access_organizations_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Get your Zero Trust organization response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/access/organizations",
		alias: "zone-level-zero-trust-organization-create-your-zero-trust-organization",
		description: `Sets up a Zero Trust organization for your account.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ auth_domain: access_auth_domain, is_ui_read_only: access_is_ui_read_only.optional(), login_design: access_login_design.optional(), name: access_name, ui_read_only_toggle_reason: access_ui_read_only_toggle_reason.optional(), user_seat_expiration_inactive_time: access_user_seat_expiration_inactive_time.optional() }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: access_organizations_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create your Zero Trust organization response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:identifier/access/organizations",
		alias: "zone-level-zero-trust-organization-update-your-zero-trust-organization",
		description: `Updates the configuration for your Zero Trust organization.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ auth_domain: access_auth_domain, is_ui_read_only: access_is_ui_read_only, login_design: access_login_design, name: access_name, ui_read_only_toggle_reason: access_ui_read_only_toggle_reason, user_seat_expiration_inactive_time: access_user_seat_expiration_inactive_time }).partial().passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: access_organizations_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update your Zero Trust organization response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/access/organizations/revoke_user",
		alias: "zone-level-zero-trust-organization-revoke-all-access-tokens-for-a-user",
		description: `Revokes a user&#x27;s access across all applications.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ email: z.string() }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: z.object({ result: z.union([z.literal(true), z.literal(false)]), success: z.union([z.literal(true), z.literal(false)]) }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Revoke all Access tokens for a user response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/access/service_tokens",
		alias: "zone-level-access-service-tokens-list-service-tokens",
		description: `Lists all service tokens.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List service tokens response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/access/service_tokens",
		alias: "zone-level-access-service-tokens-create-a-service-token",
		description: `Generates a new service token. **Note:** This is the only time you can get the Client Secret. If you lose the Client Secret, you will have to create a new service token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ duration: access_duration.optional(), name: access_service_tokens_components_schemas_name }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_create_response,
		errors: [
			{
				status: NaN,
				description: `Create a service token response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:identifier/access/service_tokens/:uuid",
		alias: "zone-level-access-service-tokens-delete-a-service-token",
		description: `Deletes a service token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_service_tokens_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Delete a service token response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:identifier/access/service_tokens/:uuid",
		alias: "zone-level-access-service-tokens-update-a-service-token",
		description: `Updates a configured service token.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ duration: access_duration, name: access_service_tokens_components_schemas_name }).partial().passthrough()
			},
			{
				name: "uuid",
				type: "Path",
				schema: z.string().max(36)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: access_service_tokens_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update a service token response failure`,
				schema: access_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/dns_analytics/report",
		alias: "dns-analytics-table",
		description: `Retrieves a list of summarised aggregate metrics over a given time period.

See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "metrics",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "dimensions",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "since",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "until",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional().default(100000)
			},
			{
				name: "sort",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "filters",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: dns_dns_analytics_api_api_response_single.and(z.object({ result: dns_dns_analytics_api_report }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Table response failure`,
				schema: dns_dns_analytics_api_api_response_single.and(z.object({ result: dns_dns_analytics_api_report }).partial().passthrough()).and(dns_dns_analytics_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/dns_analytics/report/bytime",
		alias: "dns-analytics-by-time",
		description: `Retrieves a list of aggregate metrics grouped by time interval.

See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "metrics",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "dimensions",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "since",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "until",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional().default(100000)
			},
			{
				name: "sort",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "filters",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "time_delta",
				type: "Query",
				schema: z.enum(["all", "auto", "year", "quarter", "month", "week", "day", "hour", "dekaminute", "minute"]).optional()
			},
		],
		response: dns_dns_analytics_api_api_response_single.and(z.object({ result: dns_dns_analytics_api_report_bytime }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `By Time response failure`,
				schema: dns_dns_analytics_api_api_response_single.and(z.object({ result: dns_dns_analytics_api_report_bytime }).partial().passthrough()).and(dns_dns_analytics_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:identifier/subscription",
		alias: "zone-subscription-zone-subscription-details",
		description: `Lists zone subscription details.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_zone_subscription_response_single,
		errors: [
			{
				status: NaN,
				description: `Zone Subscription Details response failure`,
				schema: bill_subs_api_zone_subscription_response_single.and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:identifier/subscription",
		alias: "zone-subscription-create-zone-subscription",
		description: `Create a zone subscription, either plan or add-ons.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: bill_subs_api_subscription_v2
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_zone_subscription_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Zone Subscription response failure`,
				schema: bill_subs_api_zone_subscription_response_single.and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:identifier/subscription",
		alias: "zone-subscription-update-zone-subscription",
		description: `Updates zone subscriptions, either plan or add-ons.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: bill_subs_api_subscription_v2
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_zone_subscription_response_single,
		errors: [
			{
				status: NaN,
				description: `Update Zone Subscription response failure`,
				schema: bill_subs_api_zone_subscription_response_single.and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id",
		alias: "zones-0-delete",
		description: `Deletes an existing zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_api_response_single_id,
		errors: [
			{
				status: NaN,
				description: `Delete Zone response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id",
		alias: "zones-0-get",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_api_response_common.and(z.object({ result: zones_zone }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Zone Details response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id",
		alias: "zones-0-patch",
		description: `Edits a zone. Only one zone property can be changed at a time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zones_0_patch_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_api_response_common.and(z.object({ result: zones_zone }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Edit Zone response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/acm/total_tls",
		alias: "total-tls-total-tls-settings-details",
		description: `Get Total TLS Settings for a Zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_total_tls_settings_response,
		errors: [
			{
				status: NaN,
				description: `Total TLS Settings Details response failure`,
				schema: tls_certificates_and_hostnames_total_tls_settings_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/acm/total_tls",
		alias: "total-tls-enable-or-disable-total-tls",
		description: `Set Total TLS Settings or disable the feature for a Zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ certificate_authority: tls_certificates_and_hostnames_components_schemas_certificate_authority.optional(), enabled: tls_certificates_and_hostnames_components_schemas_enabled }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_total_tls_settings_response,
		errors: [
			{
				status: NaN,
				description: `Enable or Disable Total TLS response failure`,
				schema: tls_certificates_and_hostnames_total_tls_settings_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/activation_check",
		alias: "put-zones-zone_id-activation_check",
		description: `Triggeres a new activation check for a PENDING Zone. This can be
triggered every 5 min for paygo/ent customers, every hour for FREE
Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zone_activation_api_response_single.and(z.object({ result: z.object({ id: zone_activation_identifier.max(32) }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Client Error`,
				schema: zone_activation_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/analytics/latency",
		alias: "argo-analytics-for-zone-argo-analytics-for-a-zone",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "bins",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: argo_analytics_response_single,
		errors: [
			{
				status: NaN,
				description: `Argo Analytics for a zone response failure`,
				schema: argo_analytics_response_single.and(argo_analytics_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/analytics/latency/colos",
		alias: "argo-analytics-for-geolocation-argo-analytics-for-a-zone-at-different-po-ps",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: argo_analytics_response_single,
		errors: [
			{
				status: NaN,
				description: `Argo Analytics for a zone at different PoPs response failure`,
				schema: argo_analytics_response_single.and(argo_analytics_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/configuration",
		alias: "api-shield-settings-retrieve-information-about-specific-configuration-properties",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "properties",
				type: "Query",
				schema: z.array(z.literal("auth_id_characteristics")).optional()
			},
		],
		response: api_shield_single_response,
		errors: [
			{
				status: NaN,
				description: `Retrieve information about specific configuration properties response failure`,
				schema: api_shield_single_response.and(api_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/api_gateway/configuration",
		alias: "api-shield-settings-set-configuration-properties",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: api_shield_configuration
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: api_shield_default_response,
		errors: [
			{
				status: NaN,
				description: `Set configuration properties response failure`,
				schema: api_shield_default_response.and(api_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/discovery",
		alias: "api-shield-api-discovery-retrieve-discovered-operations-on-a-zone-as-openapi",
		description: `Retrieve the most up to date view of discovered operations, rendered as OpenAPI schemas`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: api_shield_schema_response_discovery,
		errors: [
			{
				status: NaN,
				description: `Retrieve discovered operations on a zone, rendered as OpenAPI schemas response failure`,
				schema: api_shield_schema_response_discovery.and(api_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/discovery/operations",
		alias: "api-shield-api-discovery-retrieve-discovered-operations-on-a-zone",
		description: `Retrieve the most up to date view of discovered operations`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.unknown().optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.unknown().optional().default(20)
			},
			{
				name: "host",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "method",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "endpoint",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["host", "method", "endpoint", "traffic_stats.requests", "traffic_stats.last_updated"]).optional()
			},
			{
				name: "diff",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "origin",
				type: "Query",
				schema: z.enum(["ML", "SessionIdentifier"]).optional()
			},
			{
				name: "state",
				type: "Query",
				schema: z.enum(["review", "saved", "ignored"]).optional()
			},
		],
		response: api_shield_api_response_collection.and(z.object({ result: z.array(api_shield_discovery_operation) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Retrieve discovered operations on a zone response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/api_gateway/discovery/operations",
		alias: "api-shield-api-patch-discovered-operations",
		description: `Update the &#x60;state&#x60; on one or more discovered operations`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.record(api_shield_api_discovery_patch_multiple_request_entry)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: api_shield_patch_discoveries_response,
		errors: [
			{
				status: NaN,
				description: `Patch discovered operations response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/api_gateway/discovery/operations/:operation_id",
		alias: "api-shield-api-patch-discovered-operation",
		description: `Update the &#x60;state&#x60; on a discovered operation`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: api_shield_api_patch_discovered_operation_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "operation_id",
				type: "Path",
				schema: z.string().max(36).uuid()
			},
		],
		response: api_shield_patch_discovery_response,
		errors: [
			{
				status: NaN,
				description: `Patch discovered operation response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/operations",
		alias: "api-shield-endpoint-management-retrieve-information-about-all-operations-on-a-zone",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.unknown().optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).optional().default(20)
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["method", "host", "endpoint", "thresholds.$key"]).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
			{
				name: "host",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "method",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "endpoint",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "feature",
				type: "Query",
				schema: z.array(z.enum(["thresholds", "parameter_schemas", "schema_info"])).optional()
			},
		],
		response: api_shield_collection_response_paginated,
		errors: [
			{
				status: NaN,
				description: `Retrieve information about all operations on a zone response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/api_gateway/operations",
		alias: "api-shield-endpoint-management-add-operations-to-a-zone",
		description: `Add one or more operations to a zone. Endpoints can contain path variables. Host, method, endpoint will be normalized to a canoncial form when creating an operation and must be unique on the zone. Inserting an operation that matches an existing one will return the record of the already existing operation and update its last_updated date.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(api_shield_basic_operation)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: api_shield_collection_response,
		errors: [
			{
				status: NaN,
				description: `Add operations to a zone response failure`,
				schema: api_shield_collection_response.and(api_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/api_gateway/operations/:operation_id",
		alias: "api-shield-endpoint-management-delete-an-operation",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "operation_id",
				type: "Path",
				schema: z.string().max(36).uuid()
			},
		],
		response: api_shield_default_response,
		errors: [
			{
				status: NaN,
				description: `Delete an operation response failure`,
				schema: api_shield_default_response.and(api_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/operations/:operation_id",
		alias: "api-shield-endpoint-management-retrieve-information-about-an-operation",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "operation_id",
				type: "Path",
				schema: z.string().max(36).uuid()
			},
			{
				name: "feature",
				type: "Query",
				schema: z.array(z.enum(["thresholds", "parameter_schemas", "schema_info"])).optional()
			},
		],
		response: api_shield_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Retrieve information about an operation response failure`,
				schema: api_shield_schemas_single_response.and(api_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/operations/:operation_id/schema_validation",
		alias: "api-shield-schema-validation-retrieve-operation-level-settings",
		description: `Retrieves operation-level schema validation settings on the zone`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "operation_id",
				type: "Path",
				schema: z.string().max(36).uuid()
			},
		],
		response: api_shield_operation_schema_validation_settings,
		errors: [
			{
				status: NaN,
				description: `Operation-level schema validation settings response`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/api_gateway/operations/:operation_id/schema_validation",
		alias: "api-shield-schema-validation-update-operation-level-settings",
		description: `Updates operation-level schema validation settings on the zone`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: api_shield_operation_schema_validation_settings
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "operation_id",
				type: "Path",
				schema: z.string().max(36).uuid()
			},
		],
		response: api_shield_operation_schema_validation_settings,
		errors: [
			{
				status: NaN,
				description: `Update operation-level schema validation settings response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/api_gateway/operations/schema_validation",
		alias: "api-shield-schema-validation-update-multiple-operation-level-settings",
		description: `Updates multiple operation-level schema validation settings on the zone`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.record(api_shield_operation_schema_validation_settings_multiple_request_entry)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: api_shield_api_response_single.and(z.object({ result: api_shield_operation_schema_validation_settings_multiple_request }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update multiple operation-level schema validation settings response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/schemas",
		alias: "api-shield-endpoint-management-retrieve-operations-and-features-as-open-api-schemas",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "host",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "feature",
				type: "Query",
				schema: z.array(z.enum(["thresholds", "parameter_schemas", "schema_info"])).optional()
			},
		],
		response: api_shield_schema_response_with_thresholds,
		errors: [
			{
				status: NaN,
				description: `Retrieve operations and features as OpenAPI schemas response failure`,
				schema: api_shield_schema_response_with_thresholds.and(api_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/settings/schema_validation",
		alias: "api-shield-schema-validation-retrieve-zone-level-settings",
		description: `Retrieves zone level schema validation settings currently set on the zone`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: api_shield_zone_schema_validation_settings,
		errors: [
			{
				status: NaN,
				description: `Zone level schema validation settings response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/api_gateway/settings/schema_validation",
		alias: "api-shield-schema-validation-patch-zone-level-settings",
		description: `Updates zone level schema validation settings on the zone`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: api_shield_zone_schema_validation_settings_patch
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: api_shield_zone_schema_validation_settings,
		errors: [
			{
				status: NaN,
				description: `Update zone level schema validation settings response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/api_gateway/settings/schema_validation",
		alias: "api-shield-schema-validation-update-zone-level-settings",
		description: `Updates zone level schema validation settings on the zone`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: api_shield_zone_schema_validation_settings_put
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: api_shield_zone_schema_validation_settings,
		errors: [
			{
				status: NaN,
				description: `Update zone level schema validation settings response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/user_schemas",
		alias: "api-shield-schema-validation-retrieve-information-about-all-schemas",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.unknown().optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.unknown().optional().default(20)
			},
			{
				name: "omit_source",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "validation_enabled",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: api_shield_api_response_collection.and(z.object({ result: z.array(api_shield_public_schema) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Retrieve information about all schemas on a zone response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/api_gateway/user_schemas",
		alias: "api-shield-schema-validation-post-schema",
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: api_shield_schema_validation_post_schema_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: api_shield_api_response_single.and(z.object({ result: api_shield_schema_upload_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Upload a schema response failure`,
				schema: api_shield_schema_upload_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/api_gateway/user_schemas/:schema_id",
		alias: "api-shield-schema-delete-a-schema",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "schema_id",
				type: "Path",
				schema: z.string().max(36).uuid()
			},
		],
		response: api_shield_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete a schema response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/user_schemas/:schema_id",
		alias: "api-shield-schema-validation-retrieve-information-about-specific-schema",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "schema_id",
				type: "Path",
				schema: z.string().max(36).uuid()
			},
			{
				name: "omit_source",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: api_shield_api_response_single.and(z.object({ result: api_shield_public_schema }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Retrieve information about a specific schema zone response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/api_gateway/user_schemas/:schema_id",
		alias: "api-shield-schema-validation-enable-validation-for-a-schema",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: api_shield_schema_validation_enable_validation_for_a_schema_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "schema_id",
				type: "Path",
				schema: z.string().max(36).uuid()
			},
		],
		response: api_shield_api_response_single.and(z.object({ result: api_shield_public_schema }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Enable validation for a schema response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/api_gateway/user_schemas/:schema_id/operations",
		alias: "api-shield-schema-validation-extract-operations-from-schema",
		description: `Retrieves all operations from the schema. Operations that already exist in API Shield Endpoint Management will be returned as full operations.`,
		requestFormat: "json",
		parameters: [
			{
				name: "schema_id",
				type: "Path",
				schema: z.string().max(36).uuid()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "feature",
				type: "Query",
				schema: z.array(z.enum(["thresholds", "parameter_schemas", "schema_info"])).optional()
			},
			{
				name: "host",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "method",
				type: "Query",
				schema: z.array(z.string()).optional()
			},
			{
				name: "endpoint",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.unknown().optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.unknown().optional().default(20)
			},
			{
				name: "operation_status",
				type: "Query",
				schema: z.enum(["new", "existing"]).optional()
			},
		],
		response: api_shield_api_response_collection.and(z.object({ result: z.array(z.union([api_shield_operation, api_shield_basic_operation])) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Retrieve all operations from a schema response failure`,
				schema: api_shield_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/argo/smart_routing",
		alias: "argo-smart-routing-get-argo-smart-routing-setting",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: argo_config_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Argo Smart Routing setting response failure`,
				schema: argo_config_response_single.and(argo_config_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/argo/smart_routing",
		alias: "argo-smart-routing-patch-argo-smart-routing-setting",
		description: `Updates enablement of Argo Smart Routing.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: argo_config_patch
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: argo_config_response_single,
		errors: [
			{
				status: NaN,
				description: `Patch Argo Smart Routing setting response failure`,
				schema: argo_config_response_single.and(argo_config_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/argo/tiered_caching",
		alias: "tiered-caching-get-tiered-caching-setting",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Tiered Caching setting response failure`,
				schema: cache_response_single.and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/argo/tiered_caching",
		alias: "tiered-caching-patch-tiered-caching-setting",
		description: `Updates enablement of Tiered Caching`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cache_patch
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_response_single,
		errors: [
			{
				status: NaN,
				description: `Patch Tiered Caching setting response failure`,
				schema: cache_response_single.and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/bot_management",
		alias: "bot-management-for-a-zone-get-config",
		description: `Retrieve a zone&#x27;s Bot Management Config`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bot_management_bot_management_response_body,
		errors: [
			{
				status: NaN,
				description: `Bot Management config response failure`,
				schema: bot_management_bot_management_response_body.and(bot_management_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/bot_management",
		alias: "bot-management-for-a-zone-update-config",
		description: `Updates the Bot Management configuration for a zone.

This API is used to update:
- **Bot Fight Mode**
- **Super Bot Fight Mode**
- **Bot Management for Enterprise**

See [Bot Plans](https://developers.cloudflare.com/bots/plans/) for more information on the different plans
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: bot_management_config_single
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bot_management_bot_management_response_body,
		errors: [
			{
				status: NaN,
				description: `Update Bot Management response failure`,
				schema: bot_management_bot_management_response_body.and(bot_management_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/cache/cache_reserve",
		alias: "zone-cache-settings-get-cache-reserve-setting",
		description: `Increase cache lifetimes by automatically storing all cacheable files into Cloudflare&#x27;s persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_cache_reserve_response_value),
		errors: [
			{
				status: NaN,
				description: `Get Cache Reserve setting response failure`,
				schema: cache_zone_cache_settings_response_single.and(cache_cache_reserve_response_value).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/cache/cache_reserve",
		alias: "zone-cache-settings-change-cache-reserve-setting",
		description: `Increase cache lifetimes by automatically storing all cacheable files into Cloudflare&#x27;s persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: cache_cache_reserve_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_cache_reserve_response_value),
		errors: [
			{
				status: NaN,
				description: `Change Cache Reserve setting response failure`,
				schema: cache_zone_cache_settings_response_single.and(cache_cache_reserve_response_value).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/cache/cache_reserve_clear",
		alias: "zone-cache-settings-get-cache-reserve-clear",
		description: `You can use Cache Reserve Clear to clear your Cache Reserve, but you must first disable Cache Reserve. In most cases, this will be accomplished within 24 hours. You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind that you cannot undo or cancel this operation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_cache_reserve_clear_response_value),
		errors: [
			{
				status: NaN,
				description: `Get Cache Reserve Clear failure response`,
				schema: cache_zone_cache_settings_response_single.and(cache_cache_reserve_clear_response_value).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/cache/cache_reserve_clear",
		alias: "zone-cache-settings-start-cache-reserve-clear",
		description: `You can use Cache Reserve Clear to clear your Cache Reserve, but you must first disable Cache Reserve. In most cases, this will be accomplished within 24 hours. You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind that you cannot undo or cancel this operation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_cache_reserve_clear_response_value),
		errors: [
			{
				status: NaN,
				description: `Start Cache Reserve Clear failure response`,
				schema: cache_zone_cache_settings_response_single.and(cache_cache_reserve_clear_response_value).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/cache/origin_post_quantum_encryption",
		alias: "zone-cache-settings-get-origin-post-quantum-encryption-setting",
		description: `Instructs Cloudflare to use Post-Quantum (PQ) key agreement algorithms when connecting to your origin. Preferred instructs Cloudflare to opportunistically send a Post-Quantum keyshare in the first message to the origin (for fastest connections when the origin supports and prefers PQ), supported means that PQ algorithms are advertised but only used when requested by the origin, and off means that PQ algorithms are not advertised`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_origin_post_quantum_encryption_value),
		errors: [
			{
				status: NaN,
				description: `Get Origin Post-Quantum Encryption setting response failure`,
				schema: cache_origin_post_quantum_encryption_value.and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/cache/origin_post_quantum_encryption",
		alias: "zone-cache-settings-change-origin-post-quantum-encryption-setting",
		description: `Instructs Cloudflare to use Post-Quantum (PQ) key agreement algorithms when connecting to your origin. Preferred instructs Cloudflare to opportunistically send a Post-Quantum keyshare in the first message to the origin (for fastest connections when the origin supports and prefers PQ), supported means that PQ algorithms are advertised but only used when requested by the origin, and off means that PQ algorithms are not advertised`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: cache_origin_post_quantum_encryption_value.default("supported") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_origin_post_quantum_encryption_value),
		errors: [
			{
				status: NaN,
				description: `Change Origin Post-Quantum Encryption setting response failure`,
				schema: cache_origin_post_quantum_encryption_value.and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/cache/regional_tiered_cache",
		alias: "zone-cache-settings-get-regional-tiered-cache-setting",
		description: `Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_regional_tiered_cache_response_value),
		errors: [
			{
				status: NaN,
				description: `Get Regional Tiered Cache setting response failure`,
				schema: cache_zone_cache_settings_response_single.and(cache_regional_tiered_cache_response_value).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/cache/regional_tiered_cache",
		alias: "zone-cache-settings-change-regional-tiered-cache-setting",
		description: `Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: cache_regional_tiered_cache_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_regional_tiered_cache_response_value),
		errors: [
			{
				status: NaN,
				description: `Change Regional Tiered Cache setting response failure`,
				schema: cache_zone_cache_settings_response_single.and(cache_regional_tiered_cache_response_value).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/cache/tiered_cache_smart_topology_enable",
		alias: "smart-tiered-cache-delete-smart-tiered-cache-setting",
		description: `Remvoves enablement of Smart Tiered Cache`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete Smart Tiered Cache setting response failure`,
				schema: cache_response_single.and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/cache/tiered_cache_smart_topology_enable",
		alias: "smart-tiered-cache-get-smart-tiered-cache-setting",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Smart Tiered Cache setting response failure`,
				schema: cache_response_single.and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/cache/tiered_cache_smart_topology_enable",
		alias: "smart-tiered-cache-patch-smart-tiered-cache-setting",
		description: `Updates enablement of Tiered Cache`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: cache_schemas_patch
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_response_single,
		errors: [
			{
				status: NaN,
				description: `Patch Smart Tiered Cache setting response failure`,
				schema: cache_response_single.and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/cache/variants",
		alias: "zone-cache-settings-delete-variants-setting",
		description: `Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the &#x27;Vary: Accept&#x27; response header. If the origin server sends &#x27;Vary: Accept&#x27; but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(z.object({ result: cache_variants }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete variants setting response failure`,
				schema: cache_zone_cache_settings_response_single.and(z.object({ result: cache_variants }).partial().passthrough()).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/cache/variants",
		alias: "zone-cache-settings-get-variants-setting",
		description: `Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the &#x27;Vary: Accept&#x27; response header. If the origin server sends &#x27;Vary: Accept&#x27; but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_variants_response_value),
		errors: [
			{
				status: NaN,
				description: `Get variants setting response failure`,
				schema: cache_zone_cache_settings_response_single.and(cache_variants_response_value).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/cache/variants",
		alias: "zone-cache-settings-change-variants-setting",
		description: `Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the &#x27;Vary: Accept&#x27; response header. If the origin server sends &#x27;Vary: Accept&#x27; but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: cache_variants_value }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_variants_response_value),
		errors: [
			{
				status: NaN,
				description: `Change variants setting response failure`,
				schema: cache_zone_cache_settings_response_single.and(cache_variants_response_value).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/certificate_authorities/hostname_associations",
		alias: "client-certificate-for-a-zone-list-hostname-associations",
		description: `List Hostname Associations`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "mtls_certificate_id",
				type: "Query",
				schema: z.string().min(36).max(36).optional()
			},
		],
		response: tls_certificates_and_hostnames_hostname_associations_response,
		errors: [
			{
				status: NaN,
				description: `List Hostname Associations Response Failure`,
				schema: tls_certificates_and_hostnames_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/certificate_authorities/hostname_associations",
		alias: "client-certificate-for-a-zone-put-hostname-associations",
		description: `Replace Hostname Associations`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: tls_certificates_and_hostnames_hostname_association
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_hostname_associations_response,
		errors: [
			{
				status: NaN,
				description: `Replace Hostname Associations Response Failure`,
				schema: tls_certificates_and_hostnames_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/client_certificates",
		alias: "client-certificate-for-a-zone-list-client-certificates",
		description: `List all of your Zone&#x27;s API Shield mTLS Client Certificates by Status and/or using Pagination`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "status",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "offset",
				type: "Query",
				schema: z.number().int().optional()
			},
		],
		response: tls_certificates_and_hostnames_client_certificate_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Client Certificates Response Failure`,
				schema: tls_certificates_and_hostnames_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/client_certificates",
		alias: "client-certificate-for-a-zone-create-client-certificate",
		description: `Create a new API Shield mTLS Client Certificate`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: client_certificate_for_a_zone_create_client_certificate_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_client_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Client Certificate Response Failure`,
				schema: tls_certificates_and_hostnames_client_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/client_certificates/:client_certificate_id",
		alias: "client-certificate-for-a-zone-delete-client-certificate",
		description: `Set a API Shield mTLS Client Certificate to pending_revocation status for processing to revoked status.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "client_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_client_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Revoke Client Certificate Response Failure`,
				schema: tls_certificates_and_hostnames_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/client_certificates/:client_certificate_id",
		alias: "client-certificate-for-a-zone-client-certificate-details",
		description: `Get Details for a single mTLS API Shield Client Certificate`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "client_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_client_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Client Certificate Details Response Failure`,
				schema: tls_certificates_and_hostnames_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/client_certificates/:client_certificate_id",
		alias: "client-certificate-for-a-zone-edit-client-certificate",
		description: `If a API Shield mTLS Client Certificate is in a pending_revocation state, you may reactivate it with this endpoint.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "client_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_client_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Reactivate Client Certificate Response Failure`,
				schema: tls_certificates_and_hostnames_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/custom_certificates",
		alias: "custom-ssl-for-a-zone-list-ssl-configurations",
		description: `List, search, and filter all of your custom SSL certificates. The higher priority will break ties across overlapping &#x27;legacy_custom&#x27; certificates, but &#x27;legacy_custom&#x27; certificates will always supercede &#x27;sni_custom&#x27; certificates.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "match",
				type: "Query",
				schema: z.enum(["any", "all"]).optional().default("all")
			},
			{
				name: "status",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_collection,
		errors: [
			{
				status: NaN,
				description: `List SSL Configurations response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/custom_certificates",
		alias: "custom-ssl-for-a-zone-create-ssl-configuration",
		description: `Upload a new SSL certificate for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: custom_ssl_for_a_zone_create_ssl_configuration_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Create SSL Configuration response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/custom_certificates/:custom_certificate_id",
		alias: "custom-ssl-for-a-zone-delete-ssl-configuration",
		description: `Remove a SSL certificate from a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "custom_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_id_only,
		errors: [
			{
				status: NaN,
				description: `Delete SSL Configuration response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_id_only.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/custom_certificates/:custom_certificate_id",
		alias: "custom-ssl-for-a-zone-ssl-configuration-details",
		requestFormat: "json",
		parameters: [
			{
				name: "custom_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `SSL Configuration Details response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/custom_certificates/:custom_certificate_id",
		alias: "custom-ssl-for-a-zone-edit-ssl-configuration",
		description: `Upload a new private key and/or PEM/CRT for the SSL certificate. Note: PATCHing a configuration for sni_custom certificates will result in a new resource id being returned, and the previous one being deleted.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: custom_ssl_for_a_zone_edit_ssl_configuration_Body
			},
			{
				name: "custom_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Edit SSL Configuration response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/custom_certificates/prioritize",
		alias: "custom-ssl-for-a-zone-re-prioritize-ssl-certificates",
		description: `If a zone has multiple SSL certificates, you can set the order in which they should be used during a request. The higher priority will break ties across overlapping &#x27;legacy_custom&#x27; certificates.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ certificates: z.array(z.object({ id: tls_certificates_and_hostnames_identifier.max(32), priority: tls_certificates_and_hostnames_priority.default(20) }).partial().passthrough()) }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_collection,
		errors: [
			{
				status: NaN,
				description: `Re-prioritize SSL Certificates response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/custom_hostnames",
		alias: "custom-hostname-for-a-zone-list-custom-hostnames",
		description: `List, search, sort, and filter all of your custom hostnames.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "hostname",
				type: "Query",
				schema: z.string().max(255).optional()
			},
			{
				name: "id",
				type: "Query",
				schema: z.string().min(36).max(36).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "order",
				type: "Query",
				schema: z.unknown().optional().default("ssl")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "ssl",
				type: "Query",
				schema: z.unknown().optional().default("0")
			},
		],
		response: tls_certificates_and_hostnames_custom_hostname_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Custom Hostnames response failure`,
				schema: tls_certificates_and_hostnames_custom_hostname_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/custom_hostnames",
		alias: "custom-hostname-for-a-zone-create-custom-hostname",
		description: `Add a new custom hostname and request that an SSL certificate be issued for it. One of three validation methods—http, txt, email—should be used, with &#x27;http&#x27; recommended if the CNAME is already in place (or will be soon). Specifying &#x27;email&#x27; will send an email to the WHOIS contacts on file for the base domain plus hostmaster, postmaster, webmaster, admin, administrator. If http is used and the domain is not already pointing to the Managed CNAME host, the PATCH method must be used once it is (to complete validation).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: custom_hostname_for_a_zone_create_custom_hostname_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_custom_hostname_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Custom Hostname response failure`,
				schema: tls_certificates_and_hostnames_custom_hostname_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/custom_hostnames/:custom_hostname_id",
		alias: "custom-hostname-for-a-zone-delete-custom-hostname-(-and-any-issued-ssl-certificates)",
		requestFormat: "json",
		parameters: [
			{
				name: "custom_hostname_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ id: tls_certificates_and_hostnames_identifier.max(32) }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Delete Custom Hostname (and any issued SSL certificates) response failure`,
				schema: z.object({ id: tls_certificates_and_hostnames_identifier.max(32) }).partial().passthrough().and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/custom_hostnames/:custom_hostname_id",
		alias: "custom-hostname-for-a-zone-custom-hostname-details",
		requestFormat: "json",
		parameters: [
			{
				name: "custom_hostname_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_custom_hostname_response_single,
		errors: [
			{
				status: NaN,
				description: `Custom Hostname Details response failure`,
				schema: tls_certificates_and_hostnames_custom_hostname_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/custom_hostnames/:custom_hostname_id",
		alias: "custom-hostname-for-a-zone-edit-custom-hostname",
		description: `Modify SSL configuration for a custom hostname. When sent with SSL config that matches existing config, used to indicate that hostname should pass domain control validation (DCV). Can also be used to change validation type, e.g., from &#x27;http&#x27; to &#x27;email&#x27;.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: custom_hostname_for_a_zone_edit_custom_hostname_Body
			},
			{
				name: "custom_hostname_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_custom_hostname_response_single,
		errors: [
			{
				status: NaN,
				description: `Edit Custom Hostname response failure`,
				schema: tls_certificates_and_hostnames_custom_hostname_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/custom_hostnames/fallback_origin",
		alias: "custom-hostname-fallback-origin-for-a-zone-delete-fallback-origin-for-custom-hostnames",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_fallback_origin_response,
		errors: [
			{
				status: NaN,
				description: `Delete Fallback Origin for Custom Hostnames response failure`,
				schema: tls_certificates_and_hostnames_fallback_origin_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/custom_hostnames/fallback_origin",
		alias: "custom-hostname-fallback-origin-for-a-zone-get-fallback-origin-for-custom-hostnames",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_fallback_origin_response,
		errors: [
			{
				status: NaN,
				description: `Get Fallback Origin for Custom Hostnames response failure`,
				schema: tls_certificates_and_hostnames_fallback_origin_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/custom_hostnames/fallback_origin",
		alias: "custom-hostname-fallback-origin-for-a-zone-update-fallback-origin-for-custom-hostnames",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_fallback_origin_response,
		errors: [
			{
				status: NaN,
				description: `Update Fallback Origin for Custom Hostnames response failure`,
				schema: tls_certificates_and_hostnames_fallback_origin_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/custom_ns",
		alias: "account-level-custom-nameservers-usage-for-a-zone-get-account-custom-nameserver-related-zone-metadata",
		description: `Get metadata for account-level custom nameservers on a zone.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_custom_nameservers_get_response,
		errors: [
			{
				status: NaN,
				description: `Get Account Custom Nameserver Related Zone Metadata response failure`,
				schema: dns_custom_nameservers_get_response.and(dns_custom_nameservers_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/custom_ns",
		alias: "account-level-custom-nameservers-usage-for-a-zone-set-account-custom-nameserver-related-zone-metadata",
		description: `Set metadata for account-level custom nameservers on a zone.

If you would like new zones in the account to use account custom nameservers by default, use PUT /accounts/:identifier to set the account setting use_account_custom_ns_by_default to true.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dns_custom_nameservers_zone_metadata
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_custom_nameservers_schemas_empty_response,
		errors: [
			{
				status: NaN,
				description: `Set Account Custom Nameserver Related Zone Metadata response failure`,
				schema: dns_custom_nameservers_schemas_empty_response.and(dns_custom_nameservers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/dcv_delegation/uuid",
		alias: "dcv-delegation-uuid-get",
		description: `Retrieve the account and zone specific unique identifier used as part of the CNAME target for DCV Delegation.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_dcv_delegation_response,
		errors: [
			{
				status: NaN,
				description: `Retrieve the DCV Delegation unique identifier response failure.`,
				schema: tls_certificates_and_hostnames_dcv_delegation_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/dns_records",
		alias: "dns-records-for-a-zone-list-dns-records",
		description: `List, search, sort, and filter a zones&#x27; DNS records.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "name",
				type: "Query",
				schema: z.string().max(255).optional()
			},
			{
				name: "type",
				type: "Query",
				schema: z.enum(["A", "AAAA", "CAA", "CERT", "CNAME", "DNSKEY", "DS", "HTTPS", "LOC", "MX", "NAPTR", "NS", "PTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "TXT", "URI"]).optional()
			},
			{
				name: "content",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "proxied",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "match",
				type: "Query",
				schema: z.enum(["any", "all"]).optional().default("all")
			},
			{
				name: "comment",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "comment.present",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "comment.absent",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "comment.exact",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "comment.contains",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "comment.startswith",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "comment.endswith",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "tag",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "tag.present",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "tag.absent",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "tag.exact",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "tag.contains",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "tag.startswith",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "tag.endswith",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "search",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "tag_match",
				type: "Query",
				schema: z.enum(["any", "all"]).optional().default("all")
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50000).optional().default(100)
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["type", "name", "content", "ttl", "proxied"]).optional().default("type")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional().default("asc")
			},
		],
		response: dns_records_dns_response_collection,
		errors: [
			{
				status: NaN,
				description: `List DNS Records response failure`,
				schema: dns_records_dns_response_collection.and(dns_records_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/dns_records",
		alias: "dns-records-for-a-zone-create-dns-record",
		description: `Create a new DNS record for a zone.

Notes:
- A/AAAA records cannot exist on the same name as CNAME records.
- NS records cannot exist on the same name as any other record type.
- Domain names are always represented in Punycode, even if Unicode
  characters were used when creating the record.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dns_records_dns_record
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_records_dns_response_single,
		errors: [
			{
				status: NaN,
				description: `Create DNS Record response failure`,
				schema: dns_records_dns_response_single.and(dns_records_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/dns_records/:dns_record_id",
		alias: "dns-records-for-a-zone-delete-dns-record",
		requestFormat: "json",
		parameters: [
			{
				name: "dns_record_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ result: z.object({ id: dns_records_identifier.max(32) }).partial().passthrough() }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Delete DNS Record response failure`,
				schema: z.object({ result: z.object({ id: dns_records_identifier.max(32) }).partial().passthrough() }).partial().passthrough().and(dns_records_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/dns_records/:dns_record_id",
		alias: "dns-records-for-a-zone-dns-record-details",
		requestFormat: "json",
		parameters: [
			{
				name: "dns_record_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_records_dns_response_single,
		errors: [
			{
				status: NaN,
				description: `DNS Record Details response failure`,
				schema: dns_records_dns_response_single.and(dns_records_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/dns_records/:dns_record_id",
		alias: "dns-records-for-a-zone-patch-dns-record",
		description: `Update an existing DNS record.
Notes:
- A/AAAA records cannot exist on the same name as CNAME records.
- NS records cannot exist on the same name as any other record type.
- Domain names are always represented in Punycode, even if Unicode
  characters were used when creating the record.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dns_records_dns_record
			},
			{
				name: "dns_record_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_records_dns_response_single,
		errors: [
			{
				status: NaN,
				description: `Patch DNS Record response failure`,
				schema: dns_records_dns_response_single.and(dns_records_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/dns_records/:dns_record_id",
		alias: "dns-records-for-a-zone-update-dns-record",
		description: `Overwrite an existing DNS record.
Notes:
- A/AAAA records cannot exist on the same name as CNAME records.
- NS records cannot exist on the same name as any other record type.
- Domain names are always represented in Punycode, even if Unicode
  characters were used when creating the record.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dns_records_dns_record
			},
			{
				name: "dns_record_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_records_dns_response_single,
		errors: [
			{
				status: NaN,
				description: `Update DNS Record response failure`,
				schema: dns_records_dns_response_single.and(dns_records_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/dns_records/export",
		alias: "dns-records-for-a-zone-export-dns-records",
		description: `You can export your [BIND config](https://en.wikipedia.org/wiki/Zone_file &quot;Zone file&quot;) through this endpoint.

See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ &quot;Import and export records&quot;) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Export DNS Records response failure`,
				schema: dns_records_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/dns_records/import",
		alias: "dns-records-for-a-zone-import-dns-records",
		description: `You can upload your [BIND config](https://en.wikipedia.org/wiki/Zone_file &quot;Zone file&quot;) through this endpoint. It assumes that cURL is called from a location with bind_config.txt (valid BIND config) present.

See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ &quot;Import and export records&quot;) for more information.`,
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dns_records_for_a_zone_import_dns_records_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_records_dns_response_import_scan,
		errors: [
			{
				status: NaN,
				description: `Import DNS Records response failure`,
				schema: dns_records_dns_response_import_scan.and(dns_records_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/dns_records/scan",
		alias: "dns-records-for-a-zone-scan-dns-records",
		description: `Scan for common DNS records on your domain and automatically add them to your zone. Useful if you haven&#x27;t updated your nameservers yet.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dns_records_dns_response_import_scan,
		errors: [
			{
				status: NaN,
				description: `Scan DNS Records response failure`,
				schema: dns_records_dns_response_import_scan.and(dns_records_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/dnssec",
		alias: "dnssec-delete-dnssec-records",
		description: `Delete DNSSEC.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dnssec_delete_dnssec_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete DNSSEC records response failure`,
				schema: dnssec_delete_dnssec_response_single.and(dnssec_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/dnssec",
		alias: "dnssec-dnssec-details",
		description: `Details about DNSSEC status and configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dnssec_dnssec_response_single,
		errors: [
			{
				status: NaN,
				description: `DNSSEC Details response failure`,
				schema: dnssec_dnssec_response_single.and(dnssec_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/dnssec",
		alias: "dnssec-edit-dnssec-status",
		description: `Enable or disable DNSSEC.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ dnssec_multi_signer: dnssec_dnssec_multi_signer, dnssec_presigned: dnssec_dnssec_presigned, status: z.unknown() }).partial().passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dnssec_dnssec_response_single,
		errors: [
			{
				status: NaN,
				description: `Edit DNSSEC Status response failure`,
				schema: dnssec_dnssec_response_single.and(dnssec_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/firewall/access_rules/rules",
		alias: "ip-access-rules-for-a-zone-list-ip-access-rules",
		description: `Fetches IP Access rules of a zone. You can filter the results using several optional parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "filters",
				type: "Query",
				schema: filters
			},
			{
				name: "egs-pagination.json",
				type: "Query",
				schema: egs_pagination_json
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["configuration.target", "configuration.value", "mode"]).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
		],
		response: legacy_jhs_rule_collection_response,
		errors: [
			{
				status: NaN,
				description: `List IP Access rules response failure`,
				schema: legacy_jhs_rule_collection_response.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/firewall/access_rules/rules",
		alias: "ip-access-rules-for-a-zone-create-an-ip-access-rule",
		description: `Creates a new IP Access rule for a zone.

Note: To create an IP Access rule that applies to multiple zones, refer to [IP Access rules for a user](#ip-access-rules-for-a-user) or [IP Access rules for an account](#ip-access-rules-for-an-account) as appropriate.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ configuration: legacy_jhs_schemas_configuration, mode: legacy_jhs_schemas_mode, notes: legacy_jhs_notes }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_rule_single_response,
		errors: [
			{
				status: NaN,
				description: `Create an IP Access rule response failure`,
				schema: legacy_jhs_rule_single_response.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/firewall/access_rules/rules/:identifier",
		alias: "ip-access-rules-for-a-zone-delete-an-ip-access-rule",
		description: `Deletes an IP Access rule defined at the zone level.

Optionally, you can use the &#x60;cascade&#x60; property to specify that you wish to delete similar rules in other zones managed by the same zone owner.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ cascade: z.enum(["none", "basic", "aggressive"]).default("none") }).partial().passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_rule_single_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete an IP Access rule response failure`,
				schema: legacy_jhs_rule_single_id_response.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/firewall/access_rules/rules/:identifier",
		alias: "ip-access-rules-for-a-zone-update-an-ip-access-rule",
		description: `Updates an IP Access rule defined at the zone level. You can only update the rule action (&#x60;mode&#x60; parameter) and notes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ mode: legacy_jhs_schemas_mode, notes: legacy_jhs_notes }).partial().passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_rule_single_response,
		errors: [
			{
				status: NaN,
				description: `Update an IP Access rule response failure`,
				schema: legacy_jhs_rule_single_response.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/firewall/waf/packages/:package_id/groups",
		alias: "waf-rule-groups-list-waf-rule-groups",
		description: `Fetches the WAF rule groups in a WAF package.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "package_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "mode",
				type: "Query",
				schema: z.enum(["on", "off"]).optional().default("on")
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(100).optional().default(50)
			},
			{
				name: "order",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.unknown().optional()
			},
			{
				name: "match",
				type: "Query",
				schema: z.unknown().optional().default("all")
			},
			{
				name: "name",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "rules_count",
				type: "Query",
				schema: z.number().optional()
			},
		],
		response: waf_managed_rules_rule_group_response_collection,
		errors: [
			{
				status: NaN,
				description: `List WAF rule groups response failure`,
				schema: waf_managed_rules_rule_group_response_collection.and(waf_managed_rules_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/firewall/waf/packages/:package_id/groups/:group_id",
		alias: "waf-rule-groups-get-a-waf-rule-group",
		description: `Fetches the details of a WAF rule group.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "group_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "package_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waf_managed_rules_rule_group_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a WAF rule group response failure`,
				schema: waf_managed_rules_rule_group_response_single.and(waf_managed_rules_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/firewall/waf/packages/:package_id/groups/:group_id",
		alias: "waf-rule-groups-update-a-waf-rule-group",
		description: `Updates a WAF rule group. You can update the state (&#x60;mode&#x60; parameter) of a rule group.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ mode: waf_managed_rules_mode.default("on") }).partial().passthrough()
			},
			{
				name: "group_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "package_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waf_managed_rules_rule_group_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a WAF rule group response failure`,
				schema: waf_managed_rules_rule_group_response_single.and(waf_managed_rules_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/firewall/waf/packages/:package_id/rules",
		alias: "waf-rules-list-waf-rules",
		description: `Fetches WAF rules in a WAF package.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "package_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "mode",
				type: "Query",
				schema: z.enum(["DIS", "CHL", "BLK", "SIM"]).optional()
			},
			{
				name: "group_id",
				type: "Query",
				schema: z.string().max(32).optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(100).optional().default(50)
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["priority", "group_id", "description"]).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
			{
				name: "match",
				type: "Query",
				schema: z.enum(["any", "all"]).optional().default("all")
			},
			{
				name: "description",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "priority",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: waf_managed_rules_rule_response_collection,
		errors: [
			{
				status: NaN,
				description: `List WAF rules response failure`,
				schema: waf_managed_rules_rule_response_collection.and(waf_managed_rules_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/firewall/waf/packages/:package_id/rules/:rule_id",
		alias: "waf-rules-get-a-waf-rule",
		description: `Fetches the details of a WAF rule in a WAF package.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "package_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waf_managed_rules_rule_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a WAF rule response failure`,
				schema: waf_managed_rules_rule_response_single.and(waf_managed_rules_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/firewall/waf/packages/:package_id/rules/:rule_id",
		alias: "waf-rules-update-a-waf-rule",
		description: `Updates a WAF rule. You can only update the mode/action of the rule.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ mode: z.unknown() }).partial().passthrough()
			},
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "package_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waf_managed_rules_rule_response_single.and(z.object({ result: z.union([waf_managed_rules_anomaly_rule, waf_managed_rules_traditional_deny_rule, waf_managed_rules_traditional_allow_rule]) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update a WAF rule response failure`,
				schema: waf_managed_rules_rule_response_single.and(z.object({ result: z.union([waf_managed_rules_anomaly_rule, waf_managed_rules_traditional_deny_rule, waf_managed_rules_traditional_allow_rule]) }).partial().passthrough()).and(waf_managed_rules_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/hold",
		alias: "zones-0-hold-delete",
		description: `Stop enforcement of a zone hold on the zone, permanently or temporarily, allowing the
creation and activation of zones with this zone&#x27;s hostname.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "hold_after",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: z.object({ result: z.object({ hold: z.boolean(), hold_after: z.string(), include_subdomains: z.string() }).partial().passthrough() }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Client Error`,
				schema: zones_schemas_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/hold",
		alias: "zones-0-hold-get",
		description: `Retrieve whether the zone is subject to a zone hold, and metadata about the hold.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_api_response_single.and(z.object({ result: z.object({ hold: z.boolean(), hold_after: z.string(), include_subdomains: z.string() }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Client Error`,
				schema: zones_schemas_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/hold",
		alias: "zones-0-hold-post",
		description: `Enforce a zone hold on the zone, blocking the creation and activation of zones with this zone&#x27;s hostname.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "include_subdomains",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: zones_api_response_single.and(z.object({ result: z.object({ hold: z.boolean(), hold_after: z.string(), include_subdomains: z.string() }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Client Error`,
				schema: zones_schemas_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/hostnames/settings/:setting_id",
		alias: "per-hostname-tls-settings-list",
		description: `List the requested TLS setting for the hostnames under this zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "setting_id",
				type: "Path",
				schema: z.enum(["ciphers", "min_tls_version", "http2"])
			},
		],
		response: tls_certificates_and_hostnames_per_hostname_settings_response_collection,
		errors: [
			{
				status: NaN,
				description: `List per-hostname TLS settings response failure`,
				schema: tls_certificates_and_hostnames_per_hostname_settings_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/hostnames/settings/:setting_id/:hostname",
		alias: "per-hostname-tls-settings-delete",
		description: `Delete the tls setting value for the hostname.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "setting_id",
				type: "Path",
				schema: z.enum(["ciphers", "min_tls_version", "http2"])
			},
			{
				name: "hostname",
				type: "Path",
				schema: z.string()
			},
		],
		response: tls_certificates_and_hostnames_per_hostname_settings_response_delete,
		errors: [
			{
				status: NaN,
				description: `Delete TLS setting for hostname response failure`,
				schema: tls_certificates_and_hostnames_per_hostname_settings_response_delete.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/hostnames/settings/:setting_id/:hostname",
		alias: "per-hostname-tls-settings-put",
		description: `Update the tls setting value for the hostname.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: per_hostname_tls_settings_put_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "setting_id",
				type: "Path",
				schema: z.enum(["ciphers", "min_tls_version", "http2"])
			},
			{
				name: "hostname",
				type: "Path",
				schema: z.string()
			},
		],
		response: tls_certificates_and_hostnames_per_hostname_settings_response,
		errors: [
			{
				status: NaN,
				description: `Edit TLS setting for hostname response failure`,
				schema: tls_certificates_and_hostnames_per_hostname_settings_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/keyless_certificates",
		alias: "keyless-ssl-for-a-zone-list-keyless-ssl-configurations",
		description: `List all Keyless SSL configurations for a given zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_keyless_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Keyless SSL Configurations response failure`,
				schema: tls_certificates_and_hostnames_keyless_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/keyless_certificates",
		alias: "keyless-ssl-for-a-zone-create-keyless-ssl-configuration",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: keyless_ssl_for_a_zone_create_keyless_ssl_configuration_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_keyless_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Keyless SSL Configuration response failure`,
				schema: tls_certificates_and_hostnames_keyless_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/keyless_certificates/:keyless_certificate_id",
		alias: "keyless-ssl-for-a-zone-delete-keyless-ssl-configuration",
		requestFormat: "json",
		parameters: [
			{
				name: "keyless_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_keyless_response_single_id,
		errors: [
			{
				status: NaN,
				description: `Delete Keyless SSL Configuration response failure`,
				schema: tls_certificates_and_hostnames_keyless_response_single_id.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/keyless_certificates/:keyless_certificate_id",
		alias: "keyless-ssl-for-a-zone-get-keyless-ssl-configuration",
		description: `Get details for one Keyless SSL configuration.`,
		requestFormat: "json",
		parameters: [
			{
				name: "keyless_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_keyless_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Keyless SSL Configuration response failure`,
				schema: tls_certificates_and_hostnames_keyless_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/keyless_certificates/:keyless_certificate_id",
		alias: "keyless-ssl-for-a-zone-edit-keyless-ssl-configuration",
		description: `This will update attributes of a Keyless SSL. Consists of one or more of the following:  host,name,port.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: keyless_ssl_for_a_zone_edit_keyless_ssl_configuration_Body
			},
			{
				name: "keyless_certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_keyless_response_single,
		errors: [
			{
				status: NaN,
				description: `Edit Keyless SSL Configuration response failure`,
				schema: tls_certificates_and_hostnames_keyless_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/load_balancers",
		alias: "load-balancers-list-load-balancers",
		description: `List configured load balancers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_load_balancer_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Load Balancers response failure`,
				schema: load_balancing_load_balancer_components_schemas_response_collection.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/load_balancers",
		alias: "load-balancers-create-load-balancer",
		description: `Create a new load balancer.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ adaptive_routing: load_balancing_adaptive_routing.optional(), country_pools: load_balancing_country_pools.optional(), default_pools: load_balancing_default_pools, description: load_balancing_components_schemas_description.optional(), fallback_pool: load_balancing_fallback_pool, location_strategy: load_balancing_location_strategy.optional(), name: load_balancing_components_schemas_name, pop_pools: load_balancing_pop_pools.optional(), proxied: load_balancing_proxied.optional(), random_steering: load_balancing_random_steering.optional(), region_pools: load_balancing_region_pools.optional(), rules: load_balancing_rules.optional(), session_affinity: load_balancing_session_affinity.optional().default("\"\""), session_affinity_attributes: load_balancing_session_affinity_attributes.optional(), session_affinity_ttl: load_balancing_session_affinity_ttl.optional(), steering_policy: load_balancing_steering_policy.optional().default("\"\""), ttl: load_balancing_ttl.optional() }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_load_balancer_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Create Load Balancer response failure`,
				schema: load_balancing_load_balancer_components_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/load_balancers/:load_balancer_id",
		alias: "load-balancers-delete-load-balancer",
		description: `Delete a configured load balancer.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "load_balancer_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_components_schemas_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Load Balancer response failure`,
				schema: load_balancing_components_schemas_id_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/load_balancers/:load_balancer_id",
		alias: "load-balancers-load-balancer-details",
		description: `Fetch a single configured load balancer.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "load_balancer_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_load_balancer_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Load Balancer Details response failure`,
				schema: load_balancing_load_balancer_components_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/load_balancers/:load_balancer_id",
		alias: "load-balancers-patch-load-balancer",
		description: `Apply changes to an existing load balancer, overwriting the supplied properties.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ adaptive_routing: load_balancing_adaptive_routing, country_pools: load_balancing_country_pools, default_pools: load_balancing_default_pools, description: load_balancing_components_schemas_description, enabled: load_balancing_components_schemas_enabled.default(true), fallback_pool: load_balancing_fallback_pool, location_strategy: load_balancing_location_strategy, name: load_balancing_components_schemas_name, pop_pools: load_balancing_pop_pools, proxied: load_balancing_proxied, random_steering: load_balancing_random_steering, region_pools: load_balancing_region_pools, rules: load_balancing_rules, session_affinity: load_balancing_session_affinity.default("\"\""), session_affinity_attributes: load_balancing_session_affinity_attributes, session_affinity_ttl: load_balancing_session_affinity_ttl, steering_policy: load_balancing_steering_policy.default("\"\""), ttl: load_balancing_ttl }).partial().passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "load_balancer_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_load_balancer_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Patch Load Balancer response failure`,
				schema: load_balancing_load_balancer_components_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/load_balancers/:load_balancer_id",
		alias: "load-balancers-update-load-balancer",
		description: `Update a configured load balancer.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ adaptive_routing: load_balancing_adaptive_routing.optional(), country_pools: load_balancing_country_pools.optional(), default_pools: load_balancing_default_pools, description: load_balancing_components_schemas_description.optional(), enabled: load_balancing_components_schemas_enabled.optional().default(true), fallback_pool: load_balancing_fallback_pool, location_strategy: load_balancing_location_strategy.optional(), name: load_balancing_components_schemas_name, pop_pools: load_balancing_pop_pools.optional(), proxied: load_balancing_proxied.optional(), random_steering: load_balancing_random_steering.optional(), region_pools: load_balancing_region_pools.optional(), rules: load_balancing_rules.optional(), session_affinity: load_balancing_session_affinity.optional().default("\"\""), session_affinity_attributes: load_balancing_session_affinity_attributes.optional(), session_affinity_ttl: load_balancing_session_affinity_ttl.optional(), steering_policy: load_balancing_steering_policy.optional().default("\"\""), ttl: load_balancing_ttl.optional() }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "load_balancer_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: load_balancing_load_balancer_components_schemas_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Load Balancer response failure`,
				schema: load_balancing_load_balancer_components_schemas_single_response.and(load_balancing_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/logpush/datasets/:dataset_id/fields",
		alias: "get-zones-zone_identifier-logpush-datasets-dataset-fields",
		description: `Lists all fields available for a dataset. The response result is an object with key-value pairs, where keys are field names, and values are descriptions.`,
		requestFormat: "json",
		parameters: [
			{
				name: "dataset_id",
				type: "Path",
				schema: z.string().max(256).regex(/^[a-zA-Z0-9_\-]*$/).nullable()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_field_response_collection,
		errors: [
			{
				status: NaN,
				description: `List fields response failure`,
				schema: logpush_logpush_field_response_collection.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/logpush/datasets/:dataset_id/jobs",
		alias: "get-zones-zone_identifier-logpush-datasets-dataset-jobs",
		description: `Lists Logpush jobs for a zone for a dataset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "dataset_id",
				type: "Path",
				schema: z.string().max(256).regex(/^[a-zA-Z0-9_\-]*$/).nullable()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_job_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Logpush jobs for a dataset response failure`,
				schema: logpush_logpush_job_response_collection.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/logpush/edge",
		alias: "get-zones-zone_identifier-logpush-edge-jobs",
		description: `Lists Instant Logs jobs for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_instant_logs_job_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Instant Logs jobs response failure`,
				schema: logpush_instant_logs_job_response_collection.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/logpush/edge",
		alias: "post-zones-zone_identifier-logpush-edge-jobs",
		description: `Creates a new Instant Logs job for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ fields: logpush_fields, filter: logpush_filter, sample: logpush_sample.int() }).partial().passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_instant_logs_job_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Instant Logs job response failure`,
				schema: logpush_instant_logs_job_response_single.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/logpush/jobs",
		alias: "get-zones-zone_identifier-logpush-jobs",
		description: `Lists Logpush jobs for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_job_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Logpush jobs response failure`,
				schema: logpush_logpush_job_response_collection.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/logpush/jobs",
		alias: "post-zones-zone_identifier-logpush-jobs",
		description: `Creates a new Logpush job for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ dataset: logpush_dataset.max(256).regex(/^[a-zA-Z0-9_\-]*$/).nullish(), destination_conf: logpush_destination_conf.max(4096).url(), enabled: logpush_enabled.optional(), frequency: logpush_frequency.nullish().default("high"), logpull_options: logpush_logpull_options.max(4096).nullish(), name: logpush_name.max(512).regex(/^[a-zA-Z0-9\-\.]*$/).nullish(), output_options: logpush_output_options.nullish(), ownership_challenge: logpush_ownership_challenge.max(4096).regex(/^[a-zA-Z0-9/\+\.\-_]*$/).optional() }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_job_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Logpush job response failure`,
				schema: logpush_logpush_job_response_single.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/logpush/jobs/:job_id",
		alias: "delete-zones-zone_identifier-logpush-jobs-job_identifier",
		description: `Deletes a Logpush job.`,
		requestFormat: "json",
		parameters: [
			{
				name: "job_id",
				type: "Path",
				schema: z.number().int().gte(1)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_api_response_common.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Logpush job response failure`,
				schema: logpush_api_response_common.and(z.object({ result: z.object({}).partial().passthrough().nullable() }).partial().passthrough()).and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/logpush/jobs/:job_id",
		alias: "get-zones-zone_identifier-logpush-jobs-job_identifier",
		description: `Gets the details of a Logpush job.`,
		requestFormat: "json",
		parameters: [
			{
				name: "job_id",
				type: "Path",
				schema: z.number().int().gte(1)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_job_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Logpush job details response failure`,
				schema: logpush_logpush_job_response_single.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/logpush/jobs/:job_id",
		alias: "put-zones-zone_identifier-logpush-jobs-job_identifier",
		description: `Updates a Logpush job.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ destination_conf: logpush_destination_conf.max(4096).url(), enabled: logpush_enabled, frequency: logpush_frequency.nullable().default("high"), logpull_options: logpush_logpull_options.max(4096).nullable(), output_options: logpush_output_options.nullable(), ownership_challenge: logpush_ownership_challenge.max(4096).regex(/^[a-zA-Z0-9/\+\.\-_]*$/) }).partial().passthrough()
			},
			{
				name: "job_id",
				type: "Path",
				schema: z.number().int().gte(1)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_logpush_job_response_single,
		errors: [
			{
				status: NaN,
				description: `Update Logpush job response failure`,
				schema: logpush_logpush_job_response_single.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/logpush/ownership",
		alias: "post-zones-zone_identifier-logpush-ownership",
		description: `Gets a new ownership challenge sent to your destination.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ destination_conf: logpush_destination_conf.max(4096).url() }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_get_ownership_response,
		errors: [
			{
				status: NaN,
				description: `Get ownership challenge response failure`,
				schema: logpush_get_ownership_response.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/logpush/ownership/validate",
		alias: "post-zones-zone_identifier-logpush-ownership-validate",
		description: `Validates ownership challenge of the destination.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ destination_conf: logpush_destination_conf.max(4096).url(), ownership_challenge: logpush_ownership_challenge.max(4096).regex(/^[a-zA-Z0-9/\+\.\-_]*$/) }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_validate_ownership_response,
		errors: [
			{
				status: NaN,
				description: `Validate ownership challenge response failure`,
				schema: logpush_validate_ownership_response.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/logpush/validate/destination/exists",
		alias: "post-zones-zone_identifier-logpush-validate-destination-exists",
		description: `Checks if there is an existing job with a destination.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ destination_conf: logpush_destination_conf.max(4096).url() }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_destination_exists_response,
		errors: [
			{
				status: NaN,
				description: `Check destination exists response failure`,
				schema: logpush_destination_exists_response.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/logpush/validate/origin",
		alias: "post-zones-zone_identifier-logpush-validate-origin",
		description: `Validates logpull origin with logpull_options.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ logpull_options: logpush_logpull_options.max(4096).nullable() }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: logpush_validate_response,
		errors: [
			{
				status: NaN,
				description: `Validate origin response failure`,
				schema: logpush_validate_response.and(logpush_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/managed_headers",
		alias: "managed-transforms-list-managed-transforms",
		description: `Fetches a list of all Managed Transforms.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ managed_request_headers: rulesets_request_list, managed_response_headers: rulesets_request_list }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `List Managed Transforms response failure`,
				schema: z.object({ managed_request_headers: rulesets_request_list, managed_response_headers: rulesets_request_list }).partial().passthrough().and(rulesets_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/managed_headers",
		alias: "managed-transforms-update-status-of-managed-transforms",
		description: `Updates the status of one or more Managed Transforms.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: managed_transforms_update_status_of_managed_transforms_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ managed_request_headers: rulesets_response_list, managed_response_headers: rulesets_response_list }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Update status of Managed Transforms response failure`,
				schema: z.object({ managed_request_headers: rulesets_response_list, managed_response_headers: rulesets_response_list }).partial().passthrough().and(rulesets_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/origin_tls_client_auth",
		alias: "zone-level-authenticated-origin-pulls-list-certificates",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_components_schemas_certificate_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Certificates response failure`,
				schema: tls_certificates_and_hostnames_components_schemas_certificate_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/origin_tls_client_auth",
		alias: "zone-level-authenticated-origin-pulls-upload-certificate",
		description: `Upload your own certificate you want Cloudflare to use for edge-to-origin communication to override the shared certificate. Please note that it is important to keep only one certificate active. Also, make sure to enable zone-level authenticated origin pulls by making a PUT call to settings endpoint to see the uploaded certificate in use.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zone_level_authenticated_origin_pulls_upload_certificate_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Upload Certificate response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/origin_tls_client_auth/:certificate_id",
		alias: "zone-level-authenticated-origin-pulls-delete-certificate",
		requestFormat: "json",
		parameters: [
			{
				name: "certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete Certificate response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/origin_tls_client_auth/:certificate_id",
		alias: "zone-level-authenticated-origin-pulls-get-certificate-details",
		requestFormat: "json",
		parameters: [
			{
				name: "certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Certificate Details response failure`,
				schema: tls_certificates_and_hostnames_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/origin_tls_client_auth/hostnames",
		alias: "per-hostname-authenticated-origin-pull-enable-or-disable-a-hostname-for-client-authentication",
		description: `Associate a hostname to a certificate and enable, disable or invalidate the association. If disabled, client certificate will not be sent to the hostname even if activated at the zone level. 100 maximum associations on a single certificate are allowed. Note: Use a null value for parameter *enabled* to invalidate the association.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ config: tls_certificates_and_hostnames_config }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_hostname_aop_response_collection,
		errors: [
			{
				status: NaN,
				description: `Enable or Disable a Hostname for Client Authentication response failure`,
				schema: tls_certificates_and_hostnames_hostname_aop_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/origin_tls_client_auth/hostnames/:hostname",
		alias: "per-hostname-authenticated-origin-pull-get-the-hostname-status-for-client-authentication",
		requestFormat: "json",
		parameters: [
			{
				name: "hostname",
				type: "Path",
				schema: z.string().max(255)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_hostname_aop_single_response,
		errors: [
			{
				status: NaN,
				description: `Get the Hostname Status for Client Authentication response failure`,
				schema: tls_certificates_and_hostnames_hostname_aop_single_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/origin_tls_client_auth/hostnames/certificates",
		alias: "per-hostname-authenticated-origin-pull-list-certificates",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_certificate_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Certificates response failure`,
				schema: tls_certificates_and_hostnames_hostname_authenticated_origin_pull_components_schemas_certificate_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/origin_tls_client_auth/hostnames/certificates",
		alias: "per-hostname-authenticated-origin-pull-upload-a-hostname-client-certificate",
		description: `Upload a certificate to be used for client authentication on a hostname. 10 hostname certificates per zone are allowed.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_components_schemas_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Upload a Hostname Client Certificate response failure`,
				schema: tls_certificates_and_hostnames_components_schemas_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/origin_tls_client_auth/hostnames/certificates/:certificate_id",
		alias: "per-hostname-authenticated-origin-pull-delete-hostname-client-certificate",
		requestFormat: "json",
		parameters: [
			{
				name: "certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_components_schemas_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete Hostname Client Certificate response failure`,
				schema: tls_certificates_and_hostnames_components_schemas_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/origin_tls_client_auth/hostnames/certificates/:certificate_id",
		alias: "per-hostname-authenticated-origin-pull-get-the-hostname-client-certificate",
		description: `Get the certificate by ID to be used for client authentication on a hostname.`,
		requestFormat: "json",
		parameters: [
			{
				name: "certificate_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_components_schemas_certificate_response_single,
		errors: [
			{
				status: NaN,
				description: `Get the Hostname Client Certificate response failure`,
				schema: tls_certificates_and_hostnames_components_schemas_certificate_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/origin_tls_client_auth/settings",
		alias: "zone-level-authenticated-origin-pulls-get-enablement-setting-for-zone",
		description: `Get whether zone-level authenticated origin pulls is enabled or not. It is false by default.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_enabled_response,
		errors: [
			{
				status: NaN,
				description: `Get Enablement Setting for Zone response failure`,
				schema: tls_certificates_and_hostnames_enabled_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/origin_tls_client_auth/settings",
		alias: "zone-level-authenticated-origin-pulls-set-enablement-for-zone",
		description: `Enable or disable zone-level authenticated origin pulls. &#x27;enabled&#x27; should be set true either before/after the certificate is uploaded to see the certificate in use.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zone_level_authenticated_origin_pulls_set_enablement_for_zone_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_enabled_response,
		errors: [
			{
				status: NaN,
				description: `Set Enablement for Zone response failure`,
				schema: tls_certificates_and_hostnames_enabled_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/page_shield",
		alias: "page-shield-get-page-shield-settings",
		description: `Fetches the Page Shield settings.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: page_shield_zone_settings_response_single.and(z.object({ result: page_shield_get_zone_settings_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Page Shield settings response failure`,
				schema: page_shield_zone_settings_response_single.and(z.object({ result: page_shield_get_zone_settings_response }).partial().passthrough()).and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/page_shield",
		alias: "page-shield-update-page-shield-settings",
		description: `Updates Page Shield settings.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ enabled: page_shield_enabled, use_cloudflare_reporting_endpoint: page_shield_use_cloudflare_reporting_endpoint, use_connection_url_path: page_shield_use_connection_url_path }).partial().passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: page_shield_zone_settings_response_single.and(z.object({ result: page_shield_update_zone_settings_response }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update Page Shield settings response failure`,
				schema: page_shield_zone_settings_response_single.and(z.object({ result: page_shield_update_zone_settings_response }).partial().passthrough()).and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/page_shield/connections",
		alias: "page-shield-list-page-shield-connections",
		description: `Lists all connections detected by Page Shield.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "exclude_urls",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "urls",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "hosts",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(100).optional()
			},
			{
				name: "order_by",
				type: "Query",
				schema: z.enum(["first_seen_at", "last_seen_at"]).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
			{
				name: "prioritize_malicious",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "exclude_cdn_cgi",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "status",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page_url",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "export",
				type: "Query",
				schema: z.literal("csv").optional()
			},
		],
		response: page_shield_list_zone_connections_response,
		errors: [
			{
				status: NaN,
				description: `List Page Shield connections response failure`,
				schema: page_shield_list_zone_connections_response.and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/page_shield/connections/:connection_id",
		alias: "page-shield-get-a-page-shield-connection",
		description: `Fetches a connection detected by Page Shield by connection ID.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "connection_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
		],
		response: page_shield_get_zone_connection_response,
		errors: [
			{
				status: NaN,
				description: `Get a Page Shield connection response failure`,
				schema: page_shield_get_zone_connection_response.and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/page_shield/policies",
		alias: "page-shield-list-page-shield-policies",
		description: `Lists all Page Shield policies.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: page_shield_list_zone_policies_response,
		errors: [
			{
				status: NaN,
				description: `List Page Shield policies response failure`,
				schema: page_shield_list_zone_policies_response.and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/page_shield/policies",
		alias: "page-shield-create-a-page-shield-policy",
		description: `Create a Page Shield policy.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ action: page_shield_pageshield_policy_action, description: page_shield_pageshield_policy_description, enabled: page_shield_pageshield_policy_enabled, expression: page_shield_pageshield_policy_expression, value: page_shield_pageshield_policy_value }).partial().passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: page_shield_get_zone_policy_response,
		errors: [
			{
				status: NaN,
				description: `Create a Page Shield policy response failure`,
				schema: page_shield_get_zone_policy_response.and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/page_shield/policies/:policy_id",
		alias: "page-shield-delete-a-page-shield-policy",
		description: `Delete a Page Shield policy by ID.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Delete a Page Shield policy response failure`,
				schema: page_shield_get_zone_policy_response.and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/page_shield/policies/:policy_id",
		alias: "page-shield-get-a-page-shield-policy",
		description: `Fetches a Page Shield policy by ID.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
		],
		response: page_shield_get_zone_policy_response,
		errors: [
			{
				status: NaN,
				description: `Get a Page Shield policy response failure`,
				schema: page_shield_get_zone_policy_response.and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/page_shield/policies/:policy_id",
		alias: "page-shield-update-a-page-shield-policy",
		description: `Update a Page Shield policy by ID.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ action: page_shield_pageshield_policy_action, description: page_shield_pageshield_policy_description, enabled: page_shield_pageshield_policy_enabled, expression: page_shield_pageshield_policy_expression, value: page_shield_pageshield_policy_value }).partial().passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "policy_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
		],
		response: page_shield_get_zone_policy_response,
		errors: [
			{
				status: NaN,
				description: `Update a Page Shield policy response failure`,
				schema: page_shield_get_zone_policy_response.and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/page_shield/scripts",
		alias: "page-shield-list-page-shield-scripts",
		description: `Lists all scripts detected by Page Shield.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "exclude_urls",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "urls",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "hosts",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(100).optional()
			},
			{
				name: "order_by",
				type: "Query",
				schema: z.enum(["first_seen_at", "last_seen_at"]).optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
			{
				name: "prioritize_malicious",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "exclude_cdn_cgi",
				type: "Query",
				schema: z.boolean().optional().default(true)
			},
			{
				name: "exclude_duplicates",
				type: "Query",
				schema: z.boolean().optional().default(true)
			},
			{
				name: "status",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page_url",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "export",
				type: "Query",
				schema: z.literal("csv").optional()
			},
		],
		response: page_shield_list_zone_scripts_response,
		errors: [
			{
				status: NaN,
				description: `List Page Shield scripts response failure`,
				schema: page_shield_list_zone_scripts_response.and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/page_shield/scripts/:script_id",
		alias: "page-shield-get-a-page-shield-script",
		description: `Fetches a script detected by Page Shield by script ID.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "script_id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
		],
		response: page_shield_get_zone_script_response,
		errors: [
			{
				status: NaN,
				description: `Get a Page Shield script response failure`,
				schema: page_shield_get_zone_script_response.and(page_shield_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/pagerules",
		alias: "page-rules-list-page-rules",
		description: `Fetches Page Rules in a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["status", "priority"]).optional().default("priority")
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional().default("desc")
			},
			{
				name: "match",
				type: "Query",
				schema: z.enum(["any", "all"]).optional().default("all")
			},
			{
				name: "status",
				type: "Query",
				schema: z.enum(["active", "disabled"]).optional().default("disabled")
			},
		],
		response: zones_pagerule_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Page Rules response failure`,
				schema: zones_pagerule_response_collection.and(zones_schemas_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/pagerules",
		alias: "page-rules-create-a-page-rule",
		description: `Creates a new Page Rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: page_rules_create_a_page_rule_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_pagerule_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a Page Rule response failure`,
				schema: zones_pagerule_response_single.and(zones_schemas_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/pagerules/:pagerule_id",
		alias: "page-rules-delete-a-page-rule",
		description: `Deletes an existing Page Rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pagerule_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_schemas_api_response_single_id,
		errors: [
			{
				status: NaN,
				description: `Delete a Page Rule response failure`,
				schema: zones_schemas_api_response_single_id.and(zones_schemas_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/pagerules/:pagerule_id",
		alias: "page-rules-get-a-page-rule",
		description: `Fetches the details of a Page Rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "pagerule_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_pagerule_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a Page Rule response failure`,
				schema: zones_pagerule_response_single.and(zones_schemas_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/pagerules/:pagerule_id",
		alias: "page-rules-edit-a-page-rule",
		description: `Updates one or more fields of an existing Page Rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: page_rules_edit_a_page_rule_Body
			},
			{
				name: "pagerule_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_pagerule_response_single,
		errors: [
			{
				status: NaN,
				description: `Edit a Page Rule response failure`,
				schema: zones_pagerule_response_single.and(zones_schemas_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/pagerules/:pagerule_id",
		alias: "page-rules-update-a-page-rule",
		description: `Replaces the configuration of an existing Page Rule. The configuration of the updated Page Rule will exactly match the data passed in the API request.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: page_rules_create_a_page_rule_Body
			},
			{
				name: "pagerule_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_pagerule_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a Page Rule response failure`,
				schema: zones_pagerule_response_single.and(zones_schemas_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/pagerules/settings",
		alias: "available-page-rules-settings-list-available-page-rules-settings",
		description: `Returns a list of settings (and their details) that Page Rules can apply to matching requests.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_pagerule_settings_response_collection,
		errors: [
			{
				status: NaN,
				description: `List available Page Rules settings response failure`,
				schema: zones_pagerule_settings_response_collection.and(zones_schemas_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/purge_cache",
		alias: "zone-purge",
		description: `### Purge All Cached Content
Removes ALL files from Cloudflare&#x27;s cache. All tiers can purge everything.

### Purge Cached Content by URL
Granularly removes one or more files from Cloudflare&#x27;s cache by specifying URLs. All tiers can purge by URL.

To purge files with custom cache keys, include the headers used to compute the cache key as in the example. If you have a device type or geo in your cache key, you will need to include the CF-Device-Type or CF-IPCountry headers. If you have lang in your cache key, you will need to include the Accept-Language header.

**NB:** When including the Origin header, be sure to include the **scheme** and **hostname**. The port number can be omitted if it is the default port (80 for http, 443 for https), but must be included otherwise.

### Purge Cached Content by Tag, Host or Prefix
Granularly removes one or more files from Cloudflare&#x27;s cache either by specifying the host, the associated Cache-Tag, or a Prefix. Only Enterprise customers are permitted to purge by Tag, Host or Prefix.

**NB:** Cache-Tag, host, and prefix purging each have a rate limit of 30,000 purge API calls in every 24 hour period. You may purge up to 30 tags, hosts, or prefixes in one API call. This rate limit can be raised for customers who need to purge at higher volume.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zone_purge_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: cache_purge_api_response_single_id,
		errors: [
			{
				status: NaN,
				description: `Purge Cached Content failure`,
				schema: cache_purge_api_response_single_id.and(cache_purge_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/rulesets",
		alias: "listZoneRulesets",
		description: `Fetches all rulesets at the zone level.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetsResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List zone rulesets failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/rulesets",
		alias: "createZoneRuleset",
		description: `Creates a ruleset at the zone level.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_CreateRulesetRequest
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create a zone ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/rulesets/:ruleset_id",
		alias: "deleteZoneRuleset",
		description: `Deletes all versions of an existing zone ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Delete a zone ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/rulesets/:ruleset_id",
		alias: "getZoneRuleset",
		description: `Fetches the latest version of a zone ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get a zone ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/rulesets/:ruleset_id",
		alias: "updateZoneRuleset",
		description: `Updates a zone ruleset, creating a new version.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_UpdateRulesetRequest
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update a zone ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/rulesets/:ruleset_id/rules",
		alias: "createZoneRulesetRule",
		description: `Adds a new rule to a zone ruleset. The rule will be added to the end of the existing list of rules in the ruleset by default.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_CreateOrUpdateRuleRequest
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Create a zone ruleset rule failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/rulesets/:ruleset_id/rules/:rule_id",
		alias: "deleteZoneRulesetRule",
		description: `Deletes an existing rule from a zone ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete a zone ruleset rule failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/rulesets/:ruleset_id/rules/:rule_id",
		alias: "updateZoneRulesetRule",
		description: `Updates an existing rule in a zone ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_CreateOrUpdateRuleRequest
			},
			{
				name: "rule_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update a zone ruleset rule failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/rulesets/:ruleset_id/versions",
		alias: "listZoneRulesetVersions",
		description: `Fetches the versions of a zone ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetsResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List a zone ruleset&#x27;s versions failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/rulesets/:ruleset_id/versions/:ruleset_version",
		alias: "deleteZoneRulesetVersion",
		description: `Deletes an existing version of a zone ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_version",
				type: "Path",
				schema: z.string().regex(/^[0-9]+$/)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Delete a zone ruleset version failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/rulesets/:ruleset_id/versions/:ruleset_version",
		alias: "getZoneRulesetVersion",
		description: `Fetches a specific version of a zone ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_version",
				type: "Path",
				schema: z.string().regex(/^[0-9]+$/)
			},
			{
				name: "ruleset_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get a zone ruleset version failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/rulesets/phases/:ruleset_phase/entrypoint",
		alias: "getZoneEntrypointRuleset",
		description: `Fetches the latest version of the zone entry point ruleset for a given phase.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_phase",
				type: "Path",
				schema: z.enum(["ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_select_configuration", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed"])
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get a zone entry point ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/rulesets/phases/:ruleset_phase/entrypoint",
		alias: "updateZoneEntrypointRuleset",
		description: `Updates a zone entry point ruleset, creating a new version.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_UpdateRulesetRequest
			},
			{
				name: "ruleset_phase",
				type: "Path",
				schema: z.enum(["ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_select_configuration", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed"])
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update a zone entry point ruleset failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/rulesets/phases/:ruleset_phase/entrypoint/versions",
		alias: "listZoneEntrypointRulesetVersions",
		description: `Fetches the versions of a zone entry point ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_phase",
				type: "Path",
				schema: z.enum(["ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_select_configuration", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed"])
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetsResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List a zone entry point ruleset&#x27;s versions failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/rulesets/phases/:ruleset_phase/entrypoint/versions/:ruleset_version",
		alias: "getZoneEntrypointRulesetVersion",
		description: `Fetches a specific version of a zone entry point ruleset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "ruleset_version",
				type: "Path",
				schema: z.string().regex(/^[0-9]+$/)
			},
			{
				name: "ruleset_phase",
				type: "Path",
				schema: z.enum(["ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_select_configuration", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed"])
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().regex(/^[0-9a-f]{32}$/)
			},
		],
		response: rulesets_Response.and(z.object({ result: rulesets_RulesetResponse }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get a zone entry point ruleset version failure response.`,
				schema: rulesets_FailureResponse
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/secondary_dns/force_axfr",
		alias: "secondary-dns-(-secondary-zone)-force-axfr",
		description: `Sends AXFR zone transfer request to primary nameserver(s).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_force_response,
		errors: [
			{
				status: NaN,
				description: `Force AXFR response failure`,
				schema: secondary_dns_force_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/secondary_dns/incoming",
		alias: "secondary-dns-(-secondary-zone)-delete-secondary-zone-configuration",
		description: `Delete secondary zone configuration for incoming zone transfers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Secondary Zone Configuration response failure`,
				schema: secondary_dns_id_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/secondary_dns/incoming",
		alias: "secondary-dns-(-secondary-zone)-secondary-zone-configuration-details",
		description: `Get secondary zone configuration for incoming zone transfers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_single_response_incoming,
		errors: [
			{
				status: NaN,
				description: `Secondary Zone Configuration Details response failure`,
				schema: secondary_dns_single_response_incoming.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/secondary_dns/incoming",
		alias: "secondary-dns-(-secondary-zone)-create-secondary-zone-configuration",
		description: `Create secondary zone configuration for incoming zone transfers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: secondary_dns_dns_secondary_secondary_zone
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_single_response_incoming,
		errors: [
			{
				status: NaN,
				description: `Create Secondary Zone Configuration response failure`,
				schema: secondary_dns_single_response_incoming.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/secondary_dns/incoming",
		alias: "secondary-dns-(-secondary-zone)-update-secondary-zone-configuration",
		description: `Update secondary zone configuration for incoming zone transfers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: secondary_dns_dns_secondary_secondary_zone
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_single_response_incoming,
		errors: [
			{
				status: NaN,
				description: `Update Secondary Zone Configuration response failure`,
				schema: secondary_dns_single_response_incoming.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/secondary_dns/outgoing",
		alias: "secondary-dns-(-primary-zone)-delete-primary-zone-configuration",
		description: `Delete primary zone configuration for outgoing zone transfers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Primary Zone Configuration response failure`,
				schema: secondary_dns_id_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/secondary_dns/outgoing",
		alias: "secondary-dns-(-primary-zone)-primary-zone-configuration-details",
		description: `Get primary zone configuration for outgoing zone transfers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_single_response_outgoing,
		errors: [
			{
				status: NaN,
				description: `Primary Zone Configuration Details response failure`,
				schema: secondary_dns_single_response_outgoing.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/secondary_dns/outgoing",
		alias: "secondary-dns-(-primary-zone)-create-primary-zone-configuration",
		description: `Create primary zone configuration for outgoing zone transfers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ id: secondary_dns_identifier, name: secondary_dns_name, peers: secondary_dns_peers }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_single_response_outgoing,
		errors: [
			{
				status: NaN,
				description: `Create Primary Zone Configuration response failure`,
				schema: secondary_dns_single_response_outgoing.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/secondary_dns/outgoing",
		alias: "secondary-dns-(-primary-zone)-update-primary-zone-configuration",
		description: `Update primary zone configuration for outgoing zone transfers.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ id: secondary_dns_identifier, name: secondary_dns_name, peers: secondary_dns_peers }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_single_response_outgoing,
		errors: [
			{
				status: NaN,
				description: `Update Primary Zone Configuration response failure`,
				schema: secondary_dns_single_response_outgoing.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/secondary_dns/outgoing/disable",
		alias: "secondary-dns-(-primary-zone)-disable-outgoing-zone-transfers",
		description: `Disable outgoing zone transfers for primary zone and clears IXFR backlog of primary zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_disable_transfer_response,
		errors: [
			{
				status: NaN,
				description: `Disable Outgoing Zone Transfers response failure`,
				schema: secondary_dns_disable_transfer_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/secondary_dns/outgoing/enable",
		alias: "secondary-dns-(-primary-zone)-enable-outgoing-zone-transfers",
		description: `Enable outgoing zone transfers for primary zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_enable_transfer_response,
		errors: [
			{
				status: NaN,
				description: `Enable Outgoing Zone Transfers response failure`,
				schema: secondary_dns_enable_transfer_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/secondary_dns/outgoing/force_notify",
		alias: "secondary-dns-(-primary-zone)-force-dns-notify",
		description: `Notifies the secondary nameserver(s) and clears IXFR backlog of primary zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_schemas_force_response,
		errors: [
			{
				status: NaN,
				description: `Force DNS NOTIFY response failure`,
				schema: secondary_dns_schemas_force_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/secondary_dns/outgoing/status",
		alias: "secondary-dns-(-primary-zone)-get-outgoing-zone-transfer-status",
		description: `Get primary zone transfer status.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.unknown()
			},
		],
		response: secondary_dns_enable_transfer_response,
		errors: [
			{
				status: NaN,
				description: `Get Outgoing Zone Transfer Status response failure`,
				schema: secondary_dns_enable_transfer_response.and(secondary_dns_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings",
		alias: "zone-settings-get-all-zone-settings",
		description: `Available settings for your user in relation to a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get all Zone settings response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings",
		alias: "zone-settings-edit-zone-settings-info",
		description: `Edit settings for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ items: z.array(zones_setting).min(1) }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_collection,
		errors: [
			{
				status: NaN,
				description: `Edit zone settings info response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/0rtt",
		alias: "zone-settings-get-0-rtt-session-resumption-setting",
		description: `Gets 0-RTT session resumption setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_0rtt }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get 0-RTT session resumption setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/0rtt",
		alias: "zone-settings-change-0-rtt-session-resumption-setting",
		description: `Changes the 0-RTT session resumption setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_0rtt_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_0rtt }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change 0-RTT session resumption setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/advanced_ddos",
		alias: "zone-settings-get-advanced-ddos-setting",
		description: `Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is &#x27;on&#x27; in the case of Business and Enterprise zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_advanced_ddos }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Advanced DDOS setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/always_online",
		alias: "zone-settings-get-always-online-setting",
		description: `When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive&#x27;s Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_always_online }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Always Online setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/always_online",
		alias: "zone-settings-change-always-online-setting",
		description: `When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive&#x27;s Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_always_online_value.default("on") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_always_online }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Always Online setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/always_use_https",
		alias: "zone-settings-get-always-use-https-setting",
		description: `Reply to all requests for URLs that use &quot;http&quot; with a 301 redirect to the equivalent &quot;https&quot; URL. If you only want to redirect for a subset of requests, consider creating an &quot;Always use HTTPS&quot; page rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_always_use_https.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Always Use HTTPS setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/always_use_https",
		alias: "zone-settings-change-always-use-https-setting",
		description: `Reply to all requests for URLs that use &quot;http&quot; with a 301 redirect to the equivalent &quot;https&quot; URL. If you only want to redirect for a subset of requests, consider creating an &quot;Always use HTTPS&quot; page rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_always_use_https_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_always_use_https.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Always Use HTTPS setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/automatic_https_rewrites",
		alias: "zone-settings-get-automatic-https-rewrites-setting",
		description: `Enable the Automatic HTTPS Rewrites feature for this zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_automatic_https_rewrites.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Automatic HTTPS Rewrites setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/automatic_https_rewrites",
		alias: "zone-settings-change-automatic-https-rewrites-setting",
		description: `Enable the Automatic HTTPS Rewrites feature for this zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_automatic_https_rewrites_value.default("on") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_automatic_https_rewrites.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Automatic HTTPS Rewrites setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/automatic_platform_optimization",
		alias: "zone-settings-get-automatic_platform_optimization-setting",
		description: `[Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/)
serves your WordPress site from Cloudflare&#x27;s edge network and caches
third-party fonts.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_automatic_platform_optimization }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Automatic Platform Optimization for WordPress setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/automatic_platform_optimization",
		alias: "zone-settings-change-automatic_platform_optimization-setting",
		description: `[Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/)
serves your WordPress site from Cloudflare&#x27;s edge network and caches
third-party fonts.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_automatic_platform_optimization }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_automatic_platform_optimization }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Automatic Platform Optimization for WordPress setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/brotli",
		alias: "zone-settings-get-brotli-setting",
		description: `When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_brotli }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Brotli setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/brotli",
		alias: "zone-settings-change-brotli-setting",
		description: `When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_brotli_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_brotli }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Brotli setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/browser_cache_ttl",
		alias: "zone-settings-get-browser-cache-ttl-setting",
		description: `Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors&#x27; computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_browser_cache_ttl }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Browser Cache TTL setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/browser_cache_ttl",
		alias: "zone-settings-change-browser-cache-ttl-setting",
		description: `Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors&#x27; computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_browser_cache_ttl_value.default(14400) }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_browser_cache_ttl }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Browser Cache TTL setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/browser_check",
		alias: "zone-settings-get-browser-check-setting",
		description: `Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_browser_check }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Browser Check setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/browser_check",
		alias: "zone-settings-change-browser-check-setting",
		description: `Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_browser_check_value.default("on") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_browser_check }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Browser Check setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/cache_level",
		alias: "zone-settings-get-cache-level-setting",
		description: `Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_cache_level }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Cache Level setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/cache_level",
		alias: "zone-settings-change-cache-level-setting",
		description: `Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_cache_level_value.default("aggressive") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_cache_level }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Cache Level setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/challenge_ttl",
		alias: "zone-settings-get-challenge-ttl-setting",
		description: `Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_challenge_ttl }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Challenge TTL setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/challenge_ttl",
		alias: "zone-settings-change-challenge-ttl-setting",
		description: `Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_challenge_ttl_value.default(1800) }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_challenge_ttl }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Challenge TTL setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/ciphers",
		alias: "zone-settings-get-ciphers-setting",
		description: `Gets ciphers setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_ciphers.default([]) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get ciphers setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/ciphers",
		alias: "zone-settings-change-ciphers-setting",
		description: `Changes ciphers setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_ciphers_value.default([]) }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_ciphers.default([]) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change ciphers setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/development_mode",
		alias: "zone-settings-get-development-mode-setting",
		description: `Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare&#x27;s accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_development_mode }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Development Mode setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/development_mode",
		alias: "zone-settings-change-development-mode-setting",
		description: `Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare&#x27;s accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_development_mode_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_development_mode }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Development Mode setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/early_hints",
		alias: "zone-settings-get-early-hints-setting",
		description: `When enabled, Cloudflare will attempt to speed up overall page loads by serving &#x60;103&#x60; responses with &#x60;Link&#x60; headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_early_hints }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Early Hints setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/early_hints",
		alias: "zone-settings-change-early-hints-setting",
		description: `When enabled, Cloudflare will attempt to speed up overall page loads by serving &#x60;103&#x60; responses with &#x60;Link&#x60; headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_early_hints_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_early_hints }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Early Hints setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/email_obfuscation",
		alias: "zone-settings-get-email-obfuscation-setting",
		description: `Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_email_obfuscation }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Email Obfuscation setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/email_obfuscation",
		alias: "zone-settings-change-email-obfuscation-setting",
		description: `Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_email_obfuscation_value.default("on") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_email_obfuscation }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Email Obfuscation setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/fonts",
		alias: "zone-settings-get-fonts-setting",
		description: `Enhance your website&#x27;s font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,
boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: speed_api_response_common.and(z.object({ result: speed_cloudflare_fonts }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Cloudflare Fonts setting response failure`,
				schema: speed_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/fonts",
		alias: "zone-settings-change-fonts-setting",
		description: `Enhance your website&#x27;s font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,
boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: speed_cloudflare_fonts_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: speed_api_response_common.and(z.object({ result: speed_cloudflare_fonts }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Cloudflare Fonts setting response failure`,
				schema: speed_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/h2_prioritization",
		alias: "zone-settings-get-h2_prioritization-setting",
		description: `Gets HTTP/2 Edge Prioritization setting.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_h2_prioritization }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get HTTP/2 Edge Prioritization setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/h2_prioritization",
		alias: "zone-settings-change-h2_prioritization-setting",
		description: `Gets HTTP/2 Edge Prioritization setting.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_h2_prioritization }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_h2_prioritization }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change HTTP/2 Edge Prioritization setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/hotlink_protection",
		alias: "zone-settings-get-hotlink-protection-setting",
		description: `When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it&#x27;s not another site requesting them. People will still be able to download and view images from your page, but other sites won&#x27;t be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_hotlink_protection }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Hotlink Protection setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/hotlink_protection",
		alias: "zone-settings-change-hotlink-protection-setting",
		description: `When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it&#x27;s not another site requesting them. People will still be able to download and view images from your page, but other sites won&#x27;t be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_hotlink_protection_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_hotlink_protection }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Hotlink Protection setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/http2",
		alias: "zone-settings-get-h-t-t-p-2-setting",
		description: `Value of the HTTP2 setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_http2 }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get HTTP2 setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/http2",
		alias: "zone-settings-change-h-t-t-p-2-setting",
		description: `Value of the HTTP2 setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_http2_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_http2 }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change HTTP2 setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/http3",
		alias: "zone-settings-get-h-t-t-p-3-setting",
		description: `Value of the HTTP3 setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_http3 }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get HTTP3 setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/http3",
		alias: "zone-settings-change-h-t-t-p-3-setting",
		description: `Value of the HTTP3 setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_http3_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_http3 }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change HTTP3 setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/image_resizing",
		alias: "zone-settings-get-image_resizing-setting",
		description: `Image Resizing provides on-demand resizing, conversion and optimisation
for images served through Cloudflare&#x27;s network. Refer to the
[Image Resizing documentation](https://developers.cloudflare.com/images/)
for more information.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_image_resizing }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Image Resizing setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/image_resizing",
		alias: "zone-settings-change-image_resizing-setting",
		description: `Image Resizing provides on-demand resizing, conversion and optimisation
for images served through Cloudflare&#x27;s network. Refer to the
[Image Resizing documentation](https://developers.cloudflare.com/images/)
for more information.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_image_resizing }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_image_resizing }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Image Resizing setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/ip_geolocation",
		alias: "zone-settings-get-ip-geolocation-setting",
		description: `Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_ip_geolocation }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get IP Geolocation setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/ip_geolocation",
		alias: "zone-settings-change-ip-geolocation-setting",
		description: `Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_ip_geolocation_value.default("on") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_ip_geolocation }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change IP Geolocation setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/ipv6",
		alias: "zone-settings-get-i-pv6-setting",
		description: `Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_ipv6 }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get IPv6 setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/ipv6",
		alias: "zone-settings-change-i-pv6-setting",
		description: `Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_ipv6_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_ipv6 }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change IPv6 setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/min_tls_version",
		alias: "zone-settings-get-minimum-tls-version-setting",
		description: `Gets Minimum TLS Version setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_min_tls_version.default("1.0") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Minimum TLS Version setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/min_tls_version",
		alias: "zone-settings-change-minimum-tls-version-setting",
		description: `Changes Minimum TLS Version setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_min_tls_version_value.default("1.0") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_min_tls_version.default("1.0") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Minimum TLS Version setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/minify",
		alias: "zone-settings-get-minify-setting",
		description: `Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_minify }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Minify setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/minify",
		alias: "zone-settings-change-minify-setting",
		description: `Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_minify_value.default({ "css": "off", "html": "off", "js": "off" }) }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_minify }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Minify setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/mirage",
		alias: "zone-settings-get-mirage-setting",
		description: `Automatically optimize image loading for website visitors on mobile
devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed)
for more information.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_mirage }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Mirage setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/mirage",
		alias: "zone-settings-change-web-mirage-setting",
		description: `Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_mirage_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_mirage }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Mirage setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/mobile_redirect",
		alias: "zone-settings-get-mobile-redirect-setting",
		description: `Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_mobile_redirect }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Mobile Redirect setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/mobile_redirect",
		alias: "zone-settings-change-mobile-redirect-setting",
		description: `Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_mobile_redirect_value.default({ "mobile_subdomain": null, "status": "off", "strip_uri": false }) }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_mobile_redirect }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Mobile Redirect setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/nel",
		alias: "zone-settings-get-nel-setting",
		description: `Enable Network Error Logging reporting on your zone. (Beta)
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_nel }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Network Error Logging setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/nel",
		alias: "zone-settings-change-nel-setting",
		description: `Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/nel-solving-mobile-speed) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_nel }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_nel }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Network Error Logging setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/opportunistic_encryption",
		alias: "zone-settings-get-opportunistic-encryption-setting",
		description: `Gets Opportunistic Encryption setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_opportunistic_encryption }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Opportunistic Encryption setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/opportunistic_encryption",
		alias: "zone-settings-change-opportunistic-encryption-setting",
		description: `Changes Opportunistic Encryption setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_opportunistic_encryption_value.default("on") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_opportunistic_encryption }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Opportunistic Encryption setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/opportunistic_onion",
		alias: "zone-settings-get-opportunistic-onion-setting",
		description: `Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_opportunistic_onion.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Opportunistic Onion setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/opportunistic_onion",
		alias: "zone-settings-change-opportunistic-onion-setting",
		description: `Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_opportunistic_onion_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_opportunistic_onion.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Opportunistic Onion setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/orange_to_orange",
		alias: "zone-settings-get-orange_to_orange-setting",
		description: `Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other
zones also on Cloudflare.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_orange_to_orange }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Orange to Orange (O2O) setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/orange_to_orange",
		alias: "zone-settings-change-orange_to_orange-setting",
		description: `Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other
zones also on Cloudflare.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_orange_to_orange }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_orange_to_orange }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Orange to Orange (O2O) setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/origin_error_page_pass_thru",
		alias: "zone-settings-get-enable-error-pages-on-setting",
		description: `Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_origin_error_page_pass_thru.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Enable Error Pages On setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/origin_error_page_pass_thru",
		alias: "zone-settings-change-enable-error-pages-on-setting",
		description: `Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_origin_error_page_pass_thru_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_origin_error_page_pass_thru.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Enable Error Pages On setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/origin_max_http_version",
		alias: "zone-cache-settings-get-origin-max-http-version-setting",
		description: `Origin Max HTTP Setting Version sets the highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). The default value is &quot;2&quot; for all plan types except ENT where it is &quot;1&quot;`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_origin_max_http_version_response_value),
		errors: [
			{
				status: NaN,
				description: `Get Origin Max HTTP Version Setting Response Failure`,
				schema: cache_zone_cache_settings_response_single.and(cache_origin_max_http_version_response_value).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/origin_max_http_version",
		alias: "zone-cache-settings-change-origin-max-http-version-setting",
		description: `Origin Max HTTP Setting Version sets the highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). The default value is &quot;2&quot; for all plan types except ENT where it is &quot;1&quot;`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: cache_origin_max_http_version_value }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: cache_zone_cache_settings_response_single.and(cache_origin_max_http_version_response_value),
		errors: [
			{
				status: NaN,
				description: `Change Origin Max HTTP Version Response Failure`,
				schema: cache_zone_cache_settings_response_single.and(cache_origin_max_http_version_response_value).and(cache_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/polish",
		alias: "zone-settings-get-polish-setting",
		description: `Automatically optimize image loading for website visitors on mobile
devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed)
for more information.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_polish }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Polish setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/polish",
		alias: "zone-settings-change-polish-setting",
		description: `Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed) for more information.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_polish }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_polish }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Polish setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/prefetch_preload",
		alias: "zone-settings-get-prefetch-preload-setting",
		description: `Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_prefetch_preload.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get prefetch preload setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/prefetch_preload",
		alias: "zone-settings-change-prefetch-preload-setting",
		description: `Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_prefetch_preload_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_prefetch_preload.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change prefetch preload setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/proxy_read_timeout",
		alias: "zone-settings-get-proxy_read_timeout-setting",
		description: `Maximum time between two read operations from origin.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_proxy_read_timeout }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Proxy Read Timeout setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/proxy_read_timeout",
		alias: "zone-settings-change-proxy_read_timeout-setting",
		description: `Maximum time between two read operations from origin.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_proxy_read_timeout }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_proxy_read_timeout }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Proxy Read Timeout setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/pseudo_ipv4",
		alias: "zone-settings-get-pseudo-i-pv4-setting",
		description: `Value of the Pseudo IPv4 setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_pseudo_ipv4 }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Pseudo IPv4 setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/pseudo_ipv4",
		alias: "zone-settings-change-pseudo-i-pv4-setting",
		description: `Value of the Pseudo IPv4 setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_pseudo_ipv4_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_pseudo_ipv4 }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Pseudo IPv4 setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/response_buffering",
		alias: "zone-settings-get-response-buffering-setting",
		description: `Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_response_buffering.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Response Buffering setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/response_buffering",
		alias: "zone-settings-change-response-buffering-setting",
		description: `Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_response_buffering_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_response_buffering.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Response Buffering setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/rocket_loader",
		alias: "zone-settings-get-rocket_loader-setting",
		description: `Rocket Loader is a general-purpose asynchronous JavaScript optimisation
that prioritises rendering your content while loading your site&#x27;s
Javascript asynchronously. Turning on Rocket Loader will immediately
improve a web page&#x27;s rendering time sometimes measured as Time to First
Paint (TTFP), and also the &#x60;window.onload&#x60; time (assuming there is
JavaScript on the page). This can have a positive impact on your Google
search ranking. When turned on, Rocket Loader will automatically defer
the loading of all Javascript referenced in your HTML, with no
configuration required. Refer to
[Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056)
for more information.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_rocket_loader }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Rocket Loader setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/rocket_loader",
		alias: "zone-settings-change-rocket_loader-setting",
		description: `Rocket Loader is a general-purpose asynchronous JavaScript optimisation
that prioritises rendering your content while loading your site&#x27;s
Javascript asynchronously. Turning on Rocket Loader will immediately
improve a web page&#x27;s rendering time sometimes measured as Time to First
Paint (TTFP), and also the &#x60;window.onload&#x60; time (assuming there is
JavaScript on the page). This can have a positive impact on your Google
search ranking. When turned on, Rocket Loader will automatically defer
the loading of all Javascript referenced in your HTML, with no
configuration required. Refer to
[Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056)
for more information.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_rocket_loader }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_rocket_loader }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Rocket Loader setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/security_header",
		alias: "zone-settings-get-security-header-(-hsts)-setting",
		description: `Cloudflare security header for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_security_header }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Security Header (HSTS) setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/security_header",
		alias: "zone-settings-change-security-header-(-hsts)-setting",
		description: `Cloudflare security header for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_security_header_value.default({ "strict_transport_security": { "enabled": true, "include_subdomains": true, "max_age": 86400, "nosniff": true } }) }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_security_header }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Security Header (HSTS) setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/security_level",
		alias: "zone-settings-get-security-level-setting",
		description: `Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_security_level }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Security Level setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/security_level",
		alias: "zone-settings-change-security-level-setting",
		description: `Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_security_level_value.default("medium") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_security_level }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Security Level setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/server_side_exclude",
		alias: "zone-settings-get-server-side-exclude-setting",
		description: `If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: &lt;!--sse--&gt;&lt;!--/sse--&gt;. For example: &lt;!--sse--&gt;  Bad visitors won&#x27;t see my phone number, 555-555-5555 &lt;!--/sse--&gt;. Note: SSE only will work with HTML. If you have HTML minification enabled, you won&#x27;t see the SSE tags in your HTML source when it&#x27;s served through Cloudflare. SSE will still function in this case, as Cloudflare&#x27;s HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor&#x27;s computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_server_side_exclude }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Server Side Exclude setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/server_side_exclude",
		alias: "zone-settings-change-server-side-exclude-setting",
		description: `If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: &lt;!--sse--&gt;&lt;!--/sse--&gt;. For example: &lt;!--sse--&gt;  Bad visitors won&#x27;t see my phone number, 555-555-5555 &lt;!--/sse--&gt;. Note: SSE only will work with HTML. If you have HTML minification enabled, you won&#x27;t see the SSE tags in your HTML source when it&#x27;s served through Cloudflare. SSE will still function in this case, as Cloudflare&#x27;s HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor&#x27;s computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_server_side_exclude_value.default("on") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_server_side_exclude }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Server Side Exclude setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/sort_query_string_for_cache",
		alias: "zone-settings-get-enable-query-string-sort-setting",
		description: `Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_sort_query_string_for_cache.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Enable Query String Sort setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/sort_query_string_for_cache",
		alias: "zone-settings-change-enable-query-string-sort-setting",
		description: `Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_sort_query_string_for_cache_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_sort_query_string_for_cache.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Enable Query String Sort setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/ssl",
		alias: "zone-settings-get-ssl-setting",
		description: `SSL encrypts your visitor&#x27;s connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don&#x27;t need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You&#x27;ll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You&#x27;ll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_ssl }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get SSL setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/ssl",
		alias: "zone-settings-change-ssl-setting",
		description: `SSL encrypts your visitor&#x27;s connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don&#x27;t need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You&#x27;ll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You&#x27;ll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_ssl_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_ssl }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change SSL setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/ssl_recommender",
		alias: "zone-settings-get-ssl_recommender-setting",
		description: `Enrollment in the SSL/TLS Recommender service which tries to detect and
recommend (by sending periodic emails) the most secure SSL/TLS setting
your origin servers support.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_ssl_recommender }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get SSL/TLS Recommender enrollment setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/ssl_recommender",
		alias: "zone-settings-change-ssl_recommender-setting",
		description: `Enrollment in the SSL/TLS Recommender service which tries to detect and
recommend (by sending periodic emails) the most secure SSL/TLS setting
your origin servers support.
`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_ssl_recommender }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_ssl_recommender }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change SSL/TLS Recommender enrollment setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/tls_1_3",
		alias: "zone-settings-get-tls-1.-3-setting-enabled-for-a-zone",
		description: `Gets TLS 1.3 setting enabled for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_tls_1_3.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get TLS 1.3 setting enabled for a zone response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/tls_1_3",
		alias: "zone-settings-change-tls-1.-3-setting",
		description: `Changes TLS 1.3 setting.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_tls_1_3_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_tls_1_3.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change TLS 1.3 setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/tls_client_auth",
		alias: "zone-settings-get-tls-client-auth-setting",
		description: `TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_tls_client_auth }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get TLS Client Auth setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/tls_client_auth",
		alias: "zone-settings-change-tls-client-auth-setting",
		description: `TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_tls_client_auth_value.default("on") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_tls_client_auth }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change TLS Client Auth setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/true_client_ip_header",
		alias: "zone-settings-get-true-client-ip-setting",
		description: `Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_true_client_ip_header.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get True Client IP setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/true_client_ip_header",
		alias: "zone-settings-change-true-client-ip-setting",
		description: `Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_true_client_ip_header_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_true_client_ip_header.default("off") }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change True Client IP setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/waf",
		alias: "zone-settings-get-web-application-firewall-(-waf)-setting",
		description: `The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will &#x27;challenge&#x27; the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare&#x27;s WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_waf }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get Web Application Firewall (WAF) setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/waf",
		alias: "zone-settings-change-web-application-firewall-(-waf)-setting",
		description: `The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will &#x27;challenge&#x27; the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare&#x27;s WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_waf_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_waf }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change Web Application Firewall (WAF) setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/webp",
		alias: "zone-settings-get-web-p-setting",
		description: `When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_webp }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get WebP setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/webp",
		alias: "zone-settings-change-web-p-setting",
		description: `When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_webp_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_webp }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change WebP setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/websockets",
		alias: "zone-settings-get-web-sockets-setting",
		description: `Gets Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_websockets }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Get WebSockets setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/settings/websockets",
		alias: "zone-settings-change-web-sockets-setting",
		description: `Changes Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ value: zones_websockets_value.default("off") }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zones_zone_settings_response_single.and(z.object({ result: zones_websockets }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Change WebSockets setting response failure`,
				schema: zones_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/zaraz/config",
		alias: "get-zones-zone_identifier-zaraz-config",
		description: `Gets latest Zaraz configuration for a zone. It can be preview or published configuration, whichever was the last updated. Secret variables values will not be included.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zaraz_zaraz_config_response,
		errors: [
			{
				status: NaN,
				description: `Get Zaraz configuration response failure`,
				schema: zaraz_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/settings/zaraz/config",
		alias: "put-zones-zone_identifier-zaraz-config",
		description: `Updates Zaraz configuration for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zaraz_zaraz_config_body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zaraz_zaraz_config_response,
		errors: [
			{
				status: NaN,
				description: `Update Zaraz configuration response failure`,
				schema: zaraz_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/zaraz/default",
		alias: "get-zones-zone_identifier-zaraz-default",
		description: `Gets default Zaraz configuration for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zaraz_zaraz_config_response,
		errors: [
			{
				status: NaN,
				description: `Get Zaraz default configuration response failure`,
				schema: zaraz_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/zaraz/export",
		alias: "get-zones-zone_identifier-zaraz-export",
		description: `Exports full current published Zaraz configuration for a zone, secret variables included.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zaraz_zaraz_config_return,
		errors: [
			{
				status: NaN,
				description: `Get Zaraz configuration response failure`,
				schema: zaraz_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/zaraz/history",
		alias: "get-zones-zone_identifier-zaraz-history",
		description: `Lists a history of published Zaraz configuration records for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "offset",
				type: "Query",
				schema: z.number().int().gte(0).optional()
			},
			{
				name: "limit",
				type: "Query",
				schema: z.number().int().gte(1).optional()
			},
			{
				name: "sortField",
				type: "Query",
				schema: z.enum(["id", "user_id", "description", "created_at", "updated_at"]).optional()
			},
			{
				name: "sortOrder",
				type: "Query",
				schema: z.enum(["DESC", "ASC"]).optional()
			},
		],
		response: zaraz_zaraz_history_response,
		errors: [
			{
				status: NaN,
				description: `List Zaraz historical configuration records failure`,
				schema: zaraz_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/settings/zaraz/history",
		alias: "put-zones-zone_identifier-zaraz-history",
		description: `Restores a historical published Zaraz configuration by ID for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.number().int().gte(1)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zaraz_zaraz_config_response,
		errors: [
			{
				status: NaN,
				description: `Restore Zaraz historical configuration by ID failure`,
				schema: zaraz_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/zaraz/history/configs",
		alias: "get-zones-zone_identifier-zaraz-config-history",
		description: `Gets a history of published Zaraz configurations by ID(s) for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "ids",
				type: "Query",
				schema: z.array(z.number())
			},
		],
		response: zaraz_zaraz_config_history_response,
		errors: [
			{
				status: NaN,
				description: `Get Zaraz historical configurations by ID(s) failure`,
				schema: zaraz_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/settings/zaraz/publish",
		alias: "post-zones-zone_identifier-zaraz-publish",
		description: `Publish current Zaraz preview configuration for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.string()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zaraz_api_response_common.and(z.object({ result: z.string() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update Zaraz workflow response failure`,
				schema: zaraz_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/settings/zaraz/workflow",
		alias: "get-zones-zone_identifier-zaraz-workflow",
		description: `Gets Zaraz workflow for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zaraz_zaraz_workflow_response,
		errors: [
			{
				status: NaN,
				description: `Get Zaraz workflow response failure`,
				schema: zaraz_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/settings/zaraz/workflow",
		alias: "put-zones-zone_identifier-zaraz-workflow",
		description: `Updates Zaraz workflow for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.enum(["realtime", "preview"])
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: zaraz_zaraz_workflow_response,
		errors: [
			{
				status: NaN,
				description: `Update Zaraz workflow response failure`,
				schema: zaraz_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/speed_api/availabilities",
		alias: "speed-get-availabilities",
		description: `Retrieves quota for all plans, as well as the current zone quota.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: observatory_availabilities_response,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: observatory_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/speed_api/pages",
		alias: "speed-list-pages",
		description: `Lists all webpages which have been tested.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: observatory_pages_response_collection,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: observatory_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/speed_api/pages/:url/tests",
		alias: "speed-delete-tests",
		description: `Deletes all tests for a specific webpage from a specific region. Deleted tests are still counted as part of the quota.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "url",
				type: "Path",
				schema: z.string()
			},
			{
				name: "region",
				type: "Query",
				schema: z.enum(["asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"]).optional()
			},
		],
		response: observatory_count_response,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: observatory_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/speed_api/pages/:url/tests",
		alias: "speed-list-test-history",
		description: `Test history (list of tests) for a specific webpage.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "url",
				type: "Path",
				schema: z.string()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().int().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().int().gte(5).lte(50).optional()
			},
			{
				name: "region",
				type: "Query",
				schema: z.enum(["asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"]).optional()
			},
		],
		response: observatory_page_test_response_collection,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: observatory_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/speed_api/pages/:url/tests",
		alias: "speed-create-test",
		description: `Starts a test for a specific webpage, in a specific region.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: speed_create_test_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "url",
				type: "Path",
				schema: z.string()
			},
		],
		response: observatory_page_test_response_single,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: observatory_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/speed_api/pages/:url/tests/:test_id",
		alias: "speed-get-test",
		description: `Retrieves the result of a specific test.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "url",
				type: "Path",
				schema: z.string()
			},
			{
				name: "test_id",
				type: "Path",
				schema: z.string()
			},
		],
		response: observatory_page_test_response_single,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: observatory_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/speed_api/pages/:url/trend",
		alias: "speed-list-page-trend",
		description: `Lists the core web vital metrics trend over time for a specific page.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "url",
				type: "Path",
				schema: z.string()
			},
			{
				name: "region",
				type: "Query",
				schema: z.enum(["asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"])
			},
			{
				name: "deviceType",
				type: "Query",
				schema: z.enum(["DESKTOP", "MOBILE"])
			},
			{
				name: "start",
				type: "Query",
				schema: z.string().datetime({ offset: true })
			},
			{
				name: "end",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "tz",
				type: "Query",
				schema: z.string()
			},
			{
				name: "metrics",
				type: "Query",
				schema: z.string()
			},
		],
		response: observatory_trend_response,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: observatory_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/speed_api/schedule/:url",
		alias: "speed-delete-test-schedule",
		description: `Deletes a scheduled test for a page.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "url",
				type: "Path",
				schema: z.string()
			},
			{
				name: "region",
				type: "Query",
				schema: z.enum(["asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"]).optional()
			},
		],
		response: observatory_count_response,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: observatory_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/speed_api/schedule/:url",
		alias: "speed-get-scheduled-test",
		description: `Retrieves the test schedule for a page in a specific region.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "url",
				type: "Path",
				schema: z.string()
			},
			{
				name: "region",
				type: "Query",
				schema: z.enum(["asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"]).optional()
			},
		],
		response: observatory_schedule_response_single,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: observatory_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/speed_api/schedule/:url",
		alias: "speed-create-scheduled-test",
		description: `Creates a scheduled test for a page.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "url",
				type: "Path",
				schema: z.string()
			},
			{
				name: "region",
				type: "Query",
				schema: z.enum(["asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1"]).optional()
			},
		],
		response: observatory_create_schedule_response,
		errors: [
			{
				status: NaN,
				description: `Failure response`,
				schema: observatory_api_response_common_failure
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/ssl/analyze",
		alias: "analyze-certificate-analyze-certificate",
		description: `Returns the set of hostnames, the signature algorithm, and the expiration date of the certificate.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: analyze_certificate_analyze_certificate_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_analyze_response,
		errors: [
			{
				status: NaN,
				description: `Analyze Certificate response failure`,
				schema: tls_certificates_and_hostnames_certificate_analyze_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/ssl/certificate_packs",
		alias: "certificate-packs-list-certificate-packs",
		description: `For a given zone, list all active certificate packs.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "status",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: tls_certificates_and_hostnames_certificate_pack_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Certificate Packs response failure`,
				schema: tls_certificates_and_hostnames_certificate_pack_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/ssl/certificate_packs/:certificate_pack_id",
		alias: "certificate-packs-delete-advanced-certificate-manager-certificate-pack",
		description: `For a given zone, delete an advanced certificate pack.`,
		requestFormat: "json",
		parameters: [
			{
				name: "certificate_pack_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_delete_advanced_certificate_pack_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete Advanced Certificate Manager Certificate Pack response failure`,
				schema: tls_certificates_and_hostnames_delete_advanced_certificate_pack_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/ssl/certificate_packs/:certificate_pack_id",
		alias: "certificate-packs-get-certificate-pack",
		description: `For a given zone, get a certificate pack.`,
		requestFormat: "json",
		parameters: [
			{
				name: "certificate_pack_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_pack_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Certificate Pack response failure`,
				schema: tls_certificates_and_hostnames_certificate_pack_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/ssl/certificate_packs/:certificate_pack_id",
		alias: "certificate-packs-restart-validation-for-advanced-certificate-manager-certificate-pack",
		description: `For a given zone, restart validation for an advanced certificate pack.  This is only a validation operation for a Certificate Pack in a validation_timed_out status.`,
		requestFormat: "json",
		parameters: [
			{
				name: "certificate_pack_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_advanced_certificate_pack_response_single,
		errors: [
			{
				status: NaN,
				description: `Restart Validation for Advanced Certificate Manager Certificate Pack response failure`,
				schema: tls_certificates_and_hostnames_advanced_certificate_pack_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/ssl/certificate_packs/order",
		alias: "certificate-packs-order-advanced-certificate-manager-certificate-pack",
		description: `For a given zone, order an advanced certificate pack.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: certificate_packs_order_advanced_certificate_manager_certificate_pack_Body
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_advanced_certificate_pack_response_single,
		errors: [
			{
				status: NaN,
				description: `Order Advanced Certificate Manager Certificate Pack response failure`,
				schema: tls_certificates_and_hostnames_advanced_certificate_pack_response_single.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/ssl/certificate_packs/quota",
		alias: "certificate-packs-get-certificate-pack-quotas",
		description: `For a given zone, list certificate pack quotas.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_certificate_pack_quota_response,
		errors: [
			{
				status: NaN,
				description: `Get Certificate Pack Quotas response failure`,
				schema: tls_certificates_and_hostnames_certificate_pack_quota_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/ssl/universal/settings",
		alias: "universal-ssl-settings-for-a-zone-universal-ssl-settings-details",
		description: `Get Universal SSL Settings for a Zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_ssl_universal_settings_response,
		errors: [
			{
				status: NaN,
				description: `Universal SSL Settings Details response failure`,
				schema: tls_certificates_and_hostnames_ssl_universal_settings_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/ssl/universal/settings",
		alias: "universal-ssl-settings-for-a-zone-edit-universal-ssl-settings",
		description: `Patch Universal SSL Settings for a Zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: tls_certificates_and_hostnames_universal
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_ssl_universal_settings_response,
		errors: [
			{
				status: NaN,
				description: `Edit Universal SSL Settings response failure`,
				schema: tls_certificates_and_hostnames_ssl_universal_settings_response.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/ssl/verification",
		alias: "ssl-verification-ssl-verification-details",
		description: `Get SSL Verification Info for a Zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "retry",
				type: "Query",
				schema: z.unknown().optional()
			},
		],
		response: z.object({ result: z.array(tls_certificates_and_hostnames_verification) }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `SSL Verification Details response failure`,
				schema: tls_certificates_and_hostnames_ssl_verification_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_id/ssl/verification/:certificate_pack_id",
		alias: "ssl-verification-edit-ssl-certificate-pack-validation-method",
		description: `Edit SSL validation method for a certificate pack. A PATCH request will request an immediate validation check on any certificate, and return the updated status. If a validation method is provided, the validation will be immediately attempted using that method.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: tls_certificates_and_hostnames_components_schemas_validation_method
			},
			{
				name: "certificate_pack_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: tls_certificates_and_hostnames_ssl_validation_method_response_collection,
		errors: [
			{
				status: NaN,
				description: `Edit SSL Certificate Pack Validation Method response failure`,
				schema: tls_certificates_and_hostnames_ssl_validation_method_response_collection.and(tls_certificates_and_hostnames_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/url_normalization",
		alias: "url-normalization-get-url-normalization-settings",
		description: `Fetches the current URL normalization settings.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: rulesets_schemas_response_model,
		errors: [
			{
				status: NaN,
				description: `Get URL normalization settings response failure`,
				schema: rulesets_schemas_response_model.and(rulesets_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/url_normalization",
		alias: "url-normalization-update-url-normalization-settings",
		description: `Updates the URL normalization settings.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: rulesets_schemas_request_model
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: rulesets_schemas_response_model,
		errors: [
			{
				status: NaN,
				description: `Update URL normalization settings response failure`,
				schema: rulesets_schemas_response_model.and(rulesets_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/workers/routes",
		alias: "worker-routes-list-routes",
		description: `Returns routes for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_route_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Routes response failure`,
				schema: workers_route_response_collection.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_id/workers/routes",
		alias: "worker-routes-create-route",
		description: `Creates a route that maps a URL pattern to a Worker.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ pattern: workers_pattern, script: workers_script_name.regex(/^[a-z0-9_][a-z0-9-_]*$/).optional() }).passthrough()
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Create Route response failure`,
				schema: workers_api_response_single.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_id/workers/routes/:route_id",
		alias: "worker-routes-delete-route",
		description: `Deletes a route.`,
		requestFormat: "json",
		parameters: [
			{
				name: "route_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete Route response failure`,
				schema: workers_api_response_single.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_id/workers/routes/:route_id",
		alias: "worker-routes-get-route",
		description: `Returns information about a route, including URL pattern and Worker.`,
		requestFormat: "json",
		parameters: [
			{
				name: "route_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_route_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Route response failure`,
				schema: workers_route_response_single.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_id/workers/routes/:route_id",
		alias: "worker-routes-update-route",
		description: `Updates the URL pattern or Worker associated with a route.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ pattern: workers_pattern, script: workers_script_name.regex(/^[a-z0-9_][a-z0-9-_]*$/).optional() }).passthrough()
			},
			{
				name: "route_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_id",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: workers_route_response_single,
		errors: [
			{
				status: NaN,
				description: `Update Route response failure`,
				schema: workers_route_response_single.and(workers_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/available_plans",
		alias: "zone-rate-plan-list-available-plans",
		description: `Lists available plans the zone can subscribe to.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_api_response_collection.and(z.object({ result: z.array(bill_subs_api_available_rate_plan) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `List Available Plans response failure`,
				schema: bill_subs_api_api_response_collection.and(z.object({ result: z.array(bill_subs_api_available_rate_plan) }).partial().passthrough()).and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/available_plans/:plan_identifier",
		alias: "zone-rate-plan-available-plan-details",
		description: `Details of the available plan that the zone can subscribe to.`,
		requestFormat: "json",
		parameters: [
			{
				name: "plan_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_api_response_single.and(z.object({ result: bill_subs_api_available_rate_plan }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Available Plan Details response failure`,
				schema: bill_subs_api_api_response_single.and(z.object({ result: bill_subs_api_available_rate_plan }).partial().passthrough()).and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/available_rate_plans",
		alias: "zone-rate-plan-list-available-rate-plans",
		description: `Lists all rate plans the zone can subscribe to.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: bill_subs_api_plan_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Available Rate Plans response failure`,
				schema: bill_subs_api_plan_response_collection.and(bill_subs_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/custom_pages",
		alias: "custom-pages-for-a-zone-list-custom-pages",
		description: `Fetches all the custom pages at the zone level.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: custom_pages_custom_pages_response_collection,
		errors: [
			{
				status: NaN,
				description: `List custom pages response failure`,
				schema: custom_pages_custom_pages_response_collection.and(custom_pages_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/custom_pages/:identifier",
		alias: "custom-pages-for-a-zone-get-a-custom-page",
		description: `Fetches the details of a custom page.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: custom_pages_custom_pages_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a custom page response failure`,
				schema: custom_pages_custom_pages_response_single.and(custom_pages_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/custom_pages/:identifier",
		alias: "custom-pages-for-a-zone-update-a-custom-page",
		description: `Updates the configuration of an existing custom page.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ state: custom_pages_state, url: custom_pages_url.url() }).passthrough()
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: custom_pages_custom_pages_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a custom page response failure`,
				schema: custom_pages_custom_pages_response_single.and(custom_pages_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/email/routing",
		alias: "email-routing-settings-get-email-routing-settings",
		description: `Get information about the settings for your Email Routing zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_email_settings_response_single,
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/email/routing/disable",
		alias: "email-routing-settings-disable-email-routing",
		description: `Disable your Email Routing zone. Also removes additional MX records previously required for Email Routing to work.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_email_settings_response_single,
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/email/routing/dns",
		alias: "email-routing-settings-email-routing-dns-settings",
		description: `Show the DNS records needed to configure your Email Routing zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_dns_settings_response_collection,
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/email/routing/enable",
		alias: "email-routing-settings-enable-email-routing",
		description: `Enable you Email Routing zone. Add and lock the necessary MX and SPF records.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_email_settings_response_single,
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/email/routing/rules",
		alias: "email-routing-routing-rules-list-routing-rules",
		description: `Lists existing routing rules.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(50).optional().default(20)
			},
			{
				name: "enabled",
				type: "Query",
				schema: z.union([z.literal(true), z.literal(false)]).optional()
			},
		],
		response: email_rules_response_collection,
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/email/routing/rules",
		alias: "email-routing-routing-rules-create-routing-rule",
		description: `Rules consist of a set of criteria for matching emails (such as an email being sent to a specific custom email address) plus a set of actions to take on the email (like forwarding it to a specific destination address).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: email_create_rule_properties
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_rule_response_single,
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/email/routing/rules/:rule_identifier",
		alias: "email-routing-routing-rules-delete-routing-rule",
		description: `Delete a specific routing rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_rule_response_single,
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/email/routing/rules/:rule_identifier",
		alias: "email-routing-routing-rules-get-routing-rule",
		description: `Get information for a specific routing rule already created.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_rule_response_single,
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/email/routing/rules/:rule_identifier",
		alias: "email-routing-routing-rules-update-routing-rule",
		description: `Update actions and matches, or enable/disable specific routing rules.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: email_update_rule_properties
			},
			{
				name: "rule_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_rule_response_single,
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/email/routing/rules/catch_all",
		alias: "email-routing-routing-rules-get-catch-all-rule",
		description: `Get information on the default catch-all routing rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_catch_all_rule_response_single,
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/email/routing/rules/catch_all",
		alias: "email-routing-routing-rules-update-catch-all-rule",
		description: `Enable or disable catch-all routing rule, or change action to forward to specific destination address.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: email_update_catch_all_rule_properties
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: email_catch_all_rule_response_single,
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/filters",
		alias: "filters-delete-filters",
		description: `Deletes one or more existing filters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: filters_delete_filters_Body
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_filter_delete_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete filters response failure`,
				schema: legacy_jhs_filter_delete_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/filters",
		alias: "filters-list-filters",
		description: `Fetches filters in a zone. You can filter the results using several optional parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "paused",
				type: "Query",
				schema: z.boolean().optional()
			},
			{
				name: "expression",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "description",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "ref",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(100).optional().default(25)
			},
			{
				name: "id",
				type: "Query",
				schema: z.string().min(32).max(32).optional()
			},
		],
		response: legacy_jhs_schemas_filter_response_collection,
		errors: [
			{
				status: NaN,
				description: `List filters response failure`,
				schema: legacy_jhs_schemas_filter_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/filters",
		alias: "filters-create-filters",
		description: `Creates one or more filters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_schemas_filter_response_collection,
		errors: [
			{
				status: NaN,
				description: `Create filters response failure`,
				schema: legacy_jhs_schemas_filter_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/filters",
		alias: "filters-update-filters",
		description: `Updates one or more existing filters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_schemas_filter_response_collection,
		errors: [
			{
				status: NaN,
				description: `Update filters response failure`,
				schema: legacy_jhs_schemas_filter_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/filters/:id",
		alias: "filters-delete-a-filter",
		description: `Deletes an existing filter.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_filter_delete_response_single,
		errors: [
			{
				status: NaN,
				description: `Delete a filter response failure`,
				schema: legacy_jhs_filter_delete_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/filters/:id",
		alias: "filters-get-a-filter",
		description: `Fetches the details of a filter.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_schemas_filter_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a filter response failure`,
				schema: legacy_jhs_schemas_filter_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/filters/:id",
		alias: "filters-update-a-filter",
		description: `Updates an existing filter.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "id",
				type: "Path",
				schema: z.string().min(32).max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_schemas_filter_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a filter response failure`,
				schema: legacy_jhs_schemas_filter_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/firewall/lockdowns",
		alias: "zone-lockdown-list-zone-lockdown-rules",
		description: `Fetches Zone Lockdown rules. You can filter the results using several optional parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "description",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "modified_on",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "ip",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "priority",
				type: "Query",
				schema: z.number().optional()
			},
			{
				name: "uri_search",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "ip_range_search",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(1000).optional().default(20)
			},
			{
				name: "created_on",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "description_search",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "ip_search",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: legacy_jhs_zonelockdown_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Zone Lockdown rules response failure`,
				schema: legacy_jhs_zonelockdown_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/firewall/lockdowns",
		alias: "zone-lockdown-create-a-zone-lockdown-rule",
		description: `Creates a new Zone Lockdown rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_zonelockdown_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a Zone Lockdown rule response failure`,
				schema: legacy_jhs_zonelockdown_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/firewall/lockdowns/:id",
		alias: "zone-lockdown-delete-a-zone-lockdown-rule",
		description: `Deletes an existing Zone Lockdown rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ result: z.object({ id: legacy_jhs_lockdowns_components_schemas_id.max(32) }).partial().passthrough() }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Delete a Zone Lockdown rule response failure`,
				schema: z.object({ result: z.object({ id: legacy_jhs_lockdowns_components_schemas_id.max(32) }).partial().passthrough() }).partial().passthrough().and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/firewall/lockdowns/:id",
		alias: "zone-lockdown-get-a-zone-lockdown-rule",
		description: `Fetches the details of a Zone Lockdown rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_zonelockdown_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a Zone Lockdown rule response failure`,
				schema: legacy_jhs_zonelockdown_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/firewall/lockdowns/:id",
		alias: "zone-lockdown-update-a-zone-lockdown-rule",
		description: `Updates an existing Zone Lockdown rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_zonelockdown_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a Zone Lockdown rule response failure`,
				schema: legacy_jhs_zonelockdown_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/firewall/rules",
		alias: "firewall-rules-delete-firewall-rules",
		description: `Deletes existing firewall rules.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: firewall_rules_delete_firewall_rules_Body
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_filter_rules_response_collection_delete,
		errors: [
			{
				status: NaN,
				description: `Delete firewall rules response failure`,
				schema: legacy_jhs_filter_rules_response_collection_delete.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/firewall/rules",
		alias: "firewall-rules-list-firewall-rules",
		description: `Fetches firewall rules in a zone. You can filter the results using several optional parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "description",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "action",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(100).optional().default(25)
			},
			{
				name: "id",
				type: "Query",
				schema: z.string().max(32).optional()
			},
			{
				name: "paused",
				type: "Query",
				schema: z.boolean().optional()
			},
		],
		response: legacy_jhs_filter_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `List firewall rules response failure`,
				schema: legacy_jhs_filter_rules_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_identifier/firewall/rules",
		alias: "firewall-rules-update-priority-of-firewall-rules",
		description: `Updates the priority of existing firewall rules.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_filter_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `Update priority of firewall rules response failure`,
				schema: legacy_jhs_filter_rules_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/firewall/rules",
		alias: "firewall-rules-create-firewall-rules",
		description: `Create one or more firewall rules.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_filter_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `Create firewall rules response failure`,
				schema: legacy_jhs_filter_rules_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/firewall/rules",
		alias: "firewall-rules-update-firewall-rules",
		description: `Updates one or more existing firewall rules.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_filter_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `Update firewall rules response failure`,
				schema: legacy_jhs_filter_rules_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/firewall/rules/:id",
		alias: "firewall-rules-delete-a-firewall-rule",
		description: `Deletes an existing firewall rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: firewall_rules_delete_a_firewall_rule_Body
			},
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_filter_rules_single_response_delete,
		errors: [
			{
				status: NaN,
				description: `Delete a firewall rule response failure`,
				schema: legacy_jhs_filter_rules_single_response_delete.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/firewall/rules/:id",
		alias: "firewall-rules-get-a-firewall-rule",
		description: `Fetches the details of a firewall rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Query",
				schema: z.string().max(32).optional()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_filter_rules_single_response,
		errors: [
			{
				status: NaN,
				description: `Get a firewall rule response failure`,
				schema: legacy_jhs_filter_rules_single_response.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_identifier/firewall/rules/:id",
		alias: "firewall-rules-update-priority-of-a-firewall-rule",
		description: `Updates the priority of an existing firewall rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_filter_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `Update priority of a firewall rule response failure`,
				schema: legacy_jhs_filter_rules_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/firewall/rules/:id",
		alias: "firewall-rules-update-a-firewall-rule",
		description: `Updates an existing firewall rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_filter_rules_single_response,
		errors: [
			{
				status: NaN,
				description: `Update a firewall rule response failure`,
				schema: legacy_jhs_filter_rules_single_response.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/firewall/ua_rules",
		alias: "user-agent-blocking-rules-list-user-agent-blocking-rules",
		description: `Fetches User Agent Blocking rules in a zone. You can filter the results using several optional parameters.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "description",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "description_search",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(1000).optional().default(20)
			},
			{
				name: "ua_search",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: legacy_jhs_firewalluablock_response_collection,
		errors: [
			{
				status: NaN,
				description: `List User Agent Blocking rules response failure`,
				schema: legacy_jhs_firewalluablock_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/firewall/ua_rules",
		alias: "user-agent-blocking-rules-create-a-user-agent-blocking-rule",
		description: `Creates a new User Agent Blocking rule in a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_firewalluablock_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a User Agent Blocking rule response failure`,
				schema: legacy_jhs_firewalluablock_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/firewall/ua_rules/:id",
		alias: "user-agent-blocking-rules-delete-a-user-agent-blocking-rule",
		description: `Deletes an existing User Agent Blocking rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_firewalluablock_response_single.and(z.object({ result: z.object({ id: legacy_jhs_ua_rules_components_schemas_id.max(32) }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete a User Agent Blocking rule response failure`,
				schema: legacy_jhs_firewalluablock_response_single.and(z.object({ result: z.object({ id: legacy_jhs_ua_rules_components_schemas_id.max(32) }).partial().passthrough() }).partial().passthrough()).and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/firewall/ua_rules/:id",
		alias: "user-agent-blocking-rules-get-a-user-agent-blocking-rule",
		description: `Fetches the details of a User Agent Blocking rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_firewalluablock_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a User Agent Blocking rule response failure`,
				schema: legacy_jhs_firewalluablock_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/firewall/ua_rules/:id",
		alias: "user-agent-blocking-rules-update-a-user-agent-blocking-rule",
		description: `Updates an existing User Agent Blocking rule.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_firewalluablock_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a User Agent Blocking rule response failure`,
				schema: legacy_jhs_firewalluablock_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/firewall/waf/overrides",
		alias: "waf-overrides-list-waf-overrides",
		description: `Fetches the URI-based WAF overrides in a zone.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(100).optional().default(50)
			},
		],
		response: legacy_jhs_override_response_collection,
		errors: [
			{
				status: NaN,
				description: `List WAF overrides response failure`,
				schema: legacy_jhs_override_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/firewall/waf/overrides",
		alias: "waf-overrides-create-a-waf-override",
		description: `Creates a URI-based WAF override for a zone.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_override_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a WAF override response failure`,
				schema: legacy_jhs_override_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/firewall/waf/overrides/:id",
		alias: "waf-overrides-delete-a-waf-override",
		description: `Deletes an existing URI-based WAF override.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ result: z.object({ id: legacy_jhs_overrides_components_schemas_id.max(32) }).partial().passthrough() }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `Delete a WAF override response failure`,
				schema: z.object({ result: z.object({ id: legacy_jhs_overrides_components_schemas_id.max(32) }).partial().passthrough() }).partial().passthrough().and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/firewall/waf/overrides/:id",
		alias: "waf-overrides-get-a-waf-override",
		description: `Fetches the details of a URI-based WAF override.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_override_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a WAF override response failure`,
				schema: legacy_jhs_override_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/firewall/waf/overrides/:id",
		alias: "waf-overrides-update-waf-override",
		description: `Updates an existing URI-based WAF override.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_override_response_single,
		errors: [
			{
				status: NaN,
				description: `Update WAF override response failure`,
				schema: legacy_jhs_override_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/firewall/waf/packages",
		alias: "waf-packages-list-waf-packages",
		description: `Fetches WAF packages for a zone.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(5).lte(100).optional().default(50)
			},
			{
				name: "order",
				type: "Query",
				schema: z.literal("name").optional()
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional()
			},
			{
				name: "match",
				type: "Query",
				schema: z.enum(["any", "all"]).optional().default("all")
			},
			{
				name: "name",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: legacy_jhs_package_response_collection,
		errors: [
			{
				status: NaN,
				description: `List WAF packages response failure`,
				schema: legacy_jhs_package_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/firewall/waf/packages/:identifier",
		alias: "waf-packages-get-a-waf-package",
		description: `Fetches the details of a WAF package.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_package_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a WAF package response failure`,
				schema: legacy_jhs_package_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_identifier/firewall/waf/packages/:identifier",
		alias: "waf-packages-update-a-waf-package",
		description: `Updates a WAF package. You can update the sensitivity and the action of an anomaly detection WAF package.

**Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: waf_packages_update_a_waf_package_Body
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_package_response_single.and(z.object({ result: legacy_jhs_anomaly_package }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Update a WAF package response failure`,
				schema: legacy_jhs_package_response_single.and(z.object({ result: legacy_jhs_anomaly_package }).partial().passthrough()).and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/healthchecks",
		alias: "health-checks-list-health-checks",
		description: `List configured health checks.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: healthchecks_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Health Checks response failure`,
				schema: healthchecks_response_collection.and(healthchecks_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/healthchecks",
		alias: "health-checks-create-health-check",
		description: `Create a new health check.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: healthchecks_query_healthcheck
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: healthchecks_single_response,
		errors: [
			{
				status: NaN,
				description: `Create Health Check response failure`,
				schema: healthchecks_single_response.and(healthchecks_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/healthchecks/:identifier",
		alias: "health-checks-delete-health-check",
		description: `Delete a health check.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: healthchecks_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Health Check response failure`,
				schema: healthchecks_id_response.and(healthchecks_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/healthchecks/:identifier",
		alias: "health-checks-health-check-details",
		description: `Fetch a single configured health check.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: healthchecks_single_response,
		errors: [
			{
				status: NaN,
				description: `Health Check Details response failure`,
				schema: healthchecks_single_response.and(healthchecks_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_identifier/healthchecks/:identifier",
		alias: "health-checks-patch-health-check",
		description: `Patch a configured health check.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: healthchecks_query_healthcheck
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: healthchecks_single_response,
		errors: [
			{
				status: NaN,
				description: `Patch Health Check response failure`,
				schema: healthchecks_single_response.and(healthchecks_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/healthchecks/:identifier",
		alias: "health-checks-update-health-check",
		description: `Update a configured health check.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: healthchecks_query_healthcheck
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: healthchecks_single_response,
		errors: [
			{
				status: NaN,
				description: `Update Health Check response failure`,
				schema: healthchecks_single_response.and(healthchecks_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/healthchecks/preview",
		alias: "health-checks-create-preview-health-check",
		description: `Create a new preview health check.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: healthchecks_query_healthcheck
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: healthchecks_single_response,
		errors: [
			{
				status: NaN,
				description: `Create Preview Health Check response failure`,
				schema: healthchecks_single_response.and(healthchecks_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/healthchecks/preview/:identifier",
		alias: "health-checks-delete-preview-health-check",
		description: `Delete a health check.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: healthchecks_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete Preview Health Check response failure`,
				schema: healthchecks_id_response.and(healthchecks_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/healthchecks/preview/:identifier",
		alias: "health-checks-health-check-preview-details",
		description: `Fetch a single configured health check preview.`,
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: healthchecks_single_response,
		errors: [
			{
				status: NaN,
				description: `Health Check Preview Details response failure`,
				schema: healthchecks_single_response.and(healthchecks_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/logs/control/retention/flag",
		alias: "logs-received-get-log-retention-flag",
		description: `Gets log retention flag for Logpull API.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: data_zone_analytics_api_flag_response,
		errors: [
			{
				status: NaN,
				description: `Get log retention flag response failure`,
				schema: data_zone_analytics_api_flag_response.and(data_zone_analytics_api_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/logs/control/retention/flag",
		alias: "logs-received-update-log-retention-flag",
		description: `Updates log retention flag for Logpull API.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: logs_received_update_log_retention_flag_Body
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: data_zone_analytics_api_flag_response,
		errors: [
			{
				status: NaN,
				description: `Update log retention flag response failure`,
				schema: data_zone_analytics_api_flag_response.and(data_zone_analytics_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/logs/rayids/:ray_identifier",
		alias: "logs-received-get-logs-ray-i-ds",
		description: `The &#x60;/rayids&#x60; api route allows lookups by specific rayid. The rayids route will return zero, one, or more records (ray ids are not unique).`,
		requestFormat: "json",
		parameters: [
			{
				name: "ray_identifier",
				type: "Path",
				schema: z.string().max(16)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "timestamps",
				type: "Query",
				schema: z.enum(["unix", "unixnano", "rfc3339"]).optional().default("unixnano")
			},
			{
				name: "fields",
				type: "Query",
				schema: z.string().optional()
			},
		],
		response: data_zone_analytics_api_logs,
		errors: [
			{
				status: NaN,
				description: `Get logs RayIDs response failure`,
				schema: data_zone_analytics_api_logs.and(data_zone_analytics_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/logs/received",
		alias: "logs-received-get-logs-received",
		description: `The &#x60;/received&#x60; api route allows customers to retrieve their edge HTTP logs. The basic access pattern is &quot;give me all the logs for zone Z for minute M&quot;, where the minute M refers to the time records were received at Cloudflare&#x27;s central data center. &#x60;start&#x60; is inclusive, and &#x60;end&#x60; is exclusive. Because of that, to get all data, at minutely cadence, starting at 10AM, the proper values are: &#x60;start&#x3D;2018-05-20T10:00:00Z&amp;end&#x3D;2018-05-20T10:01:00Z&#x60;, then &#x60;start&#x3D;2018-05-20T10:01:00Z&amp;end&#x3D;2018-05-20T10:02:00Z&#x60; and so on; the overlap will be handled properly.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "end",
				type: "Query",
				schema: end
			},
			{
				name: "sample",
				type: "Query",
				schema: z.number().gte(0).lte(1).optional()
			},
			{
				name: "timestamps",
				type: "Query",
				schema: z.enum(["unix", "unixnano", "rfc3339"]).optional().default("unixnano")
			},
			{
				name: "count",
				type: "Query",
				schema: z.number().int().gte(1).optional()
			},
			{
				name: "fields",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "start",
				type: "Query",
				schema: start
			},
		],
		response: data_zone_analytics_api_logs,
		errors: [
			{
				status: NaN,
				description: `Get logs received response failure`,
				schema: data_zone_analytics_api_logs.and(data_zone_analytics_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/logs/received/fields",
		alias: "logs-received-list-fields",
		description: `Lists all fields available. The response is json object with key-value pairs, where keys are field names, and values are descriptions.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: z.object({ key: z.string() }).partial().passthrough(),
		errors: [
			{
				status: NaN,
				description: `List fields response failure`,
				schema: data_zone_analytics_api_fields_response.and(data_zone_analytics_api_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/rate_limits",
		alias: "rate-limits-for-a-zone-list-rate-limits",
		description: `Fetches the rate limits for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional().default(1)
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(1000).optional().default(20)
			},
		],
		response: legacy_jhs_ratelimit_response_collection,
		errors: [
			{
				status: NaN,
				description: `List rate limits response failure`,
				schema: legacy_jhs_ratelimit_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/rate_limits",
		alias: "rate-limits-for-a-zone-create-a-rate-limit",
		description: `Creates a new rate limit for a zone. Refer to the object definition for a list of required attributes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_ratelimit_response_single,
		errors: [
			{
				status: NaN,
				description: `Create a rate limit response failure`,
				schema: legacy_jhs_ratelimit_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/rate_limits/:id",
		alias: "rate-limits-for-a-zone-delete-a-rate-limit",
		description: `Deletes an existing rate limit.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_ratelimit_response_single.and(z.object({ result: z.object({ id: legacy_jhs_rate_limits_components_schemas_id.max(32) }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete a rate limit response failure`,
				schema: legacy_jhs_ratelimit_response_single.and(z.object({ result: z.object({ id: legacy_jhs_rate_limits_components_schemas_id.max(32) }).partial().passthrough() }).partial().passthrough()).and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/rate_limits/:id",
		alias: "rate-limits-for-a-zone-get-a-rate-limit",
		description: `Fetches the details of a rate limit.`,
		requestFormat: "json",
		parameters: [
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_ratelimit_response_single,
		errors: [
			{
				status: NaN,
				description: `Get a rate limit response failure`,
				schema: legacy_jhs_ratelimit_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/rate_limits/:id",
		alias: "rate-limits-for-a-zone-update-a-rate-limit",
		description: `Updates an existing rate limit.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.unknown()
			},
			{
				name: "id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_ratelimit_response_single,
		errors: [
			{
				status: NaN,
				description: `Update a rate limit response failure`,
				schema: legacy_jhs_ratelimit_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/snippets",
		alias: "zone-snippets",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: snippets_api_api_response_common.and(z.object({ result: z.array(snippets_api_snippet) }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/snippets/:snippet_name",
		alias: "zone-snippets-snippet-delete",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "snippet_name",
				type: "Path",
				schema: z.string().regex(/^[A-Za-z0-9_]+$/)
			},
		],
		response: snippets_api_api_response_common,
		errors: [
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/snippets/:snippet_name",
		alias: "zone-snippets-snippet",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "snippet_name",
				type: "Path",
				schema: z.string().regex(/^[A-Za-z0-9_]+$/)
			},
		],
		response: snippets_api_api_response_common.and(z.object({ result: snippets_api_snippet }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/snippets/:snippet_name",
		alias: "zone-snippets-snippet-put",
		requestFormat: "form-data",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zone_snippets_snippet_put_Body
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "snippet_name",
				type: "Path",
				schema: z.string().regex(/^[A-Za-z0-9_]+$/)
			},
		],
		response: snippets_api_api_response_common.and(z.object({ result: snippets_api_snippet }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/snippets/:snippet_name/content",
		alias: "zone-snippets-snippet-content",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "snippet_name",
				type: "Path",
				schema: z.string().regex(/^[A-Za-z0-9_]+$/)
			},
		],
		response: z.void(),
		errors: [
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/snippets/snippet_rules",
		alias: "zone-snippets-snippet-rules",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: snippets_api_api_response_common.and(z.object({ result: snippets_api_rules }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/snippets/snippet_rules",
		alias: "zone-snippets-snippet-rules-put",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: zone_snippets_snippet_rules_put_Body
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: snippets_api_api_response_common.and(z.object({ result: snippets_api_rules }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
			{
				status: NaN,
				description: `Snippet response failure`,
				schema: snippets_api_api_response_common_failure
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/ssl/recommendation",
		alias: "ssl/-tls-mode-recommendation-ssl/-tls-recommendation",
		description: `Retrieve the SSL/TLS Recommender&#x27;s recommendation for a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_api_response_single.and(z.object({ result: z.object({ id: legacy_jhs_id, modified_on: legacy_jhs_timestamp.datetime({ offset: true }), value: legacy_jhs_ssl_recommender_components_schemas_value }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `SSL/TLS Recommendation response failure`,
				schema: legacy_jhs_api_response_single.and(z.object({ result: z.object({ id: legacy_jhs_id, modified_on: legacy_jhs_timestamp.datetime({ offset: true }), value: legacy_jhs_ssl_recommender_components_schemas_value }).partial().passthrough() }).partial().passthrough()).and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/waiting_rooms",
		alias: "waiting-room-list-waiting-rooms",
		description: `Lists waiting rooms.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_response_collection,
		errors: [
			{
				status: NaN,
				description: `List waiting rooms response failure`,
				schema: waitingroom_response_collection.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/waiting_rooms",
		alias: "waiting-room-create-waiting-room",
		description: `Creates a new waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: waitingroom_query_waitingroom
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_single_response,
		errors: [
			{
				status: NaN,
				description: `Create waiting room response failure`,
				schema: waitingroom_single_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id",
		alias: "waiting-room-delete-waiting-room",
		description: `Deletes a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_waiting_room_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete waiting room response failure`,
				schema: waitingroom_waiting_room_id_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id",
		alias: "waiting-room-waiting-room-details",
		description: `Fetches a single configured waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_single_response,
		errors: [
			{
				status: NaN,
				description: `Waiting room details response failure`,
				schema: waitingroom_single_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id",
		alias: "waiting-room-patch-waiting-room",
		description: `Patches a configured waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: waitingroom_query_waitingroom
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_single_response,
		errors: [
			{
				status: NaN,
				description: `Patch waiting room response failure`,
				schema: waitingroom_single_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id",
		alias: "waiting-room-update-waiting-room",
		description: `Updates a configured waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: waitingroom_query_waitingroom
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_single_response,
		errors: [
			{
				status: NaN,
				description: `Update waiting room response failure`,
				schema: waitingroom_single_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/events",
		alias: "waiting-room-list-events",
		description: `Lists events for a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_event_response_collection,
		errors: [
			{
				status: NaN,
				description: `List events response failure`,
				schema: waitingroom_event_response_collection.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/events",
		alias: "waiting-room-create-event",
		description: `Only available for the Waiting Room Advanced subscription. Creates an event for a waiting room. An event takes place during a specified period of time, temporarily changing the behavior of a waiting room. While the event is active, some of the properties in the event&#x27;s configuration may either override or inherit from the waiting room&#x27;s configuration. Note that events cannot overlap with each other, so only one event can be active at a time.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: waitingroom_query_event
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_event_response,
		errors: [
			{
				status: NaN,
				description: `Create event response failure`,
				schema: waitingroom_event_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/events/:event_id",
		alias: "waiting-room-delete-event",
		description: `Deletes an event for a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "event_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_event_id_response,
		errors: [
			{
				status: NaN,
				description: `Delete event response failure`,
				schema: waitingroom_event_id_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/events/:event_id",
		alias: "waiting-room-event-details",
		description: `Fetches a single configured event for a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "event_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_event_response,
		errors: [
			{
				status: NaN,
				description: `Event details response failure`,
				schema: waitingroom_event_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/events/:event_id",
		alias: "waiting-room-patch-event",
		description: `Patches a configured event for a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: waitingroom_query_event
			},
			{
				name: "event_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_event_response,
		errors: [
			{
				status: NaN,
				description: `Patch event response failure`,
				schema: waitingroom_event_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/events/:event_id",
		alias: "waiting-room-update-event",
		description: `Updates a configured event for a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: waitingroom_query_event
			},
			{
				name: "event_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_event_response,
		errors: [
			{
				status: NaN,
				description: `Update event response failure`,
				schema: waitingroom_event_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/events/:event_id/details",
		alias: "waiting-room-preview-active-event-details",
		description: `Previews an event&#x27;s configuration as if it was active. Inherited fields from the waiting room will be displayed with their current values.`,
		requestFormat: "json",
		parameters: [
			{
				name: "event_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_event_details_response,
		errors: [
			{
				status: NaN,
				description: `Preview active event details response failure`,
				schema: waitingroom_event_details_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/rules",
		alias: "waiting-room-list-waiting-room-rules",
		description: `Lists rules for a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Waiting Room Rules response failure`,
				schema: waitingroom_rules_response_collection.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/rules",
		alias: "waiting-room-create-waiting-room-rule",
		description: `Only available for the Waiting Room Advanced subscription. Creates a rule for a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ action: waitingroom_rule_action, description: waitingroom_rule_description.optional(), enabled: waitingroom_rule_enabled.optional().default(true), expression: waitingroom_rule_expression }).passthrough()
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `Create Waiting Room Rule response failure`,
				schema: waitingroom_rules_response_collection.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/rules",
		alias: "waiting-room-replace-waiting-room-rules",
		description: `Only available for the Waiting Room Advanced subscription. Replaces all rules for a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.array(waitingroom_create_rule)
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `Replace Waiting Room Rules response failure`,
				schema: waitingroom_rules_response_collection.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/rules/:rule_id",
		alias: "waiting-room-delete-waiting-room-rule",
		description: `Deletes a rule for a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "rule_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `Delete Waiting Room Rule response failure`,
				schema: waitingroom_rules_response_collection.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/rules/:rule_id",
		alias: "waiting-room-patch-waiting-room-rule",
		description: `Patches a rule for a waiting room.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: z.object({ action: waitingroom_rule_action, description: waitingroom_rule_description.optional(), enabled: waitingroom_rule_enabled.optional().default(true), expression: waitingroom_rule_expression, position: waitingroom_rule_position.optional() }).passthrough()
			},
			{
				name: "rule_id",
				type: "Path",
				schema: z.string()
			},
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_rules_response_collection,
		errors: [
			{
				status: NaN,
				description: `Patch Waiting Room Rule response failure`,
				schema: waitingroom_rules_response_collection.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/waiting_rooms/:waiting_room_id/status",
		alias: "waiting-room-get-waiting-room-status",
		description: `Fetches the status of a configured waiting room. Response fields include:
1. &#x60;status&#x60;: String indicating the status of the waiting room. The possible status are:
	- **not_queueing** indicates that the configured thresholds have not been met and all users are going through to the origin.
	- **queueing** indicates that the thresholds have been met and some users are held in the waiting room.
	- **event_prequeueing** indicates that an event is active and is currently prequeueing users before it starts.
2. &#x60;event_id&#x60;: String of the current event&#x27;s &#x60;id&#x60; if an event is active, otherwise an empty string.
3. &#x60;estimated_queued_users&#x60;: Integer of the estimated number of users currently waiting in the queue.
4. &#x60;estimated_total_active_users&#x60;: Integer of the estimated number of users currently active on the origin.
5. &#x60;max_estimated_time_minutes&#x60;: Integer of the maximum estimated time currently presented to the users.`,
		requestFormat: "json",
		parameters: [
			{
				name: "waiting_room_id",
				type: "Path",
				schema: z.unknown()
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_status_response,
		errors: [
			{
				status: NaN,
				description: `Get waiting room status response failure`,
				schema: waitingroom_status_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/waiting_rooms/preview",
		alias: "waiting-room-create-a-custom-waiting-room-page-preview",
		description: `Creates a waiting room page preview. Upload a custom waiting room page for preview. You will receive a preview URL in the form &#x60;http://waitingrooms.dev/preview/&lt;uuid&gt;&#x60;. You can use the following query parameters to change the state of the preview:
1. &#x60;force_queue&#x60;: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website (also known as queueAll).
2. &#x60;queue_is_full&#x60;: Boolean indicating if the waiting room&#x27;s queue is currently full and not accepting new users at the moment.
3. &#x60;queueing_method&#x60;: The queueing method currently used by the waiting room.
	- **fifo** indicates a FIFO queue.
	- **random** indicates a Random queue.
	- **passthrough** indicates a Passthrough queue. Keep in mind that the waiting room page will only be displayed if &#x60;force_queue&#x3D;true&#x60; or &#x60;event&#x3D;prequeueing&#x60; — for other cases the request will pass through to the origin. For our preview, this will be a fake origin website returning &quot;Welcome&quot;. 
	- **reject** indicates a Reject queue.
4. &#x60;event&#x60;: Used to preview a waiting room event.
	- **none** indicates no event is occurring.
	- **prequeueing** indicates that an event is prequeueing (between &#x60;prequeue_start_time&#x60; and &#x60;event_start_time&#x60;).
	- **started** indicates that an event has started (between &#x60;event_start_time&#x60; and &#x60;event_end_time&#x60;).
5. &#x60;shuffle_at_event_start&#x60;: Boolean indicating if the event will shuffle users in the prequeue when it starts. This can only be set to **true** if an event is active (&#x60;event&#x60; is not **none**).

For example, you can make a request to &#x60;http://waitingrooms.dev/preview/&lt;uuid&gt;?force_queue&#x3D;false&amp;queue_is_full&#x3D;false&amp;queueing_method&#x3D;random&amp;event&#x3D;started&amp;shuffle_at_event_start&#x3D;true&#x60;
6. &#x60;waitTime&#x60;: Non-zero, positive integer indicating the estimated wait time in minutes. The default value is 10 minutes.

For example, you can make a request to &#x60;http://waitingrooms.dev/preview/&lt;uuid&gt;?waitTime&#x3D;50&#x60; to configure the estimated wait time as 50 minutes.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: waitingroom_query_preview
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_preview_response,
		errors: [
			{
				status: NaN,
				description: `Create a custom waiting room page preview response failure`,
				schema: waitingroom_preview_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/waiting_rooms/settings",
		alias: "waiting-room-get-zone-settings",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_zone_settings_response,
		errors: [
			{
				status: NaN,
				description: `The current zone-level Waiting Room settings response failure`,
				schema: waitingroom_zone_settings_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_identifier/waiting_rooms/settings",
		alias: "waiting-room-patch-zone-settings",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: waitingroom_zone_settings
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_zone_settings_response,
		errors: [
			{
				status: NaN,
				description: `The zone-level Waiting Room settings response failure`,
				schema: waitingroom_zone_settings_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/waiting_rooms/settings",
		alias: "waiting-room-update-zone-settings",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: waitingroom_zone_settings
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: waitingroom_zone_settings_response,
		errors: [
			{
				status: NaN,
				description: `The zone-level Waiting Room settings response failure`,
				schema: waitingroom_zone_settings_response.and(waitingroom_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/web3/hostnames",
		alias: "web3-hostname-list-web3-hostnames",
		requestFormat: "json",
		parameters: [
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_collection_response,
		errors: [
			{
				status: NaN,
				description: `List Web3 Hostnames response failure`,
				schema: dweb_config_collection_response.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/web3/hostnames",
		alias: "web3-hostname-create-web3-hostname",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dweb_config_create_request
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_single_response,
		errors: [
			{
				status: NaN,
				description: `Create Web3 Hostname response failure`,
				schema: dweb_config_single_response.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/web3/hostnames/:identifier",
		alias: "web3-hostname-delete-web3-hostname",
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_api_response_single_id,
		errors: [
			{
				status: NaN,
				description: `Delete Web3 Hostname response failure`,
				schema: dweb_config_api_response_single_id.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/web3/hostnames/:identifier",
		alias: "web3-hostname-web3-hostname-details",
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_single_response,
		errors: [
			{
				status: NaN,
				description: `Web3 Hostname Details response failure`,
				schema: dweb_config_single_response.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "patch",
		path: "/zones/:zone_identifier/web3/hostnames/:identifier",
		alias: "web3-hostname-edit-web3-hostname",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dweb_config_modify_request
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_single_response,
		errors: [
			{
				status: NaN,
				description: `Edit Web3 Hostname response failure`,
				schema: dweb_config_single_response.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/web3/hostnames/:identifier/ipfs_universal_path/content_list",
		alias: "web3-hostname-ipfs-universal-path-gateway-content-list-details",
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_content_list_details_response,
		errors: [
			{
				status: NaN,
				description: `IPFS Universal Path Gateway Content List Details response failure`,
				schema: dweb_config_content_list_details_response.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/web3/hostnames/:identifier/ipfs_universal_path/content_list",
		alias: "web3-hostname-update-ipfs-universal-path-gateway-content-list",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dweb_config_content_list_update_request
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_content_list_details_response,
		errors: [
			{
				status: NaN,
				description: `Update IPFS Universal Path Gateway Content List response failure`,
				schema: dweb_config_content_list_details_response.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/web3/hostnames/:identifier/ipfs_universal_path/content_list/entries",
		alias: "web3-hostname-list-ipfs-universal-path-gateway-content-list-entries",
		requestFormat: "json",
		parameters: [
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_content_list_entry_collection_response,
		errors: [
			{
				status: NaN,
				description: `List IPFS Universal Path Gateway Content List Entries response failure`,
				schema: dweb_config_content_list_entry_collection_response.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone_identifier/web3/hostnames/:identifier/ipfs_universal_path/content_list/entries",
		alias: "web3-hostname-create-ipfs-universal-path-gateway-content-list-entry",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dweb_config_content_list_entry_create_request
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_content_list_entry_single_response,
		errors: [
			{
				status: NaN,
				description: `Create IPFS Universal Path Gateway Content List Entry response failure`,
				schema: dweb_config_content_list_entry_single_response.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone_identifier/web3/hostnames/:identifier/ipfs_universal_path/content_list/entries/:content_list_entry_identifier",
		alias: "web3-hostname-delete-ipfs-universal-path-gateway-content-list-entry",
		requestFormat: "json",
		parameters: [
			{
				name: "content_list_entry_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_api_response_single_id,
		errors: [
			{
				status: NaN,
				description: `Delete IPFS Universal Path Gateway Content List Entry response failure`,
				schema: dweb_config_api_response_single_id.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone_identifier/web3/hostnames/:identifier/ipfs_universal_path/content_list/entries/:content_list_entry_identifier",
		alias: "web3-hostname-ipfs-universal-path-gateway-content-list-entry-details",
		requestFormat: "json",
		parameters: [
			{
				name: "content_list_entry_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_content_list_entry_single_response,
		errors: [
			{
				status: NaN,
				description: `IPFS Universal Path Gateway Content List Entry Details response failure`,
				schema: dweb_config_content_list_entry_single_response.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone_identifier/web3/hostnames/:identifier/ipfs_universal_path/content_list/entries/:content_list_entry_identifier",
		alias: "web3-hostname-edit-ipfs-universal-path-gateway-content-list-entry",
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: dweb_config_content_list_entry_create_request
			},
			{
				name: "content_list_entry_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "identifier",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone_identifier",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: dweb_config_content_list_entry_single_response,
		errors: [
			{
				status: NaN,
				description: `Edit IPFS Universal Path Gateway Content List Entry response failure`,
				schema: dweb_config_content_list_entry_single_response.and(dweb_config_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone/spectrum/analytics/aggregate/current",
		alias: "spectrum-aggregate-analytics-get-current-aggregated-analytics",
		description: `Retrieves analytics aggregated from the last minute of usage on Spectrum applications underneath a given zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "appID",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "app_id_param",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "colo_name",
				type: "Query",
				schema: z.string().max(3).optional()
			},
		],
		response: legacy_jhs_analytics_aggregate_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `Get current aggregated analytics response failure`,
				schema: legacy_jhs_analytics_aggregate_components_schemas_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone/spectrum/analytics/events/bytime",
		alias: "spectrum-analytics-(-by-time)-get-analytics-by-time",
		description: `Retrieves a list of aggregate metrics grouped by time interval.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dimensions",
				type: "Query",
				schema: z.array(z.enum(["event", "appID", "coloName", "ipVersion"])).optional()
			},
			{
				name: "sort",
				type: "Query",
				schema: z.array(z.unknown()).optional()
			},
			{
				name: "until",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "metrics",
				type: "Query",
				schema: z.array(z.enum(["count", "bytesIngress", "bytesEgress", "durationAvg", "durationMedian", "duration90th", "duration99th"])).optional()
			},
			{
				name: "filters",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "since",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "time_delta",
				type: "Query",
				schema: z.enum(["year", "quarter", "month", "week", "day", "hour", "dekaminute", "minute"]).optional()
			},
		],
		response: legacy_jhs_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Get analytics by time response failure`,
				schema: legacy_jhs_api_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone/spectrum/analytics/events/summary",
		alias: "spectrum-analytics-(-summary)-get-analytics-summary",
		description: `Retrieves a list of summarised aggregate metrics over a given time period.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "dimensions",
				type: "Query",
				schema: z.array(z.enum(["event", "appID", "coloName", "ipVersion"])).optional()
			},
			{
				name: "sort",
				type: "Query",
				schema: z.array(z.unknown()).optional()
			},
			{
				name: "until",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
			{
				name: "metrics",
				type: "Query",
				schema: z.array(z.enum(["count", "bytesIngress", "bytesEgress", "durationAvg", "durationMedian", "duration90th", "duration99th"])).optional()
			},
			{
				name: "filters",
				type: "Query",
				schema: z.string().optional()
			},
			{
				name: "since",
				type: "Query",
				schema: z.string().datetime({ offset: true }).optional()
			},
		],
		response: legacy_jhs_api_response_single,
		errors: [
			{
				status: NaN,
				description: `Get analytics summary response failure`,
				schema: legacy_jhs_api_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone/spectrum/apps",
		alias: "spectrum-applications-list-spectrum-applications",
		description: `Retrieves a list of currently existing Spectrum applications inside a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "zone",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "page",
				type: "Query",
				schema: z.number().gte(1).optional()
			},
			{
				name: "per_page",
				type: "Query",
				schema: z.number().gte(1).lte(100).optional().default(20)
			},
			{
				name: "direction",
				type: "Query",
				schema: z.enum(["asc", "desc"]).optional().default("asc")
			},
			{
				name: "order",
				type: "Query",
				schema: z.enum(["protocol", "app_id", "created_on", "modified_on", "dns"]).optional().default("dns")
			},
		],
		response: legacy_jhs_components_schemas_response_collection,
		errors: [
			{
				status: NaN,
				description: `List Spectrum applications response failure`,
				schema: legacy_jhs_components_schemas_response_collection.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "post",
		path: "/zones/:zone/spectrum/apps",
		alias: "spectrum-applications-create-spectrum-application-using-a-name-for-the-origin",
		description: `Creates a new Spectrum application from a configuration using a name for the origin.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_Body
			},
			{
				name: "zone",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_response_single_origin_dns,
		errors: [
			{
				status: NaN,
				description: `Create Spectrum application using a name for the origin response failure`,
				schema: legacy_jhs_response_single_origin_dns.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "delete",
		path: "/zones/:zone/spectrum/apps/:app_id",
		alias: "spectrum-applications-delete-spectrum-application",
		description: `Deletes a previously existing application.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_api_response_single.and(z.object({ result: z.object({ id: legacy_jhs_app_id.max(32) }).partial().passthrough() }).partial().passthrough()),
		errors: [
			{
				status: NaN,
				description: `Delete Spectrum application response failure`,
				schema: legacy_jhs_api_response_single.and(z.object({ result: z.object({ id: legacy_jhs_app_id.max(32) }).partial().passthrough() }).partial().passthrough()).and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "get",
		path: "/zones/:zone/spectrum/apps/:app_id",
		alias: "spectrum-applications-get-spectrum-application-configuration",
		description: `Gets the application configuration of a specific application inside a zone.`,
		requestFormat: "json",
		parameters: [
			{
				name: "app_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_schemas_response_single,
		errors: [
			{
				status: NaN,
				description: `Get Spectrum application configuration response failure`,
				schema: legacy_jhs_schemas_response_single.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
	{
		method: "put",
		path: "/zones/:zone/spectrum/apps/:app_id",
		alias: "spectrum-applications-update-spectrum-application-configuration-using-a-name-for-the-origin",
		description: `Updates a previously existing application&#x27;s configuration that uses a name for the origin.`,
		requestFormat: "json",
		parameters: [
			{
				name: "body",
				type: "Body",
				schema: spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_Body
			},
			{
				name: "app_id",
				type: "Path",
				schema: z.string().max(32)
			},
			{
				name: "zone",
				type: "Path",
				schema: z.string().max(32)
			},
		],
		response: legacy_jhs_response_single_origin_dns,
		errors: [
			{
				status: NaN,
				description: `Update Spectrum application configuration using a name for the origin response failure`,
				schema: legacy_jhs_response_single_origin_dns.and(legacy_jhs_api_response_common_failure)
			},
		]
	},
]);

export const api = new Zodios(endpoints);

export function createApiClient(baseUrl: string, options?: ZodiosOptions) {
	return new Zodios(baseUrl, endpoints, options);
}
